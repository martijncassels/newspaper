"use strict";
/**
 * This exports a class that can efficiently perform stream-based parsing of multipart/form-data http values.
 * The code is tolerant in the face of errors/malformed bodies in that the parser instance can be queried
 *  after all chunks have been admitted for summaries of the various parts.
 *
 * The parser implements a determinstic state machine which let's us parse the content
 * one character at a time, without backtracking. Each state has a set of transitions that map
 * the next character to a new state.  If no match is found, each state has a "fallback state".
 *
 * Key RFCs:
 *    - RFC 2388 - Returning Values From Forms: multipart/form-data (https://www.ietf.org/rfc/rfc2388.txt)
 *    - RFC 2046 - Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types. (https://tools.ietf.org/html/rfc2046)
 *               - Note section 5.1 of 2046 for definitions on boundary delimiters.
 *    - RFC 2045 - Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies (https://tools.ietf.org/html/rfc2045)
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * An enum that defines the various states the parser can be.  To account for arbitrary boundary strings,
 * a range is left open in the enum starting at Boundary1_LeadingCR and Boundary2_LeadingCR to account for
 * first boundary delimiter, and subsequent boundary delimiters.
 */
var ParserState;
(function (ParserState) {
    ParserState[ParserState["None"] = 0] = "None";
    ParserState[ParserState["InitialState"] = 1] = "InitialState";
    ParserState[ParserState["PreambleState"] = 2] = "PreambleState";
    ParserState[ParserState["FoundBoundary_1"] = 3] = "FoundBoundary_1";
    ParserState[ParserState["FoundBoundary_1_consuming_trailing_whitespace"] = 4] = "FoundBoundary_1_consuming_trailing_whitespace";
    ParserState[ParserState["FoundBoundary_1_CR_1"] = 5] = "FoundBoundary_1_CR_1";
    ParserState[ParserState["FoundBoundary_1_LF_1"] = 6] = "FoundBoundary_1_LF_1";
    ParserState[ParserState["FoundBoundary_1_CR_2"] = 7] = "FoundBoundary_1_CR_2";
    ParserState[ParserState["FoundBoundary_1_LF_2"] = 8] = "FoundBoundary_1_LF_2";
    ParserState[ParserState["CloseBoundary_1_trailing_dash_1"] = 9] = "CloseBoundary_1_trailing_dash_1";
    ParserState[ParserState["InHeaders"] = 10] = "InHeaders";
    ParserState[ParserState["InHeader_CR_1"] = 11] = "InHeader_CR_1";
    ParserState[ParserState["InHeader_LF_1"] = 12] = "InHeader_LF_1";
    ParserState[ParserState["InHeader_CR_2"] = 13] = "InHeader_CR_2";
    ParserState[ParserState["InHeader_LF_2"] = 14] = "InHeader_LF_2";
    ParserState[ParserState["InBody"] = 15] = "InBody";
    ParserState[ParserState["FoundBoundary_2"] = 16] = "FoundBoundary_2";
    ParserState[ParserState["FoundBoundary_2_consuming_trailing_whitespace"] = 17] = "FoundBoundary_2_consuming_trailing_whitespace";
    ParserState[ParserState["FoundBoundary_2_CR_1"] = 18] = "FoundBoundary_2_CR_1";
    ParserState[ParserState["FoundBoundary_2_LF_1"] = 19] = "FoundBoundary_2_LF_1";
    ParserState[ParserState["FoundBoundary_2_CR_2"] = 20] = "FoundBoundary_2_CR_2";
    ParserState[ParserState["FoundBoundary_2_LF_2"] = 21] = "FoundBoundary_2_LF_2";
    ParserState[ParserState["CloseBoundary_2_trailing_dash_1"] = 22] = "CloseBoundary_2_trailing_dash_1";
    ParserState[ParserState["Done"] = 23] = "Done";
    ParserState[ParserState["Boundary1_LeadingCR"] = 24] = "Boundary1_LeadingCR";
    ParserState[ParserState["Boundary2_LeadingCR"] = 104] = "Boundary2_LeadingCR"; // indicates first CR of the 2nd boundary.  Add 80 to previous since max length on a boundary is 70 characters, not including leading \r\n--
})(ParserState || (ParserState = {}));
/**
 * class that performs the parsing.
 */
var MultiPartFormParser = (function () {
    function MultiPartFormParser(boundary, encoding) {
        this.boundary = boundary;
        this.encoding = encoding;
        // lookup table on how to go from one parser state to another parser state
        this.stateTable = {};
        this.parts = [];
        this.rawHeaderSections = [];
        this.consumeHeaders = false;
        this.currentCharacterIndex = 0;
        this.currentBoundaryStartIndex = 0;
        if (!boundary) {
            throw new Error('boundary string must be a valid string');
        }
        if (boundary.length > 70 || boundary.length < 1) {
            throw new Error("Boundary string has unsupported size of " + boundary.length + ".  Length is 70 characters. See RFC 2046 Section 5.1.1");
        }
        this.populateStateTable();
        this.resolveStateTable();
        this.currentState = this.stateTable[ParserState.InitialState];
    }
    /**
     * Add a chunk of body to be parsed.  Once all chunks have been added, the part summaries can
     * be retrieved by calling getParts()
     */
    MultiPartFormParser.prototype.addChunk = function (chunk) {
        if (Buffer.isBuffer(chunk)) {
            this.scanBuffer(chunk);
        }
        else if (typeof (chunk) === 'string') {
            this.scanString(chunk);
        }
        else {
            throw new Error("unexpected type " + typeof chunk + " passed to addChunk");
        }
    };
    /**
     * Retrieve known parts.  For accurate representation, should only be called after all chunks of the body have been added.
     */
    MultiPartFormParser.prototype.getParts = function () {
        return this.parts;
    };
    /**
     * Add all the state transitions for the parser
     */
    MultiPartFormParser.prototype.populateStateTable = function () {
        var _this = this;
        // first rule to get off the initial state
        this.addStateEntry(ParserState.InitialState, ParserState.PreambleState, [
            // special case if first character is a -, jump into first dash 
            { transitionChar: '-', newStateID: ParserState.Boundary1_LeadingCR + 2, onTransition: function () { _this.currentBoundaryStartIndex = _this.currentCharacterIndex; } },
            { transitionChar: '\r', newStateID: ParserState.Boundary1_LeadingCR }
        ]);
        // state transitions to go from PreambleState -> FoundBoundary_1
        this.addBoundaryStates('\r\n--' + this.boundary, ParserState.PreambleState, ParserState.FoundBoundary_1, ParserState.PreambleState, ParserState.Boundary1_LeadingCR);
        // from FoundBoundary state to consuming whitespace
        this.addStateEntry(ParserState.FoundBoundary_1, ParserState.PreambleState, [
            { transitionChar: '-', newStateID: ParserState.CloseBoundary_1_trailing_dash_1 },
            { transitionChar: ' ', newStateID: ParserState.FoundBoundary_1_consuming_trailing_whitespace },
            { transitionChar: '\t', newStateID: ParserState.FoundBoundary_1_consuming_trailing_whitespace },
            { transitionChar: '\n', newStateID: ParserState.FoundBoundary_1_consuming_trailing_whitespace },
            { transitionChar: '\r', newStateID: ParserState.FoundBoundary_1_CR_1 }
        ]);
        // '-' => Done.  2nd dash after boundary indicates we're done
        this.addStateEntry(ParserState.CloseBoundary_1_trailing_dash_1, ParserState.PreambleState, [{ transitionChar: '-', newStateID: ParserState.Done, onTransition: function () { _this.notifyDone(); } },
            { transitionChar: '\r', newStateID: ParserState.Boundary1_LeadingCR, onTransition: function () { _this.currentBoundaryStartIndex = _this.currentCharacterIndex; } }
        ]);
        // consume any remaining characters after done state
        this.addStateEntry(ParserState.Done, ParserState.Done, []);
        // rules to consume trailing whitespace after a boundary
        this.addStateEntry(ParserState.FoundBoundary_1_consuming_trailing_whitespace, ParserState.PreambleState, [
            { transitionChar: ' ', newStateID: ParserState.FoundBoundary_1_consuming_trailing_whitespace },
            { transitionChar: '\t', newStateID: ParserState.FoundBoundary_1_consuming_trailing_whitespace },
            { transitionChar: '\r', newStateID: ParserState.FoundBoundary_1_CR_1 },
            { transitionChar: '\n', newStateID: ParserState.FoundBoundary_1_consuming_trailing_whitespace } // a \n w/out being preceded by \r is considered whitespace
        ]);
        // rules to transition from CR_1 after boundary
        this.addStateEntry(ParserState.FoundBoundary_1_CR_1, ParserState.PreambleState, [
            { transitionChar: '\n', newStateID: ParserState.FoundBoundary_1_LF_1 },
            { transitionChar: ' ', newStateID: ParserState.FoundBoundary_1_consuming_trailing_whitespace },
            { transitionChar: '\t', newStateID: ParserState.FoundBoundary_1_consuming_trailing_whitespace },
            { transitionChar: '\r', newStateID: ParserState.FoundBoundary_1_CR_1 }
        ]);
        // rules to go from FoundBoundary_LF_1 => FoundBoundary_CR_2
        this.addStateEntry(ParserState.FoundBoundary_1_LF_1, ParserState.InHeaders, [
            { transitionChar: '\r', newStateID: ParserState.FoundBoundary_1_CR_2 }
        ], function () { _this.notifyStartHeaderSection(); });
        // rules to go from FoundBoundary_CR_2 => FoundBoundary_LF_2
        this.addStateEntry(ParserState.FoundBoundary_1_CR_2, ParserState.InHeaders, [
            { transitionChar: '\n', newStateID: ParserState.FoundBoundary_1_LF_2 }
        ], function () { _this.notifyStartHeaderSection(); });
        // rules to go from FoundBoundary_CR_2 => FoundBoundary_LF_2.  CRLFCRLF after boundary means no headers, and go directly into InBody 
        this.addStateEntry(ParserState.FoundBoundary_1_LF_2, ParserState.InBody, [], function () {
            _this.notifyStartHeaderSection();
            _this.notifyEndHeaderSection();
            _this.notifyStartBodySection();
        });
        // rules to go from InHeaders -> InBody
        this.addStateEntry(ParserState.InHeaders, ParserState.InHeaders, [
            { transitionChar: '\r', newStateID: ParserState.InHeader_CR_1 }
        ]);
        this.addStateEntry(ParserState.InHeader_CR_1, ParserState.InHeaders, [
            { transitionChar: '\n', newStateID: ParserState.InHeader_LF_1 }
        ]);
        this.addStateEntry(ParserState.InHeader_LF_1, ParserState.InHeaders, [
            { transitionChar: '\r', newStateID: ParserState.InHeader_CR_2 },
            { transitionChar: '-', newStateID: ParserState.Boundary2_LeadingCR + 2, onTransition: function () { _this.currentBoundaryStartIndex = _this.currentCharacterIndex - 2; } }
        ]);
        this.addStateEntry(ParserState.InHeader_CR_2, ParserState.InHeaders, [
            { transitionChar: '\n', newStateID: ParserState.InHeader_LF_2 }
        ]);
        this.addStateEntry(ParserState.InHeader_LF_2, ParserState.InBody, [], function () {
            _this.notifyEndHeaderSection();
            _this.notifyStartBodySection();
        });
        // transition from InBody -> FoundBoundary_2
        this.addBoundaryStates('\r\n--' + this.boundary, ParserState.InBody, ParserState.FoundBoundary_2, ParserState.InBody, ParserState.Boundary2_LeadingCR);
        // from FoundBoundary state to consuming whitespace
        this.addStateEntry(ParserState.FoundBoundary_2, ParserState.InBody, [
            { transitionChar: '-', newStateID: ParserState.CloseBoundary_2_trailing_dash_1 },
            { transitionChar: ' ', newStateID: ParserState.FoundBoundary_2_consuming_trailing_whitespace },
            { transitionChar: '\t', newStateID: ParserState.FoundBoundary_2_consuming_trailing_whitespace },
            { transitionChar: '\n', newStateID: ParserState.FoundBoundary_2_consuming_trailing_whitespace },
            { transitionChar: '\r', newStateID: ParserState.FoundBoundary_2_CR_1 }
        ]);
        // '-' => Done.  2nd dash after boundary indicates we're done
        this.addStateEntry(ParserState.CloseBoundary_2_trailing_dash_1, ParserState.InBody, [{
                transitionChar: '-', newStateID: ParserState.Done,
                onTransition: function () {
                    _this.notifyEndBodySection();
                    _this.notifyDone();
                }
            },
            { transitionChar: '\r', newStateID: ParserState.Boundary2_LeadingCR, onTransition: function () { _this.currentBoundaryStartIndex = _this.currentCharacterIndex; } }
        ]);
        // rules to consume trailing whitespace after a boundary
        this.addStateEntry(ParserState.FoundBoundary_2_consuming_trailing_whitespace, ParserState.InBody, [
            { transitionChar: ' ', newStateID: ParserState.FoundBoundary_2_consuming_trailing_whitespace },
            { transitionChar: '\t', newStateID: ParserState.FoundBoundary_2_consuming_trailing_whitespace },
            { transitionChar: '\r', newStateID: ParserState.FoundBoundary_2_CR_1 },
            { transitionChar: '\n', newStateID: ParserState.FoundBoundary_2_consuming_trailing_whitespace } // a \n w/out being preceded by \r is considered whitespace
        ]);
        // rules to transition from CR_1 after boundary
        this.addStateEntry(ParserState.FoundBoundary_2_CR_1, ParserState.InBody, [
            { transitionChar: '\n', newStateID: ParserState.FoundBoundary_2_LF_1 },
            { transitionChar: ' ', newStateID: ParserState.FoundBoundary_2_consuming_trailing_whitespace },
            { transitionChar: '\t', newStateID: ParserState.FoundBoundary_2_consuming_trailing_whitespace },
            { transitionChar: '\r', newStateID: ParserState.FoundBoundary_2_CR_1 }
        ]);
        // rules to go from FoundBoundary_LF_1 => FoundBoundary_CR_2
        this.addStateEntry(ParserState.FoundBoundary_2_LF_1, ParserState.InHeaders, [
            { transitionChar: '\r', newStateID: ParserState.FoundBoundary_2_CR_2 }
        ], function () {
            _this.notifyEndBodySection();
            _this.notifyStartHeaderSection();
        });
        // rules to go from FoundBoundary_CR_2 => FoundBoundary_LF_2
        this.addStateEntry(ParserState.FoundBoundary_2_CR_2, ParserState.InHeaders, [
            { transitionChar: '\n', newStateID: ParserState.FoundBoundary_2_LF_2 }
        ], function () {
            _this.notifyEndBodySection();
            _this.notifyStartHeaderSection();
        });
        // rules to go from FoundBoundary_CR_2 => FoundBoundary_LF_2.  CRLFCRLF after boundary means no headers, and go directly into InBody 
        this.addStateEntry(ParserState.FoundBoundary_2_LF_2, ParserState.InBody, [], function () {
            _this.notifyEndBodySection();
            _this.notifyStartHeaderSection();
            _this.notifyEndHeaderSection();
            _this.notifyStartBodySection();
        });
    };
    /**
     * resolves indexes for transition states to their state entry instances.  Avoids any runtime lookups into state table
     */
    MultiPartFormParser.prototype.resolveStateTable = function () {
        for (var k in this.stateTable) {
            if (this.stateTable.hasOwnProperty(k)) {
                var e = this.stateTable[k];
                e.fallBackStateEntry = this.stateTable[e.fallBackStateID];
                for (var i = 0; i < e.transitions.length; i++) {
                    e.transitions[i].newStateEntry = this.stateTable[e.transitions[i].newStateID];
                }
            }
        }
    };
    /**
     *  Add a state entry to the state table.  Transitions from `initialState` are defined by the entries in `transitions` array.
     */
    MultiPartFormParser.prototype.addStateEntry = function (initialState, fallBackStateID, transitions, onFallback, debugDescription) {
        var t = {
            stateID: initialState,
            fallBackStateID: fallBackStateID,
            transitions: transitions,
            onFallback: onFallback,
            description: debugDescription || "initialState: " + ParserState[initialState] + ", finalState: " + ParserState[fallBackStateID] + ", fallbackState = " + ParserState[fallBackStateID]
        };
        if (this.stateTable[initialState]) {
            throw new Error("unexpected found existing transition table entry for state " + ParserState[initialState]);
        }
        this.stateTable[initialState] = t;
    };
    /**
     * Add a set of state transitions for a boundary string.  e.g., `--boundary-delimiter-1`
     *
     * @s: the string to construct state entries for.  A "minor state" will be constructed for each character in this string
     * @initialState:  the initial state of the parser to apply this rule.
     * @finalTransitionState:  the final state we will transition too if the string is matched.
     * @fallBackState:  The fallback state we will revert to if we don't match a character.
     * @nextStateId:  The number at which we should start assigning state IDs.  This should be unique among all the state entries
     */
    MultiPartFormParser.prototype.addBoundaryStates = function (s, initialState, finalTransitionState, fallBackState, nextStateId) {
        var _this = this;
        var startState = initialState;
        for (var i = 0; i < s.length; i++) {
            var currentTransitionId = nextStateId++;
            var transition = {
                transitionChar: s[i],
                newStateID: i === s.length - 1 ? finalTransitionState : currentTransitionId
            };
            // special case to capture the index of the start of the next potential boundary delimiter.
            if (i === 0) {
                transition.onTransition = function () { _this.currentBoundaryStartIndex = _this.currentCharacterIndex; };
            }
            this.addStateEntry(startState, fallBackState, [transition], undefined, "intialState: " + ParserState[initialState] + ", finalState: " + ParserState[finalTransitionState] + ", fallbackState = " + ParserState[fallBackState] + ", i = " + i + ", s = " + s);
            startState = transition.newStateID;
        }
    };
    MultiPartFormParser.prototype.notifyStartHeaderSection = function () {
        this.rawHeaderSections.push('');
        this.parts.push({
            rawHeaders: '',
            bodyStartIndex: -1,
            bodyEndIndex: -1
        });
        this.consumeHeaders = true;
    };
    MultiPartFormParser.prototype.notifyEndHeaderSection = function () {
        this.consumeHeaders = false;
        var summary = this.parts[this.parts.length - 1];
        summary.rawHeaders = summary.rawHeaders.trim();
    };
    MultiPartFormParser.prototype.notifyStartBodySection = function () {
        var summary = this.parts[this.parts.length - 1];
        summary.bodyStartIndex = this.currentCharacterIndex;
    };
    MultiPartFormParser.prototype.notifyEndBodySection = function () {
        var summary = this.parts[this.parts.length - 1];
        if (summary.bodyStartIndex >= 0) {
            summary.bodyEndIndex = this.currentBoundaryStartIndex;
        }
    };
    MultiPartFormParser.prototype.notifyNextCharacter = function (c) {
        if (this.consumeHeaders) {
            this.parts[this.parts.length - 1].rawHeaders += c;
        }
    };
    MultiPartFormParser.prototype.notifyDone = function () {
        // no-op
    };
    /**
     * scan a buffer that has been added to
     */
    MultiPartFormParser.prototype.scanBuffer = function (chunk) {
        // TODO - work directly on buffer w/out converting to a string
        // not sure what is more efficient here.  We should be able to look at a sequence of characters
        // 
        var s = chunk.toString(this.encoding);
        this.scanString(s);
    };
    /**
     * scan a string of characters that has been added
     */
    MultiPartFormParser.prototype.scanString = function (chunk) {
        for (var currIndex = 0; currIndex < chunk.length; currIndex++) {
            var currChar = chunk[currIndex];
            var stateEntry = this.currentState;
            var isMatch = false;
            for (var j = 0; j < stateEntry.transitions.length; j++) {
                var transition = stateEntry.transitions[j];
                if (currChar === transition.transitionChar) {
                    isMatch = true;
                    this.currentState = transition.newStateEntry;
                    if (transition.onTransition) {
                        transition.onTransition();
                    }
                    break;
                }
            }
            if (!isMatch) {
                if (this.currentState.stateID !== stateEntry.fallBackStateID) {
                    this.currentState = stateEntry.fallBackStateEntry;
                    if (stateEntry.onFallback) {
                        stateEntry.onFallback();
                    }
                }
            }
            if (this.consumeHeaders) {
                this.notifyNextCharacter(currChar);
            }
            this.currentCharacterIndex++;
        }
    };
    return MultiPartFormParser;
}());
exports.MultiPartFormParser = MultiPartFormParser;

//# sourceMappingURL=../../maps/util/MultiPartFormParser.js.map
