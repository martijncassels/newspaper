'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var uuid_1 = require("uuid");
var Tracing_1 = require("../Tracing");
var HttpEvents_1 = require("./HttpEvents");
var HttpClientProxy = (function () {
    function HttpClientProxy() {
        this.proxiedModules = [];
    }
    // Helper methods for publishing events. We break these out into separate
    // methods so we can enforce type checking for the event interfaces
    HttpClientProxy.prototype.publishRequestCreatedEvent = function (data) {
        Tracing_1.default.publish(HttpEvents_1.EVENT_HTTP_CLIENT_REQUEST_CREATED, data);
    };
    HttpClientProxy.prototype.publishRequestDataSentEvent = function (data) {
        Tracing_1.default.publish(HttpEvents_1.EVENT_HTTP_CLIENT_REQUEST_DATA_SENT, data);
    };
    HttpClientProxy.prototype.publishRequestEndEvent = function (data) {
        Tracing_1.default.publish(HttpEvents_1.EVENT_HTTP_CLIENT_REQUEST_END, data);
    };
    HttpClientProxy.prototype.publishRequestErrorEvent = function (data) {
        Tracing_1.default.publish(HttpEvents_1.EVENT_HTTP_CLIENT_REQUEST_ERROR, data);
    };
    HttpClientProxy.prototype.publishResponseReceivedEvent = function (data) {
        Tracing_1.default.publish(HttpEvents_1.EVENT_HTTP_CLIENT_RESPONSE_RECEIVED, data);
    };
    HttpClientProxy.prototype.publishResponseDataReceivedEvent = function (data) {
        Tracing_1.default.publish(HttpEvents_1.EVENT_HTTP_CLIENT_RESPONSE_DATA_RECEIVED, data);
    };
    HttpClientProxy.prototype.publishResponseEndEvent = function (data) {
        Tracing_1.default.publish(HttpEvents_1.EVENT_HTTP_CLIENT_RESPONSE_END, data);
    };
    HttpClientProxy.prototype.publishResponseErrorEvent = function (data) {
        Tracing_1.default.publish(HttpEvents_1.EVENT_HTTP_CLIENT_RESPONSE_ERROR, data);
    };
    HttpClientProxy.prototype.init = function (moduleInfo) {
        var httpModule = moduleInfo.originalModule;
        if (this.proxiedModules.indexOf(httpModule) !== -1) {
            throw new Error('Cannot proxy a module that has already been proxied');
        }
        this.proxiedModules.push(httpModule);
        var oldRequest = httpModule.request;
        var self = this;
        httpModule.request = function request(options) {
            var requestArgs = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                requestArgs[_i - 1] = arguments[_i];
            }
            var req = oldRequest.call.apply(oldRequest, [this, options].concat(requestArgs));
            var id = uuid_1.v1();
            if (Tracing_1.default.isEventEnabled(HttpEvents_1.EVENT_HTTP_CLIENT_REQUEST_CREATED)) {
                self.publishRequestCreatedEvent({ id: id, req: req, options: options });
            }
            req.on('response', function (res) {
                if (Tracing_1.default.isEventEnabled(HttpEvents_1.EVENT_HTTP_CLIENT_RESPONSE_RECEIVED)) {
                    self.publishResponseReceivedEvent({ id: id, req: req, res: res });
                }
                res.on('data', function (chunk) {
                    if (Tracing_1.default.isEventEnabled(HttpEvents_1.EVENT_HTTP_CLIENT_RESPONSE_DATA_RECEIVED)) {
                        self.publishResponseDataReceivedEvent({ id: id, req: req, res: res, chunk: chunk });
                    }
                });
                res.on('end', function () {
                    if (Tracing_1.default.isEventEnabled(HttpEvents_1.EVENT_HTTP_CLIENT_RESPONSE_END)) {
                        self.publishResponseEndEvent({ id: id, req: req, res: res });
                    }
                });
                res.on('error', function (error) {
                    if (Tracing_1.default.isEventEnabled(HttpEvents_1.EVENT_HTTP_CLIENT_RESPONSE_ERROR)) {
                        self.publishResponseErrorEvent({ id: id, req: req, res: res, error: error });
                    }
                });
            });
            req.on('error', function (error) {
                if (Tracing_1.default.isEventEnabled(HttpEvents_1.EVENT_HTTP_CLIENT_REQUEST_ERROR)) {
                    self.publishRequestErrorEvent({ id: id, req: req, error: error });
                }
            });
            // Note: it's possible to write data using the `end` method as well,
            // but that method calls `write` under the hood, and patching both
            // leads to a doubly patched write method, which duplicates the body
            var oldWrite = req.write;
            req.write = function (chunk) {
                var writeArgs = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    writeArgs[_i - 1] = arguments[_i];
                }
                var result = oldWrite.call.apply(oldWrite, [this, chunk].concat(writeArgs));
                if ((typeof chunk === 'string' || Buffer.isBuffer(chunk)) &&
                    Tracing_1.default.isEventEnabled(HttpEvents_1.EVENT_HTTP_CLIENT_REQUEST_DATA_SENT)) {
                    self.publishRequestDataSentEvent({ id: id, req: req, chunk: chunk });
                }
                return result;
            };
            var oldEnd = req.end;
            req.end = function end() {
                var endArgs = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    endArgs[_i] = arguments[_i];
                }
                var result = oldEnd.apply(this, endArgs);
                if (Tracing_1.default.isEventEnabled(HttpEvents_1.EVENT_HTTP_CLIENT_REQUEST_END)) {
                    self.publishRequestEndEvent({ id: id, req: req });
                }
                return result;
            };
            return req;
        };
    };
    return HttpClientProxy;
}());
exports.HttpClientProxy = HttpClientProxy;

//# sourceMappingURL=../../../maps/tracing/module_instrumentors/HttpClientProxy.js.map
