'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var ExpressEvents_1 = require("./ExpressEvents");
var Tracing_1 = require("../Tracing");
var _ = require("lodash");
/* tslint:disable:no-var-requires */
var httpCommon = require('_http_common');
/* tslint:disable:no-var-requires */
var ExpressProxyMiddleware = (function () {
    function ExpressProxyMiddleware() {
    }
    ExpressProxyMiddleware.init = function (express) {
        this.setupRouteMethodMiddleware(express);
        this.setupRouterMiddleware(express);
        this.setupStaticMiddleware(express);
    };
    // NOTE: Express uses the 'methods' package to generate the list below.
    //       The 'methods' package relies on the Node 'http' module, which
    //       relies on the _http_common module.  Importing the 'http' module
    //       in a proxy seems to confuse proxy-ing, but importing _http_common
    //       seems to work OK.
    // see https://github.com/jshttp/methods/blob/master/index.js#L40-L68 for origin of list below.
    ExpressProxyMiddleware.getMethods = function () {
        if (!ExpressProxyMiddleware.methods) {
            ExpressProxyMiddleware.methods = httpCommon.methods.slice().sort();
            ExpressProxyMiddleware.methods = ExpressProxyMiddleware.methods.map(function lowerCaseMethod(method) {
                return method.toLowerCase();
            });
        }
        return ExpressProxyMiddleware.methods;
    };
    ExpressProxyMiddleware.setupRouteMethod = function (express, method) {
        var oldMethod = express.Route.prototype[method];
        if (oldMethod) {
            express.Route.prototype[method] = function newMethod() {
                if (Tracing_1.default.isEventEnabled(ExpressEvents_1.EVENT_EXPRESS_INVOKE_PRE_ROUTE_METHOD)) {
                    var data = {
                        originalThis: this,
                        originalArgs: arguments,
                        methodName: method,
                        proxyFunction: newMethod
                    };
                    Tracing_1.default.publish(ExpressEvents_1.EVENT_EXPRESS_INVOKE_PRE_ROUTE_METHOD, data);
                }
                return oldMethod.apply(this, arguments);
            };
        }
    };
    ExpressProxyMiddleware.setupRouteMethodMiddleware = function (express) {
        var _this = this;
        ExpressProxyMiddleware.getMethods().concat('all').forEach(function (method) {
            _this.setupRouteMethod(express, method);
        });
    };
    ExpressProxyMiddleware.setupRouterNaming = function (express) {
        var oldRouter = express.Router;
        var newRouter = function newRouter() {
            var router = oldRouter.apply(this, arguments);
            if (Tracing_1.default.isEventEnabled(ExpressEvents_1.EVENT_EXPRESS_INVOKE_PRE_ROUTER)) {
                var data = {
                    originalThis: this,
                    originalArgs: arguments,
                    router: router
                };
                Tracing_1.default.publish(ExpressEvents_1.EVENT_EXPRESS_INVOKE_PRE_ROUTER, data);
                router = data.router;
            }
            return router;
        };
        _.assign(newRouter, oldRouter);
        express.Router = newRouter;
    };
    ExpressProxyMiddleware.setupRouterMiddleware = function (express) {
        var oldUse = express.Router.use;
        express.Router.use = function newUse() {
            if (Tracing_1.default.isEventEnabled(ExpressEvents_1.EVENT_EXPRESS_INVOKE_PRE_ROUTER_USE)) {
                var data = {
                    originalThis: this,
                    originalArgs: arguments,
                    proxyFunction: newUse
                };
                Tracing_1.default.publish(ExpressEvents_1.EVENT_EXPRESS_INVOKE_PRE_ROUTER_USE, data);
            }
            return oldUse.apply(this, arguments);
        };
        // NOTE: Because Express captures the Router properties upon creation, all patching of Router functions
        //       must happen before patching the Router function itself (e.g. for naming).
        this.setupRouterNaming(express);
    };
    ExpressProxyMiddleware.setupStaticMiddleware = function (express) {
        var oldStatic = express.static;
        express.static = function newQuery() {
            var middleware = oldStatic.apply(this, arguments);
            if (Tracing_1.default.isEventEnabled(ExpressEvents_1.EVENT_EXPRESS_INVOKE_PRE_STATIC)) {
                var data = {
                    originalThis: this,
                    originalArgs: arguments,
                    middleware: middleware
                };
                Tracing_1.default.publish(ExpressEvents_1.EVENT_EXPRESS_INVOKE_PRE_STATIC, data);
            }
            return middleware;
        };
    };
    return ExpressProxyMiddleware;
}());
exports.ExpressProxyMiddleware = ExpressProxyMiddleware;

//# sourceMappingURL=../../../maps/tracing/module_instrumentors/ExpressProxyMiddleware.js.map
