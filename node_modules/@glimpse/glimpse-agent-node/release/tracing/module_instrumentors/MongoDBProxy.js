'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var Tracing_1 = require("../Tracing");
var moment = require("moment");
var MongoDBEvents_1 = require("./MongoDBEvents");
;
var MongoDBProxy = (function () {
    function MongoDBProxy() {
        this.realCollectionMethods = {};
        this.realCursorMethods = {};
    }
    MongoDBProxy.prototype.init = function (mongodbModule, resolvedPath) {
        var self = this;
        /**
         * override of mongodb Collection.prototype.insert
         */
        function insertProxy() {
            var args = MongoDBProxy.swizzleArgs(arguments);
            if (Tracing_1.default.isEventEnabled(MongoDBEvents_1.EVENT_MONGODB_COLLECTION_INSERT)) {
                var data = {
                    originalArgs: args
                };
                Tracing_1.default.publish(MongoDBEvents_1.EVENT_MONGODB_COLLECTION_INSERT, data);
            }
            return self.realCollectionMethods.insert.apply(this, args);
        }
        // Collection overrides
        this.addProxyForCollectionMethod('insert', insertProxy, mongodbModule);
        this.setupCollectionProxy(['deleteMany', 'deleteOne', 'findOneAndDelete', 'remove'], this.deleteProxy, mongodbModule);
        this.setupCollectionProxy(['insertMany', 'insertOne'], this.insertMethodsProxy, mongodbModule);
        this.setupCollectionProxy(['updateOne', 'updateMany', 'replaceOne', 'findOneAndUpdate'], this.updateProxy, mongodbModule);
        this.setupCollectionProxy(['count'], this.collectionReadProxy, mongodbModule);
        // Cursor overrides
        this.setupCursorProxy(['toArray', 'next', 'nextObject'], this.cursorStartReadProxyCallbackOrPromise, mongodbModule);
        this.setupCursorProxy(['forEach', 'each'], this.cursorStartReadProxyCallbackNoPromise, mongodbModule);
        this.setupCursorProxy(['close'], this.cursorCloseProxy, mongodbModule);
    };
    ;
    /**
     * Add a proxy for a mongoDB collection method
     */
    MongoDBProxy.prototype.setupCollectionProxy = function (targets, proxyHelper, mongoDBModule) {
        var _this = this;
        var self = this;
        for (var i = 0; i < targets.length; i++) {
            (function (key) {
                function proxy() {
                    return proxyHelper.call(self, key, this, arguments);
                }
                _this.addProxyForCollectionMethod(key, proxy, mongoDBModule);
            })(targets[i]);
        }
    };
    /**
     * Add a proxy for a mongoDB collection method
     */
    MongoDBProxy.prototype.setupCursorProxy = function (targets, proxyHelper, mongoDBModule) {
        var _this = this;
        var self = this;
        for (var i = 0; i < targets.length; i++) {
            (function (key) {
                function proxy() {
                    return proxyHelper.call(self, key, this, arguments);
                }
                _this.addProxyForCursorMethod(key, proxy, mongoDBModule);
            })(targets[i]);
        }
    };
    /**
     *  helper method to hookup up a proxy method on the mongoDB collection class
     */
    MongoDBProxy.prototype.addProxyForCollectionMethod = function (key, proxy, mongodb) {
        this.realCollectionMethods[key] = mongodb.Collection.prototype[key];
        mongodb.Collection.prototype[key] = proxy;
    };
    ;
    /**
     * helper method to hookup up a proxy method on the mongoDB cursor class
     */
    MongoDBProxy.prototype.addProxyForCursorMethod = function (key, proxy, mongodb) {
        this.realCursorMethods[key] = mongodb.Cursor.prototype[key];
        mongodb.Cursor.prototype[key] = proxy;
    };
    /**
     * helper method to proxy various cursor read statements that support a callback or a promise
     */
    MongoDBProxy.prototype.cursorCloseProxy = function (methodName, originalThis, originalArgs) {
        var startTime = moment();
        var hrtime = process.hrtime();
        function afterSuccess(result) {
            if (Tracing_1.default.isEventEnabled(MongoDBEvents_1.EVENT_MONGODB_READ_END)) {
                var data = {
                    originalThis: originalThis,
                    methodName: methodName,
                    startTime: startTime,
                    hrtime: hrtime,
                    err: undefined
                };
                Tracing_1.default.publish(MongoDBEvents_1.EVENT_MONGODB_READ_END, data);
            }
        }
        ;
        function afterFailure(err) {
            if (Tracing_1.default.isEventEnabled(MongoDBEvents_1.EVENT_MONGODB_READ_END)) {
                var data = {
                    originalThis: originalThis,
                    methodName: methodName,
                    startTime: startTime,
                    hrtime: hrtime,
                    err: err
                };
                Tracing_1.default.publish(MongoDBEvents_1.EVENT_MONGODB_READ_END, data);
            }
        }
        ;
        return this.callbackOrPromise(originalThis, originalArgs, 0, 1, this.realCursorMethods[methodName], afterSuccess, afterFailure);
    };
    /**
     * helper method to proxy various cursor read statements that support a callback or a promise
     */
    MongoDBProxy.prototype.cursorStartReadProxyCallbackOrPromise = function (methodName, originalThis, originalArgs) {
        var startTime = moment();
        var hrtime = process.hrtime();
        if (Tracing_1.default.isEventEnabled(MongoDBEvents_1.EVENT_MONGODB_READ_START)) {
            var data = {
                originalThis: originalThis,
                methodName: methodName,
                startTime: startTime,
                hrtime: hrtime
            };
            Tracing_1.default.publish(MongoDBEvents_1.EVENT_MONGODB_READ_START, data);
        }
        function afterSuccess(result) {
            if (Tracing_1.default.isEventEnabled(MongoDBEvents_1.EVENT_MONGODB_READ_RECORD)) {
                var data = {
                    originalThis: originalThis,
                    methodName: methodName,
                    startTime: startTime,
                    hrtime: hrtime,
                    result: result,
                    err: undefined
                };
                Tracing_1.default.publish(MongoDBEvents_1.EVENT_MONGODB_READ_RECORD, data);
            }
        }
        ;
        function afterFailure(err) {
            if (Tracing_1.default.isEventEnabled(MongoDBEvents_1.EVENT_MONGODB_READ_RECORD)) {
                var data = {
                    originalThis: originalThis,
                    methodName: methodName,
                    startTime: startTime,
                    hrtime: hrtime,
                    result: undefined,
                    err: err
                };
                Tracing_1.default.publish(MongoDBEvents_1.EVENT_MONGODB_READ_RECORD, data);
            }
        }
        ;
        return this.callbackOrPromise(originalThis, originalArgs, 0, 1, this.realCursorMethods[methodName], afterSuccess, afterFailure);
    };
    /**
     * helper method to proxy cursor read statements that support only callbacks
     */
    MongoDBProxy.prototype.cursorStartReadProxyCallbackNoPromise = function (methodName, originalThis, originalArgs) {
        var startTime = moment();
        var hrtime = process.hrtime();
        if (Tracing_1.default.isEventEnabled(MongoDBEvents_1.EVENT_MONGODB_READ_START)) {
            var data = {
                originalThis: originalThis,
                methodName: methodName
            };
            Tracing_1.default.publish(MongoDBEvents_1.EVENT_MONGODB_READ_START, data);
        }
        // assume args[0] is the callback we need to wrap
        if (typeof (originalArgs[0]) === 'function') {
            var callback_1 = originalArgs[0];
            var callbackWrapper = function callbackWrapper(err, result) {
                if (Tracing_1.default.isEventEnabled(MongoDBEvents_1.EVENT_MONGODB_READ_RECORD)) {
                    var data = {
                        originalThis: originalThis,
                        methodName: methodName,
                        startTime: startTime,
                        hrtime: hrtime,
                        result: result,
                        err: err
                    };
                    Tracing_1.default.publish(MongoDBEvents_1.EVENT_MONGODB_READ_RECORD, data);
                }
                callback_1.apply(this, arguments);
            };
            originalArgs[0] = callbackWrapper;
        }
        return this.realCursorMethods[methodName].apply(originalThis, originalArgs);
    };
    /**
     * Proxy for collection read count
     */
    MongoDBProxy.prototype.collectionReadProxy = function (methodName, originalThis, originalArgs) {
        var startTime = moment();
        var hrtime = process.hrtime();
        function afterSuccess(result) {
            if (Tracing_1.default.isEventEnabled(MongoDBEvents_1.EVENT_MONGODB_COLLECTION_COUNT)) {
                var data = {
                    originalThis: originalThis,
                    originalArgs: originalArgs,
                    methodName: methodName,
                    startTime: startTime,
                    hrtime: hrtime,
                    err: undefined
                };
                Tracing_1.default.publish(MongoDBEvents_1.EVENT_MONGODB_COLLECTION_COUNT, data);
            }
        }
        ;
        function afterFailure(err) {
            if (Tracing_1.default.isEventEnabled(MongoDBEvents_1.EVENT_MONGODB_COLLECTION_COUNT)) {
                var data = {
                    originalThis: originalThis,
                    originalArgs: originalArgs,
                    methodName: methodName,
                    startTime: startTime,
                    hrtime: hrtime,
                    err: err
                };
                Tracing_1.default.publish(MongoDBEvents_1.EVENT_MONGODB_COLLECTION_COUNT, data);
            }
        }
        ;
        return this.callbackOrPromise(originalThis, originalArgs, 0, 3, this.realCollectionMethods[methodName], afterSuccess, afterFailure);
    };
    ;
    /**
     *  helper method to proxy various insert methods
     */
    MongoDBProxy.prototype.insertMethodsProxy = function (methodName, originalThis, originalArgs) {
        var startTime = moment();
        var hrtime = process.hrtime();
        function afterSuccess(result) {
            if (Tracing_1.default.isEventEnabled(MongoDBEvents_1.EVENT_MONGODB_COLLECTION_INSERT_METHODS)) {
                var data = {
                    originalThis: originalThis,
                    originalArgs: originalArgs,
                    methodName: methodName,
                    startTime: startTime,
                    hrtime: hrtime,
                    result: result,
                    err: undefined
                };
                Tracing_1.default.publish(MongoDBEvents_1.EVENT_MONGODB_COLLECTION_INSERT_METHODS, data);
            }
        }
        ;
        function afterFailure(err) {
            if (Tracing_1.default.isEventEnabled(MongoDBEvents_1.EVENT_MONGODB_COLLECTION_INSERT_METHODS)) {
                var data = {
                    originalThis: originalThis,
                    originalArgs: originalArgs,
                    methodName: methodName,
                    startTime: startTime,
                    hrtime: hrtime,
                    result: undefined,
                    err: err
                };
                Tracing_1.default.publish(MongoDBEvents_1.EVENT_MONGODB_COLLECTION_INSERT_METHODS, data);
            }
        }
        ;
        return this.callbackOrPromise(originalThis, originalArgs, 1, 2, this.realCollectionMethods[methodName], afterSuccess, afterFailure);
    };
    ;
    /**
     * Proxy for update methods including 'updateOne', 'updateMany', 'replaceOne', 'findOneAndUpdate'
     */
    MongoDBProxy.prototype.updateProxy = function (methodName, originalThis, originalArgs) {
        var startTime = moment();
        var hrtime = process.hrtime();
        function afterSuccess(result) {
            if (Tracing_1.default.isEventEnabled(MongoDBEvents_1.EVENT_MONGODB_COLLECTION_UPDATE_METHODS)) {
                var data = {
                    originalThis: originalThis,
                    originalArgs: originalArgs,
                    methodName: methodName,
                    startTime: startTime,
                    hrtime: hrtime,
                    result: result,
                    err: undefined
                };
                Tracing_1.default.publish(MongoDBEvents_1.EVENT_MONGODB_COLLECTION_UPDATE_METHODS, data);
            }
        }
        ;
        function afterFailure(err) {
            if (Tracing_1.default.isEventEnabled(MongoDBEvents_1.EVENT_MONGODB_COLLECTION_UPDATE_METHODS)) {
                var data = {
                    originalThis: originalThis,
                    originalArgs: originalArgs,
                    methodName: methodName,
                    startTime: startTime,
                    hrtime: hrtime,
                    result: undefined,
                    err: err
                };
                Tracing_1.default.publish(MongoDBEvents_1.EVENT_MONGODB_COLLECTION_UPDATE_METHODS, data);
            }
        }
        ;
        return this.callbackOrPromise(originalThis, originalArgs, 2, 2, this.realCollectionMethods[methodName], afterSuccess, afterFailure);
    };
    ;
    /**
     *  helper method to proxy deleteOne, deleteMany or findOneAndDelete
     */
    MongoDBProxy.prototype.deleteProxy = function (methodName, originalThis, originalArgs) {
        var startTime = moment();
        var hrtime = process.hrtime();
        function afterDeleteSuccess(result) {
            if (Tracing_1.default.isEventEnabled(MongoDBEvents_1.EVENT_MONGODB_COLLECTION_DELETE_METHODS)) {
                var data = {
                    originalThis: originalThis,
                    originalArgs: originalArgs,
                    methodName: methodName,
                    startTime: startTime,
                    hrtime: hrtime,
                    result: result,
                    err: undefined
                };
                Tracing_1.default.publish(MongoDBEvents_1.EVENT_MONGODB_COLLECTION_DELETE_METHODS, data);
            }
        }
        ;
        function afterDeleteFailure(err) {
            if (Tracing_1.default.isEventEnabled(MongoDBEvents_1.EVENT_MONGODB_COLLECTION_DELETE_METHODS)) {
                var data = {
                    originalThis: originalThis,
                    originalArgs: originalArgs,
                    methodName: methodName,
                    startTime: startTime,
                    hrtime: hrtime,
                    result: undefined,
                    err: err
                };
                Tracing_1.default.publish(MongoDBEvents_1.EVENT_MONGODB_COLLECTION_DELETE_METHODS, data);
            }
        }
        ;
        return this.callbackOrPromise(originalThis, originalArgs, 1, 2, this.realCollectionMethods[methodName], afterDeleteSuccess, afterDeleteFailure);
    };
    ;
    /**
     * helper method that will execute a callback if present, or return a promise.
     *
     * @callbackStartIndex - the string  index into originalArgs of where a callback may be.
     * @callbackProbeLength - the number of slots in originalArgs to probe for a paramater of type function.  This will be the callback.
     * @realMethod - is the actual method that we're proxying.
     * @onSuccess - the callback to raise when @realMethod is successful.
     * @onFailure - the callback to raise when @realMethod fails.
     */
    MongoDBProxy.prototype.callbackOrPromise = function (originalThis, originalArgs, callbackStartIndex, callbackProbeLength, realMethod, onSuccess, onFailure) {
        var originalCallback = undefined;
        var callbackIndex = -1;
        for (var i = callbackStartIndex; i < callbackStartIndex + callbackProbeLength; i++) {
            if (typeof originalArgs[i] === 'function') {
                callbackIndex = i;
                originalCallback = originalArgs[i];
                break;
            }
        }
        if (originalCallback) {
            var callbackWrapper = function callbackWrapper(err, result) {
                if (err) {
                    onFailure(err);
                }
                else {
                    onSuccess(result);
                }
                originalCallback.apply(this, arguments);
            };
            // replace callback in arguments array
            originalArgs[callbackIndex] = callbackWrapper;
            return realMethod.apply(originalThis, originalArgs);
        }
        else {
            // no callback specified, so we return a promise.
            // this.s.promiseLibrary is a promise constructor.  this.s is Collection's internal state
            var promiseFunction = function promiseFunction(resolve, reject) {
                function proxySuccess(r) {
                    onSuccess.apply(this, arguments);
                    resolve(r);
                }
                ;
                function proxyFailed(err) {
                    onFailure.apply(this, arguments);
                    reject(err);
                }
                ;
                realMethod.apply(originalThis, originalArgs)
                    .then(proxySuccess, proxyFailed);
            };
            return new originalThis.s.promiseLibrary(promiseFunction);
        }
    };
    ;
    /**
     * Normalizes position of optional options and callback arguments on the given array.
     */
    MongoDBProxy.swizzleArgs = function (argsArray) {
        if (!Array.isArray(argsArray)) {
            argsArray = Array.prototype.slice.call(argsArray, 0);
        }
        if (typeof argsArray[1] === 'function') {
            argsArray.push(argsArray[1]);
            argsArray[1] = {};
        }
        else if (!argsArray[1]) {
            argsArray[1] = {};
        }
        return argsArray;
    };
    return MongoDBProxy;
}());
exports.MongoDBProxy = MongoDBProxy;

//# sourceMappingURL=../../../maps/tracing/module_instrumentors/MongoDBProxy.js.map
