'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var ExpressEvents_1 = require("./ExpressEvents");
var Tracing_1 = require("./../Tracing");
var ExpressProxyActionRouteView = (function () {
    function ExpressProxyActionRouteView() {
    }
    ExpressProxyActionRouteView.init = function (express) {
        var expressDispatch = express.Route.prototype.dispatch;
        express.Route.prototype.dispatch = function dispatchRoute(req, res) {
            var rest = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                rest[_i - 2] = arguments[_i];
            }
            if (Tracing_1.default.isEventEnabled(ExpressEvents_1.EVENT_EXPRESS_INVOKE_PRE_ROUTE_DISPATCH)) {
                var data = {
                    originalThis: this,
                    originalArgs: arguments,
                    response: res
                };
                Tracing_1.default.publish(ExpressEvents_1.EVENT_EXPRESS_INVOKE_PRE_ROUTE_DISPATCH, data);
            }
            return expressDispatch.call.apply(expressDispatch, [this, req, res].concat(rest));
        };
        var expressResponseRender = express.response.render;
        express.response.render = function renderResponse() {
            var rest = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                rest[_i] = arguments[_i];
            }
            // Need to pass original arguments
            var updatedArguments = ExpressProxyActionRouteView.fixupResponseRenderArgs(this, rest);
            var response = this;
            // hijack the view render here - A "view engine" is pluggable on the app, so we want to support
            // potential of multiple apps in a process with different "view" settings.
            if (!this.req.app.settings.view.prototype.originalRender) {
                this.req.app.settings.view.prototype.originalRender = this.req.app.settings.view.prototype.render;
                this.req.app.settings.view.prototype.render = function viewRender() {
                    if (Tracing_1.default.isEventEnabled(ExpressEvents_1.EVENT_EXPRESS_INVOKE_PRE_VIEW_RENDER)) {
                        // NOTE:  be careful of any closure variables used here, as they'll always reflect the first
                        // time through the parent function, since we only set up this proxy once.
                        var data = {
                            originalThis: this,
                            originalArgs: arguments
                        };
                        Tracing_1.default.publish(ExpressEvents_1.EVENT_EXPRESS_INVOKE_PRE_VIEW_RENDER, data);
                    }
                    var expressViewRender = this.originalRender;
                    return expressViewRender.apply(this, arguments);
                };
            }
            if (Tracing_1.default.isEventEnabled(ExpressEvents_1.EVENT_EXPRESS_INVOKE_PRE_RESPONSE_RENDER)) {
                var data = {
                    originalThis: this,
                    originalArgs: updatedArguments,
                    response: response
                };
                Tracing_1.default.publish(ExpressEvents_1.EVENT_EXPRESS_INVOKE_PRE_RESPONSE_RENDER, data);
            }
            return expressResponseRender.apply(this, updatedArguments);
        };
        var expressSend = express.response.send;
        express.response.send = function sendResponse() {
            if (Tracing_1.default.isEventEnabled(ExpressEvents_1.EVENT_EXPRESS_INVOKE_PRE_RESPONSE_SEND)) {
                var data = {
                    originalThis: this,
                    originalArgs: arguments,
                    response: this
                };
                Tracing_1.default.publish(ExpressEvents_1.EVENT_EXPRESS_INVOKE_PRE_RESPONSE_SEND, data);
            }
            return expressSend.apply(this, arguments);
        };
        var expressEnd = express.response.end;
        express.response.end = function endResponse() {
            if (Tracing_1.default.isEventEnabled(ExpressEvents_1.EVENT_EXPRESS_INVOKE_PRE_RESPONSE_END)) {
                var data = {
                    originalThis: this,
                    originalArgs: arguments,
                    response: this
                };
                Tracing_1.default.publish(ExpressEvents_1.EVENT_EXPRESS_INVOKE_PRE_RESPONSE_END, data);
            }
            return expressEnd.apply(this, arguments);
        };
    };
    ExpressProxyActionRouteView.fixupResponseRenderArgs = function (response, originalArguments) {
        var done;
        function onRenderComplete(err, str) {
            if (Tracing_1.default.isEventEnabled(ExpressEvents_1.EVENT_EXPRESS_NOTIFY_RENDER_COMPLETE)) {
                var data = {
                    originalThis: this,
                    originalArgs: arguments,
                    err: err,
                    response: response
                };
                Tracing_1.default.publish(ExpressEvents_1.EVENT_EXPRESS_NOTIFY_RENDER_COMPLETE, data);
            }
            done(err, str);
        }
        ;
        var updatedArguments = Array.prototype.slice.call(originalArguments);
        if (updatedArguments.length > 0 && (typeof updatedArguments[updatedArguments.length - 1] === 'function')) {
            done = updatedArguments[updatedArguments.length - 1];
            updatedArguments[updatedArguments.length - 1] = onRenderComplete;
        }
        else {
            updatedArguments.push(onRenderComplete);
        }
        // default callback - this is the default "done" handler set up by express response object.  It ensures we have correct error handling.
        done = done || function (err, str) {
            if (err) {
                return response.req.next(err);
            }
            response.send(str);
        };
        return updatedArguments;
    };
    return ExpressProxyActionRouteView;
}());
exports.ExpressProxyActionRouteView = ExpressProxyActionRouteView;

//# sourceMappingURL=../../../maps/tracing/module_instrumentors/ExpressProxyActionRouteView.js.map
