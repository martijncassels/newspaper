'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var ModuleIdentifier_1 = require("./ModuleIdentifier");
var semver_1 = require("semver");
var glimpse_common_1 = require("@glimpse/glimpse-common");
var ModuleManager = (function () {
    function ModuleManager() {
        this.nonExperimentalModules = new Map();
        this.moduleInstrumentors = {};
        this.unsupportedVersions = {};
    }
    ModuleManager.prototype.init = function (agent, moduleModule) {
        this.nonExperimentalModules.set('console', true);
        this.nonExperimentalModules.set('http', true);
        this.nonExperimentalModules.set('https', true);
        this.nonExperimentalModules.set('express', true);
        this.nonExperimentalModules.set('mongodb-core', true);
        this.nonExperimentalModules.set('mongodb', true);
        this.agent = agent;
        this.moduleModule = moduleModule;
        this.originalRequire = moduleModule.prototype.require;
        var self = this;
        var configSettings = self.agent.providers.configSettings;
        var glimpseRequire = function glimpseRequire(moduleId) {
            var originalModule = self.originalRequire.call(this, moduleId);
            // _resolveFilename isn't cleanly exposed, but we can access via `this.constructor`.
            // require.resolve(id) doesn't work correctly here since it will run in the context of the Glimpse.Agent
            // module, and not in the context of the module we're trying to load.
            var modulePath = this.constructor._resolveFilename(moduleId, this);
            // Note: check if config settings are available and check the config
            // settings if it is. Default to true if config settings aren't
            // available or if the user did not explicitly specify whether or
            // not to enable this module
            var isExperimentalModeModule = self.isExperimentalModeModule(moduleId);
            var isEnabled = true;
            if (isExperimentalModeModule) {
                isEnabled = configSettings ? configSettings.getBoolean('enable.experimental.features', false) : false;
            }
            if (isEnabled) {
                isEnabled = configSettings ? configSettings.getBoolean("instrumentor." + moduleId + ".enabled", true) : true;
            }
            if (self.moduleInstrumentors[moduleId] && isEnabled) {
                var moduleInfo = ModuleIdentifier_1.getModuleInfo(moduleId, modulePath, originalModule);
                for (var _i = 0, _a = self.moduleInstrumentors[moduleId]; _i < _a.length; _i++) {
                    var instrumentorEntry = _a[_i];
                    var supportedVersion = instrumentorEntry.instrumentor.supportedModules[moduleId];
                    if (semver_1.satisfies(moduleInfo.version, supportedVersion)) {
                        if (!instrumentorEntry.enabledModules[modulePath]) {
                            var result = instrumentorEntry.instrumentor.enableInstrumentation(moduleInfo);
                            instrumentorEntry.enabledModules[modulePath] = result.isEnabled;
                        }
                    }
                    else {
                        // If we got here, it means we do support instrumenting
                        // the given module, but not the specific version of the
                        // module, so we want to report this. However, it's
                        // pretty common for the same module to be required
                        // multiple times and we don't want to flood the
                        // reporting service, so we keep track of what we've
                        // reported so far, and only report on the first time
                        if (!self.unsupportedVersions[moduleId]) {
                            self.unsupportedVersions[moduleId] = [];
                        }
                        if (self.unsupportedVersions[moduleId].indexOf(moduleInfo.version) === -1) {
                            self.unsupportedVersions[moduleId].push(moduleInfo.version);
                            if (self.errorReportingService) {
                                self.errorReportingService.reportError(glimpse_common_1.createUnsupportedPackageRequiredError(moduleId, moduleInfo.version, supportedVersion));
                            }
                        }
                    }
                }
            }
            return originalModule;
        };
        moduleModule.prototype.require = glimpseRequire;
    };
    /**
     * returns true if this is an experimental module, false otherwise
     */
    ModuleManager.prototype.isExperimentalModeModule = function (moduleId) {
        return !(this.nonExperimentalModules.has(moduleId));
    };
    ModuleManager.prototype.destroy = function () {
        this.moduleModule.prototype.require = this.originalRequire;
    };
    ModuleManager.prototype.addModuleInstrumentor = function (instrumentor) {
        // Temporary hack to support old proxies without having to modify the
        // public signatures for instrumentors/the module manager
        // tslint:disable:no-string-literal
        if (instrumentor['setAgent']) {
            instrumentor['setAgent'](this.agent);
        }
        // tslint:enable:no-string-literal
        for (var _i = 0, _a = Object.keys(instrumentor.supportedModules); _i < _a.length; _i++) {
            var moduleId = _a[_i];
            if (!this.moduleInstrumentors[moduleId]) {
                this.moduleInstrumentors[moduleId] = [];
            }
            this.moduleInstrumentors[moduleId].push({
                instrumentor: instrumentor,
                enabledModules: {}
            });
        }
    };
    ModuleManager.prototype.setErrorReportingService = function (service) {
        this.errorReportingService = service;
    };
    return ModuleManager;
}());
exports.ModuleManager = ModuleManager;

//# sourceMappingURL=../../maps/tracing/ModuleManager.js.map
