'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ProxyBase_1 = require("./ProxyBase");
var GuidHelper_1 = require("../util/GuidHelper");
var NodeVersionHelper_1 = require("../util/NodeVersionHelper");
var util = require("util");
;
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Debug"] = 0] = "Debug";
    LogLevel[LogLevel["Log"] = 1] = "Log";
    LogLevel[LogLevel["Info"] = 2] = "Info";
    LogLevel[LogLevel["Warning"] = 3] = "Warning";
    LogLevel[LogLevel["Error"] = 4] = "Error";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
;
/**
 * The Proxy class for Console logging
 */
var ConsoleProxy = (function (_super) {
    __extends(ConsoleProxy, _super);
    function ConsoleProxy() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._realConsoleMethods = {};
        _this._realConsolePrototypeMethods = {};
        _this._suppressLogWriteMessage = false;
        _this._suppressGlimpseMessage = false;
        _this._timerLabels = new Map();
        return _this;
    }
    /**
     * Init the proxy.
     */
    ConsoleProxy.prototype.init = function (agent, consoleModule) {
        this.agent = agent;
        this.contextManager = agent.providers.contextManager;
        this.stackHelper = agent.providers.stackHelper;
        this.configSettings = agent.providers.configSettings;
        this.messageConverter = agent.providers.messageConverter;
        this.addProxy('assert', 'assert', this.assert, consoleModule);
        this.addProxy('debug', 'debug', this.debug, consoleModule); // debug() is not supported on Node, but leave here for client platforms where it may be supported.fs
        this.addProxy('error', 'warn', this.error, consoleModule); // route "error" calls through to warn
        this.addProxy('trace', 'trace', this.trace, consoleModule); // let "trace" calls go through our override, and then through "warn"
        this.addProxy('info', 'log', this.info, consoleModule); // route "info" calls through to log
        this.addProxy('log', 'log', this.log, consoleModule);
        this.addProxy('warn', 'warn', this.warn, consoleModule);
        this.addProxy('dir', 'dir', this.dir, consoleModule);
        this.addProxy('time', 'time', this.time, consoleModule);
        this.addProxy('timeEnd', 'timeEnd', this.timeEnd, consoleModule);
        return consoleModule;
    };
    ;
    Object.defineProperty(ConsoleProxy.prototype, "forceLoadModule", {
        get: function () {
            // we need to load the Console module asap, as users can call the console.* methods without calling require('console').  
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConsoleProxy.prototype, "moduleName", {
        get: function () { return 'console'; },
        enumerable: true,
        configurable: true
    });
    ;
    /**
     * helper method that will send the appropriate glimpse message and invoke the underlying console method
     */
    ConsoleProxy.prototype.proxyHelper = function (originalThis, originalArgs, realMethod, logLevel, stackTopFunction) {
        if (this.contextManager.isWithinContext() && !this._suppressGlimpseMessage) {
            var numStackFrames = this.configSettings.get('instrumentor.console.stack-capture.size', 10);
            var stack = this.stackHelper.captureStack(stackTopFunction, numStackFrames);
            var msg = this.createLogWriteMessage(Array.prototype.slice.call(originalArgs, 0), logLevel, undefined, true);
            this.sendMessage(msg, stack);
        }
        return realMethod.apply(originalThis, originalArgs);
    };
    /**
     * logic to send messages for Console.assert()
     */
    ConsoleProxy.prototype.assert = function (originalThis, originalArgs, realMethod, stackTopFunction) {
        if ((!originalArgs || !originalArgs[0]) && this.contextManager.isWithinContext()) {
            var numStackFrames = this.configSettings.get('instrumentor.console.stack-capture.size', 10);
            var stack = this.stackHelper.captureStack(stackTopFunction, numStackFrames);
            var msg = this.createLogWriteMessage(Array.prototype.slice.call(originalArgs, 1), LogLevel.Error, undefined, true);
            this.sendMessage(msg, stack);
        }
        return realMethod.apply(originalThis, originalArgs);
    };
    /**
     * Logic to send glimpse messages for Console.dir()
     */
    ConsoleProxy.prototype.dir = function (originalThis, originalArgs, realMethod, stackTopFunction) {
        if (this.contextManager.isWithinContext()) {
            var numStackFrames = this.configSettings.get('instrumentor.console.stack-capture.size', 10);
            var stack = this.stackHelper.captureStack(stackTopFunction, numStackFrames);
            //
            // TODO:  https://github.com/Glimpse/Glimpse.Node/issues/599 - Need custom formatting logic for util.inspect to keep the 
            // string json-parseable.
            //
            // let options = originalArgs[1] || {};
            // options = (<any>Object).assign({ customInspect: false }, options);
            // const stringData = util.inspect(originalArgs[0], options);
            // const objData = JSON.parse(stringData);
            var objData = originalArgs[0];
            var msg = this.createLogJSONMessage([objData], LogLevel.Log, undefined);
            this.sendMessage(msg, stack);
        }
        return realMethod.apply(originalThis, originalArgs);
    };
    /**
     * logic to support glimpse messages for timeEnd
     */
    ConsoleProxy.prototype.time = function (originalThis, originalArgs, realMethod, stackTopFunction) {
        var hrtime = process.hrtime();
        var returnValue = realMethod.apply(originalThis, originalArgs);
        var label = originalArgs[0];
        var correlationId = GuidHelper_1.GuidHelper.newGuid();
        var timerInfo = { correlationId: correlationId, hrtime: hrtime };
        this._timerLabels.set(label, timerInfo);
        if (this.contextManager.isWithinContext()) {
            var numStackFrames = this.configSettings.get('instrumentor.console.stack-capture.size', 10);
            var stack = this.stackHelper.captureStack(stackTopFunction, numStackFrames);
            var msg = this.createTimerBeginMessage(label, timerInfo.correlationId);
            this.sendMessage(msg, stack);
        }
        return returnValue;
    };
    /**
     * logic to support glimpse messages for timeEnd
     */
    ConsoleProxy.prototype.timeEnd = function (originalThis, originalArgs, realMethod, stackTopFunction) {
        this._suppressLogWriteMessage = true;
        var returnValue = undefined;
        try {
            returnValue = realMethod.apply(originalThis, originalArgs);
        }
        finally {
            this._suppressLogWriteMessage = false;
        }
        var label = originalArgs[0];
        var timerInfo;
        timerInfo = this._timerLabels.get(label);
        var correlationId;
        var millis;
        if (timerInfo) {
            var hrtime = process.hrtime(timerInfo.hrtime);
            // prior to v6.0, node runtime wouldn't delete the timer label when timeEnd was called.
            // replicate that behavior here. 
            //  See https://github.com/nodejs/node/pull/5901
            //      https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V6.md#notable-changes-14
            if (NodeVersionHelper_1.NodeVersionHelper.getMajor() >= 6) {
                this._timerLabels.delete(label);
            }
            correlationId = timerInfo.correlationId;
            millis = hrtime[0] * 1000 + hrtime[1] / 1e6;
        }
        else {
            correlationId = GuidHelper_1.GuidHelper.newGuid();
            millis = 0;
        }
        if (this.contextManager.isWithinContext()) {
            var numStackFrames = this.configSettings.get('instrumentor.console.stack-capture.size', 10);
            var stack = this.stackHelper.captureStack(stackTopFunction, numStackFrames);
            var msg = this.createTimerEndMessage(label, correlationId, millis);
            this.sendMessage(msg, stack);
        }
        return returnValue;
    };
    /**
     * This is a no-op for now as Node doesn't support debug, but browsers do, so we'll leave this here for when this
     * proxy is hooked up on browser clients.
     */
    ConsoleProxy.prototype.debug = function (originalThis, originalArgs, realMethod, stackTopFunction) {
        return this.proxyHelper(originalThis, originalArgs, realMethod, LogLevel.Error, stackTopFunction);
    };
    /**
     * Logic to send glimpse messages for Console.error()
     */
    ConsoleProxy.prototype.error = function (originalThis, originalArgs, realMethod, stackTopFunction) {
        return this.proxyHelper(originalThis, originalArgs, realMethod, LogLevel.Error, stackTopFunction);
    };
    /**
     * Logic to send glimpse messages for Console.error()
     */
    ConsoleProxy.prototype.trace = function (originalThis, originalArgs, realMethod, stackTopFunction) {
        if (this.contextManager.isWithinContext()) {
            var numStackFrames = this.configSettings.get('instrumentor.console.stack-capture.size', 10);
            var stack = this.stackHelper.captureStack(stackTopFunction, numStackFrames);
            var args = Array.prototype.slice.call(originalArgs, 0);
            // add 'Trace:' prefix to the message to conform w/ what is output from Node
            if (args[0] === undefined) {
                args[0] = 'Trace:';
            }
            else {
                args[0] = 'Trace: ' + args[0];
            }
            var msg = this.createLogWriteMessage(args, LogLevel.Debug, undefined, true);
            msg.types.push('log-display-callstack');
            this.sendMessage(msg, stack);
        }
        // underlying trace implementation will call console.error - we want to suppress message generation when that happens so 
        // we don't have two glimpse messages for the same event.
        try {
            this._suppressGlimpseMessage = true;
            return realMethod.apply(originalThis, originalArgs);
        }
        finally {
            this._suppressGlimpseMessage = false;
        }
    };
    /**
     * Logic to send glimpse messages for Console.info()
     */
    ConsoleProxy.prototype.info = function (originalThis, originalArgs, realMethod, stackTopFunction) {
        return this.proxyHelper(originalThis, originalArgs, realMethod, LogLevel.Info, stackTopFunction);
    };
    /**
     * Logic to send glimpse messages for Console.log()
     */
    ConsoleProxy.prototype.log = function (originalThis, originalArgs, realMethod, stackTopFunction) {
        if (this._suppressLogWriteMessage) {
            realMethod.apply(originalThis, originalArgs);
        }
        else {
            return this.proxyHelper(originalThis, originalArgs, realMethod, LogLevel.Log, stackTopFunction);
        }
    };
    /**
     * Logic to send glimpse messages for Console.warn()
     */
    ConsoleProxy.prototype.warn = function (originalThis, originalArgs, realMethod, stackTopFunction) {
        return this.proxyHelper(originalThis, originalArgs, realMethod, LogLevel.Warning, stackTopFunction);
    };
    ConsoleProxy.prototype.createTimerBeginMessage = function (label, correlationId) {
        var message = this.createLogWriteMessage(undefined, LogLevel.Debug, undefined, false, 'log-timespan-begin', 'correlation-begin', 'correlation');
        var payload = message.payload;
        // for timer begin, the message is a string and it is the label.
        payload.message = label;
        payload.correlationId = correlationId;
        return message;
    };
    ConsoleProxy.prototype.createTimerEndMessage = function (label, correlationId, durationInMilliseconds) {
        var message = this.createLogWriteMessage(undefined, LogLevel.Debug, undefined, false, 'log-timespan-end', 'correlation-end', 'correlation');
        var payload = message.payload;
        payload.message = label;
        payload.correlationId = correlationId;
        payload.duration = durationInMilliseconds;
        return message;
    };
    /**
     * create a 'log-json' glimpse message
     */
    ConsoleProxy.prototype.createLogJSONMessage = function (logArguments, level, category) {
        return this.createLogWriteMessage(logArguments, level, category, false, 'log-json');
    };
    /**
     * create a 'log-write' glimpse message
     */
    ConsoleProxy.prototype.createLogWriteMessage = function (logArguments, level, category, isPrintf) {
        var extraTypes = [];
        for (var _i = 4; _i < arguments.length; _i++) {
            extraTypes[_i - 4] = arguments[_i];
        }
        var self = this;
        var message;
        var context = this.contextManager.currentContext();
        if (context) {
            var messageTypes = [];
            var payload = {
                message: logArguments,
                level: LogLevel[level],
                library: 'Node.js Console',
                category: category
            };
            if (extraTypes) {
                messageTypes.push.apply(messageTypes, extraTypes);
            }
            if (isPrintf) {
                messageTypes.push('log-token-printf');
                payload.tokenSupport = 'node';
            }
            messageTypes.push('log-write');
            message = self.messageConverter.createMessageEnvelope(messageTypes, undefined, context);
            message.payload = payload;
        }
        return message;
    };
    ConsoleProxy.prototype.sendMessage = function (messageEnvelope, stackFrames) {
        var _this = this;
        var self = this;
        this.stackHelper.mapFrames(stackFrames, function (mappedFrames) {
            // tslint:disable-next-line:no-any 
            messageEnvelope.payload.frames = mappedFrames;
            messageEnvelope.types.push('call-stack');
            var transformedMessage = self.messageConverter.transformMessageForTransit(messageEnvelope, messageEnvelope.payload);
            _this.agent.broker.sendMessage(transformedMessage);
        });
    };
    /**
     *  helper method to hookup up a proxy method on the Console object.  This helper
     *  accounts for the fact that there could potentially be two different sets of
     *  log methods, the 'console.*' methods, and then the Console.prototype.* methods.
     */
    ConsoleProxy.prototype.addProxy = function (methodToProxy, methodToCall, proxyFunction, consoleModule) {
        var self = this;
        if (this._realConsoleMethods[methodToProxy] || this._realConsolePrototypeMethods[methodToProxy]) {
            throw new Error(util.format('Attempted to add proxy twice for method %s', methodToProxy));
        }
        if (consoleModule[methodToProxy]) {
            this._realConsoleMethods[methodToProxy] = consoleModule[methodToProxy];
            var p1 = function p1() {
                return proxyFunction.call(self, this, arguments, self._realConsoleMethods[methodToCall], p1);
            };
            consoleModule[methodToProxy] = p1;
        }
        if (consoleModule.Console.prototype[methodToProxy]) {
            this._realConsolePrototypeMethods[methodToProxy] = consoleModule.Console.prototype[methodToProxy];
            var p2 = function p2() {
                return proxyFunction.call(self, this, arguments, self._realConsolePrototypeMethods[methodToCall], p2);
            };
            consoleModule.Console.prototype[methodToProxy] = p2;
        }
    };
    return ConsoleProxy;
}(ProxyBase_1.ProxyBase));
exports.ConsoleProxy = ConsoleProxy;

//# sourceMappingURL=../../maps/inspectors/ConsoleProxy.js.map
