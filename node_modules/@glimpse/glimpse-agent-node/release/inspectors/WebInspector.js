'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var DateTimeValue_1 = require("../configuration/DateTimeValue");
var HttpHelper_1 = require("../util/HttpHelper");
var ResponseListener_1 = require("./util/ResponseListener");
var InspectorResponseContext = (function () {
    function InspectorResponseContext(startTime, responseListener, webRequestMessage) {
        this.startTime = startTime;
        this.responseListener = responseListener;
        this.webRequestMessage = webRequestMessage;
    }
    return InspectorResponseContext;
}());
var WebInspector = (function () {
    function WebInspector() {
    }
    WebInspector.prototype.getCurrentTimeStamp = function () {
        return DateTimeValue_1.DateTimeValue.fromUnixMillisecondTimestamp(Date.now(), process.hrtime());
    };
    WebInspector.prototype.requestStart = function (req, res, requestStartTime) {
        var inspectedResponse = res;
        var context = HttpHelper_1.HttpHelper.getContext(req);
        if (context) {
            // NOTE: We can't rely on req.statusCode during the request end event, 
            //       as it may not be consistent with the headers actually sent.
            //       Instead, we track status code changes up to the point where
            //       headers are sent.
            var responseListener = ResponseListener_1.ResponseListener.attachListener(res);
            var types = ['web-request'];
            // create the message envelope now so the offset value & the ordinal will reflect the start of request
            var message = this.agent.providers.messageConverter.createMessageEnvelope(types, undefined, context);
            inspectedResponse.__glimpseRequestInspectorContext = new InspectorResponseContext(requestStartTime, responseListener, message);
        }
    };
    WebInspector.prototype.getRequestUrl = function (req) {
        var requestUrl = req.url;
        // Check if this is an express request object, which splits the path into baseUrl and url
        // tslint:disable:no-any
        if (req.hasOwnProperty('baseUrl') && typeof req.baseUrl === 'string') {
            requestUrl = req.baseUrl + req.url;
        }
        // tslint:enable:no-any
        // Create the full URL, if we can
        var host = HttpHelper_1.RequestHelper.host(req);
        var protocol = HttpHelper_1.RequestHelper.protocol(req);
        if (host && protocol) {
            return protocol + "://" + host + requestUrl;
        }
        else {
            return requestUrl;
        }
    };
    /* tslint:disable:no-any */
    WebInspector.prototype.requestEnd = function (req, res, content, size, requestStartTime, multiPartSummaries) {
        /* tslint:enable:no-any */
        var requestEndTime = this.getCurrentTimeStamp();
        // pull context from request instead of context manager, as request/response is more reliable
        var context = HttpHelper_1.HttpHelper.getContext(req);
        if (context) {
            var inspectedResponse = res;
            var message = inspectedResponse.__glimpseRequestInspectorContext.webRequestMessage;
            var data = {
                url: this.getRequestUrl(req),
                method: req.method,
                startTime: requestStartTime.format(),
                protocol: {
                    identifier: HttpHelper_1.RequestHelper.protocol(req),
                    version: req.httpVersion
                },
                headers: req.headers,
                isAjax: HttpHelper_1.RequestHelper.header(req, 'X-Glimpse-IsAjax') === 'true',
                clientIp: req.socket.remoteAddress,
                body: HttpHelper_1.HttpHelper.createMessageBodyProperty(req, content, size, this.agent.providers.configSettings, multiPartSummaries),
                timing: {
                    requestStart: requestStartTime.diff(context.startTime),
                    requestEnd: requestEndTime.diff(context.startTime)
                }
            };
            // update indices
            message.indices = {
                'request-url': data.url,
                'request-method': data.method,
                'request-datetime': data.startTime
            };
            var transmittableMessage = this.agent.providers.messageConverter.transformMessageForTransit(message, data);
            this.agent.broker.sendMessage(transmittableMessage);
        }
    };
    WebInspector.prototype.responseStart = function (req, res, responseStartTime) {
        var inspectedResponse = res;
        var context = HttpHelper_1.HttpHelper.getContext(req);
        if (context) {
            var types = ['web-response'];
            // create the message envelope now so the offset value & the ordinal will reflect the start of response
            var message = this.agent.providers.messageConverter.createMessageEnvelope(types, undefined, context);
            inspectedResponse.__glimpseRequestInspectorContext.webResponseMessage = message;
        }
    };
    // tslint:disable-next-line:no-any
    WebInspector.prototype.responseEnd = function (req, res, content, size, responseStartTime) {
        // pull context from request instead of context manager, as request/response is more reliable
        var context = HttpHelper_1.HttpHelper.getContext(req);
        if (context) {
            var inspectedResponse = res;
            var endTime = this.dateTime.now;
            var data = {
                url: this.getRequestUrl(req),
                headers: ResponseListener_1.ResponseListener.getAllHeaders(res),
                statusCode: inspectedResponse.__glimpseRequestInspectorContext.responseListener.sentStatusCode,
                statusMessage: inspectedResponse.__glimpseRequestInspectorContext.responseListener.sentStatusMessage,
                duration: endTime.diff(inspectedResponse.__glimpseRequestInspectorContext.startTime),
                endTime: endTime.format(),
                body: HttpHelper_1.HttpHelper.createMessageBodyProperty(res, content, size, this.agent.providers.configSettings),
                timing: {
                    responseStart: responseStartTime.diff(context.startTime),
                    responseEnd: endTime.diff(context.startTime)
                }
            };
            var indices = {
                'request-duration': data.duration,
                'request-status-code': data.statusCode
            };
            var contentType = data.headers['content-type'];
            if (contentType && contentType.length > 0) {
                indices['request-content-type'] = contentType[0];
            }
            var message = inspectedResponse.__glimpseRequestInspectorContext.webResponseMessage;
            if (!message) {
                message = this.agent.providers.messageConverter.createMessageEnvelope(['web-response'], undefined, context);
            }
            message.indices = indices;
            var transmittableMessage = this.agent.providers.messageConverter.transformMessageForTransit(message, data);
            this.agent.broker.sendMessage(transmittableMessage);
        }
    };
    WebInspector.prototype.init = function (agent) {
        this.agent = agent;
        this.dateTime = agent.providers.dateTime;
    };
    return WebInspector;
}());
exports.WebInspector = WebInspector;

//# sourceMappingURL=../../maps/inspectors/WebInspector.js.map
