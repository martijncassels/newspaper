"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var os = require("os");
var fs = require("fs");
var path = require("path");
var url = require("url");
var glimpse_common_1 = require("@glimpse/glimpse-common");
// tslint:disable-next-line:no-var-requires
var sourcemap = require('source-map');
var StackHelper = (function () {
    function StackHelper(errorService) {
        /**
         * cache of generated source files to the SourceMapConsumer instance
         */
        this.mapCache = {};
        /**
         * keep track of any strings we can't parse so we only report an error once per string
         */
        this.reportedErrors = {};
        this.agentRoot = path.resolve(path.join(__dirname, '../..'));
        this.errorReportingService = errorService;
    }
    /**
     * capture the current stack trace.
     *
     * @stackTopFunction is a function that will mark the top of the stack in the returned trace.
     * All functions include stackTopFunction & above will be omitted.
     *
     * @numFrames - the number of stack frames to capture
     *
     */
    StackHelper.prototype.captureStack = function (stackTopFunction, numFrames) {
        var parsedFrames = [];
        if (numFrames > 0) {
            var obj = {
                stack: undefined
            };
            /* tslint:disable:no-any */
            var saveLimit = Error.stackTraceLimit;
            Error.stackTraceLimit = numFrames;
            Error.captureStackTrace(obj, stackTopFunction);
            Error.stackTraceLimit = saveLimit;
            /* tslint:enable:no-any */
            var frames_1 = obj.stack.split('\n');
            // start parsing at 1 since first entry will say 'error'
            for (var i = 1; i < frames_1.length; i++) {
                if (frames_1[i]) {
                    var frame = this.parseFrameEntry(frames_1[i]);
                    parsedFrames.push(frame);
                }
            }
        }
        return parsedFrames;
    };
    /**
     * will return the first frame on the stack above stackTopFunction and not in the node_modules directory and
     * not a native module.  If such a frame can't be found, it will return the top of the stack.
     */
    StackHelper.prototype.tryGetFirstUserCodeFrame = function (frames) {
        var loc;
        if (frames && frames.length > 0) {
            loc = frames[0];
            // find first stack frame that appears to be part of user's app, namely not in node_modules and not 'native'
            var nodeModules = path.sep + 'node_modules' + path.sep;
            for (var i = 0; i < frames.length; i++) {
                if (frames[i].fileName && !this.isBuiltIn(frames[i]) && !this.isGlimpseFrame(frames[i]) && frames[i].fileName !== 'native' && frames[i].fileName.indexOf(nodeModules) === -1) {
                    loc = frames[i];
                    break;
                }
            }
        }
        return loc;
    };
    /**
     * returns true if the given frame is for glimpse code
     */
    StackHelper.prototype.isGlimpseFrame = function (frame) {
        return frame.fileName.indexOf(this.agentRoot) === 0;
    };
    /**
     * returns true if the given frame is for a node built-in function
     */
    StackHelper.prototype.isBuiltIn = function (frame) {
        // if built-in, the fileName will be something like 'http.js'.
        // in this case, path.dirname('http.js') === '.'.  Also check
        // for now directory to be safe.
        var dirname = path.dirname(frame.fileName);
        return (dirname === '.' || dirname.length === 0);
    };
    /**
     * given an array of stack frames, apply source map information to create a new array of stack frames.
     * The callback will be invoked with the new stack frames with mapping info avaialable
     */
    StackHelper.prototype.mapFrames = function (frames, callback) {
        var self = this;
        var newFrames = [];
        var callbacksReceived = 0;
        frames.forEach(function (currFrame, idx) {
            self.mapFrame(currFrame, function (newFrame) {
                ++callbacksReceived;
                newFrames[idx] = newFrame;
                if (callbacksReceived === frames.length) {
                    callback(newFrames);
                }
            });
        });
    };
    /**
     * given content, look up the source map UI.  Public for testing purposes.
     */
    StackHelper.prototype.getMappingUriFromContent = function (sourceFile, data) {
        // see source map proposal:  https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit
        // TODO: support '//@" in addition to '//#' for the " source mapping Url
        // need to have the string concat below, without it will break remap-istanbul when it tries to use source maps on this file
        var sourceMapMark = '\n//# ' + 'sourceMappingURL=';
        var maploc = undefined;
        var idx = data.lastIndexOf(sourceMapMark);
        if (idx > -1) {
            var line = data.substring(idx + sourceMapMark.length);
            line = line.trim();
            return url.parse(line);
        }
        return maploc;
    };
    /**
     * Parse a string form of a single stack frame and return an IStackFrame instance.  Public for testing purposes.
     */
    StackHelper.prototype.parseFrameEntry = function (source) {
        var openParen, closeParen, colon1, colon2;
        for (var i = 0; i < source.length; i++) {
            switch (source[i]) {
                case '(':
                    openParen = i;
                    break;
                case ')':
                    closeParen = i;
                    break;
                case ':':
                    if (!colon1) {
                        colon1 = i;
                    }
                    else if (!colon2) {
                        colon2 = i;
                    }
                    else {
                        // we want the last two colons, so if both colon1 & colon2 have been set, advance them.
                        colon1 = colon2;
                        colon2 = i;
                    }
                    break;
                default:
                    break;
            }
        }
        var functionName, fileName, line, column;
        if (openParen && closeParen && (openParen < closeParen) && colon1 && colon2) {
            // case  '    at processImmediate [as _immediateCallback] (timers.js:533:5)'
            functionName = source.substring(7, openParen).trim();
            fileName = source.substring(openParen + 1, colon1).trim();
            line = source.substring(colon1 + 1, colon2);
            column = source.substring(colon2 + 1, closeParen);
        }
        else if (colon1 && colon2) {
            // case '    at d:\\glimpse\\Glimpse.Node.Prototype\\node_modules\\mocha\\lib\\runner.js:352:7'
            functionName = '<anonymous>';
            fileName = source.substring(7, colon1).trim();
            line = source.substring(colon1 + 1, colon2);
            column = source.substring(colon2 + 1);
        }
        else if (openParen && closeParen) {
            var tryFileName = source.substring(openParen + 1, closeParen);
            if (tryFileName === 'native' || tryFileName === '<anonymous>') {
                // case '    at Array.forEach (native)' or '    at callFn.next (<anonymous>)'
                functionName = source.substring(7, openParen).trim();
                fileName = tryFileName;
                line = '0';
                column = '0';
            }
        }
        // if filename is undefined, we failed to parse the frame
        if (!fileName) {
            if (this.errorReportingService && !this.reportedErrors[source]) {
                this.reportedErrors[source] = true;
                this.errorReportingService.reportError(glimpse_common_1.createStackHelperUnsupportedStackFrameFormat(source));
            }
            functionName = '';
            fileName = '';
            line = '0';
            column = '0';
        }
        return {
            functionName: functionName,
            fileName: fileName,
            lineNumber: parseInt(line, 10),
            columnNumber: parseInt(column, 10),
            source: source
        };
    };
    /**
     * given the existing stack frame, create map a new stack frame where data has been replaced with values from source maps, if available.
     */
    StackHelper.prototype.mapFrame = function (frame, callback) {
        var self = this;
        if (self.mapCache.hasOwnProperty(frame.fileName)) {
            // in the event we didn't load a source map, we'll populate the cache with undefined.
            var mappedFrame = self.createMappedFrame(self.mapCache[frame.fileName], frame);
            callback(mappedFrame);
        }
        else {
            self.getMappingUriFromFile(frame.fileName, function (mappingUri) {
                self.loadSourceMapConsumer(frame.fileName, mappingUri, function (sourceMapConsumer) {
                    // if sourceMapConsumer is undefined, it means there was an error loading it.
                    // We'll populate cache with undefined so we don't continually try to load it.
                    self.mapCache[frame.fileName] = sourceMapConsumer;
                    var mappedFrame = self.createMappedFrame(sourceMapConsumer, frame);
                    callback(mappedFrame);
                });
            });
        }
    };
    /**
     * given a stack frame & a sourceMapConsumer, return a new stack frame with the
     * generated filename/line/column values replaced with the values from the source map.
     *
     * If sourceMapConsumer is null, then original fram will be returned.
     */
    StackHelper.prototype.createMappedFrame = function (sourceMapConsumer, frame) {
        if (sourceMapConsumer) {
            var position = sourceMapConsumer.originalPositionFor({ line: frame.lineNumber, column: frame.columnNumber });
            var validPosition = position && position.source && (position.line || position.line === 0) && (position.column || position.column === 0);
            if (validPosition) {
                frame = {
                    functionName: frame.functionName,
                    fileName: position.source,
                    lineNumber: position.line,
                    columnNumber: position.column,
                    source: frame.source
                };
            }
            if (os.platform() === 'win32') {
                frame.fileName = frame.fileName.replace(/\//g, '\\');
            }
        }
        return frame;
    };
    /**
     * given a path to a source file, find the source mapping URI, and invoke given callback with UI.
     */
    StackHelper.prototype.getMappingUriFromFile = function (sourceFile, callback) {
        var self = this;
        fs.readFile(sourceFile, 'utf8', function (err, data) {
            var mappingUri = undefined;
            if (data && !err) {
                mappingUri = self.getMappingUriFromContent(sourceFile, data);
            }
            callback(mappingUri);
        });
    };
    /**
     * given a URI to a source map, create a SourceMapConsumer, and invoke the given callback with it.
     */
    StackHelper.prototype.loadSourceMapConsumer = function (generatedFile, uri, callback) {
        if (uri && (!uri.protocol || uri.protocol === 'file:')) {
            var maploc = uri.pathname;
            if (!path.isAbsolute(maploc)) {
                maploc = path.join(path.dirname(generatedFile), maploc);
            }
            if (os.platform() === 'win32') {
                maploc = maploc.replace(/\//g, '\\');
            }
            fs.readFile(maploc, 'utf8', function (err, data) {
                var smc = undefined;
                if (data && !err) {
                    var map = JSON.parse(data);
                    smc = new sourcemap.SourceMapConsumer(map);
                }
                callback(smc);
            });
        }
        else {
            if (uri && this.errorReportingService) {
                // we've got a URI, but it isn't a file or relative path, so we don't support it.  Send telemetry so we know about it.
                var uriString = url.format(uri);
                this.errorReportingService.reportError(glimpse_common_1.createStackHelperUnsupportedSourceMapUriError(uriString));
            }
            callback(undefined);
        }
    };
    return StackHelper;
}());
exports.StackHelper = StackHelper;

//# sourceMappingURL=../../../maps/inspectors/util/StackHelper.js.map
