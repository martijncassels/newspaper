'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var glimpse_common_1 = require("@glimpse/glimpse-common");
var ProxyBase_1 = require("./ProxyBase");
var HttpHelper_1 = require("../util/HttpHelper");
var MultiPartFormSummarizer_1 = require("../util/MultiPartFormSummarizer");
var GuidHelper_1 = require("../util/GuidHelper");
var DateTimeValue_1 = require("../configuration/DateTimeValue");
var SESSION_COOKIE = '.Glimpse.Session';
var REQUEST_ID_COOKIE = '.Glimpse.RequestId';
var IS_AJAX_HEADER = 'X-Glimpse-IsAjax';
var HttpProxy = (function (_super) {
    __extends(HttpProxy, _super);
    function HttpProxy() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.inspectors = [];
        _this.proxiedModules = [];
        return _this;
    }
    Object.defineProperty(HttpProxy.prototype, "moduleName", {
        get: function () { return 'http'; },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(HttpProxy.prototype, "forceLoadModule", {
        get: function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    HttpProxy.prototype.raiseRequestStartEvent = function (req, res, requestStartTime) {
        for (var _i = 0, _a = this.inspectors; _i < _a.length; _i++) {
            var inspector = _a[_i];
            inspector.requestStart(req, res, requestStartTime);
        }
    };
    // tslint:disable-next-line:no-any
    HttpProxy.prototype.raiseRequestEndEvent = function (req, res, content, size, requestStartTime, multiPartSummaries) {
        for (var _i = 0, _a = this.inspectors; _i < _a.length; _i++) {
            var inspector = _a[_i];
            inspector.requestEnd(req, res, content, size, requestStartTime, multiPartSummaries);
        }
    };
    // tslint:disable-next-line:no-any
    HttpProxy.prototype.raiseResponseStartEvent = function (req, res, responseStartTime) {
        for (var _i = 0, _a = this.inspectors; _i < _a.length; _i++) {
            var inspector = _a[_i];
            inspector.responseStart(req, res, responseStartTime);
        }
    };
    // tslint:disable-next-line:no-any
    HttpProxy.prototype.raiseResponseEndEvent = function (req, res, content, size, responseStartTime) {
        for (var _i = 0, _a = this.inspectors; _i < _a.length; _i++) {
            var inspector = _a[_i];
            inspector.responseEnd(req, res, content, size, responseStartTime);
        }
    };
    HttpProxy.prototype.getCurrentTimeStamp = function () {
        return DateTimeValue_1.DateTimeValue.fromUnixMillisecondTimestamp(Date.now(), process.hrtime());
    };
    HttpProxy.prototype.patchCreateServer = function (agent, httpModule) {
        var oldCreateServer = httpModule.createServer;
        var self = this;
        httpModule.createServer = function glimpseHttpCreateServer() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var server;
            // NOTE: https.createServer() and http.createServer() have different signatures:
            //         - http.createServer([callback])
            //         - https.createServer(options[, callback])
            //
            //       We can't inspect the callback type because the callback is optional,
            //       but we can inspect the `options` parameter since it is required for
            //       HTTPS calls and HTTP calls don't accept an options object
            //
            //       Note that we do *not* pass the callback into the old createServer();
            //       it's attached to the `request` event after `on` has been patched.
            var cb;
            var isHttps = args.length && typeof args[0] === 'object';
            if (isHttps && args.length >= 1 && typeof args[1] === 'function') {
                cb = args[1];
                args.splice(1, 1);
            }
            else if (!isHttps && args.length && typeof args[0] === 'function') {
                cb = args[0];
                args.splice(0, 1);
            }
            server = oldCreateServer.apply(this, args);
            // NOTE: Any number of `request` listeners may be attached to the server,
            //       either attached indirectly via createServer(cb) or attached directly
            //       via server.on('request', cb).
            //
            //       We must ensure that all of them execute within the same Glimpse context.
            //       We do this by patching server.on() and wrapping `request` listeners,
            //       then creating/adding the context.
            var oldOn = server.on;
            server.on = function glimpseServerOn(eventName, listener) {
                var onArgs = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    onArgs[_i - 2] = arguments[_i];
                }
                if (eventName === 'request') {
                    var oldListener_1 = listener;
                    listener = function (req, res) {
                        // NOTE: Glimpse initialization in the user's app is synchronous (e.g. `glimpse.init()`).
                        //       However, there are some Glimpse services that require asynchronous initialization.
                        //       In those cases, we defer initialization until just prior to handling the first
                        //       request (as that's the first asynchronous hook point provided by Node). When
                        //       initialization is complete, we continue processing the request.                        
                        agent.providers.deferredInitializationManager.init(function (err) {
                            if (err) {
                                throw err;
                            }
                            var context = HttpHelper_1.HttpHelper.getContext(req);
                            // If no context currently exists, create one and attach to request/response objects...
                            if (!context) {
                                context = agent.providers.contextManager.createContext(req);
                                HttpHelper_1.HttpHelper.setContext(req, context);
                                HttpHelper_1.HttpHelper.setContext(res, context);
                            }
                            // Run the handler within the context...
                            return agent.providers.contextManager.runInContext(context, function () { return oldListener_1(req, res); });
                        });
                    };
                }
                return oldOn.call.apply(oldOn, [this, eventName, listener].concat(onArgs));
            };
            // Attach HttpProxy-specific logic to `request` event (which wraps any callback passed to createServer())...
            server.on('request', self.setupServerProxy(agent, cb));
            return server;
        };
    };
    HttpProxy.prototype.setupServerProxy = function (agent, cb) {
        var self = this;
        var maxBodySize = HttpHelper_1.HttpHelper.getMaxBodySize(agent.providers.configSettings);
        return function internalCallback(req, res) {
            var rest = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                rest[_i - 2] = arguments[_i];
            }
            var context = HttpHelper_1.HttpHelper.getContext(req);
            var requestStartTime = self.getCurrentTimeStamp();
            self.raiseRequestStartEvent(req, res, requestStartTime);
            // It is possible in some circumstances that `res.end()` is
            // called before the `data` event on the `req` object is
            // fired. In this case, we check this flag and send the before
            // event immediately before sending the end event.
            var requestEndSent = false;
            // Note: the User Inspector class was rolled into this one
            // because the begin/end events weren't fine graind enough
            // to set these headers at the appropriate time. Once this
            // module is ported to the new proxy paradigm, this can be
            // split back into a separate inspector
            // BEGIN code from UserInspector
            var requestCookies = HttpHelper_1.RequestHelper.parseCookies(req);
            var userId = requestCookies ? requestCookies[SESSION_COOKIE] : undefined;
            if (!userId) {
                HttpHelper_1.ResponseHelper.setCookie(res, SESSION_COOKIE, GuidHelper_1.GuidHelper.newGuid(false));
            }
            // END code from UserInspector
            res.setHeader('X-Glimpse-ContextId', context.id);
            // General performance note for this implementation: this has been identified
            // as a hot path for performance, so there are places where maintainability
            // and readability are sacrificed for performance. Specifically, there is
            // repeated code in here that could be abstracted into helper methods, but
            // would incure the extra stack frame and slow things down
            // Note on Buffers. We use Buffers to store body requests, and we
            // create new buffers a few times as well. We use the Buffer consructor
            // to do this for backwards compatibility reasons, but we should
            // migrate away some day. There is a security risk with using the
            // Buffer constructor, which is why it's been deprecated. More info:
            // https://nodejs.org/api/buffer.html#buffer_buffer_from_buffer_alloc_and_buffer_allocunsafe
            // Chunks may be read back as either Buffers or strings. For now we store
            // them as an array of chunks, and let inspectors figure out the best way
            // to normalize them.
            var requestBodyChunks = [];
            var requestBodyLength = 0;
            var bufferedData = [];
            var isBufferingData = true;
            var isMultiPartFormData = undefined;
            var multiPartFormSummarizer = undefined;
            req.on('data', function (chunk) {
                agent.providers.contextManager.checkContextID('HttpProxy::(request - on(\'data\')', context.id);
                // set up a parser to parse out headers if this is a multi-part form request
                if (isMultiPartFormData === undefined) {
                    multiPartFormSummarizer = MultiPartFormSummarizer_1.createMultiPartFormSummarizer(req.headers['content-type']);
                    if (multiPartFormSummarizer) {
                        isMultiPartFormData = true;
                    }
                    else {
                        isMultiPartFormData = false;
                    }
                }
                if (isBufferingData) {
                    bufferedData.push(chunk);
                }
                if (isMultiPartFormData) {
                    multiPartFormSummarizer.addChunk(chunk);
                }
                var originalChunkLength = chunk.length;
                if (requestBodyLength < maxBodySize) {
                    if (requestBodyLength + originalChunkLength >= maxBodySize) {
                        chunk = chunk.slice(0, maxBodySize - requestBodyLength);
                    }
                    requestBodyChunks.push(chunk);
                }
                requestBodyLength += originalChunkLength;
            });
            var isBufferingEnd = false;
            req.on('end', function () {
                isBufferingEnd = true;
                // TODO:  renable this check when we have an effective context tracking implementation in place
                //agent.providers.contextManager.checkContextID('HttpProxy::(request - on(\'end\')', context.id);
                if (!requestEndSent) {
                    self.raiseRequestEndEvent(req, res, requestBodyChunks, requestBodyLength, requestStartTime, multiPartFormSummarizer ? multiPartFormSummarizer.getParts() : []);
                    requestEndSent = true;
                }
            });
            req.on('error', function (err) {
                self.errorReportingService.reportError(glimpse_common_1.createHttpServerError(err));
            });
            res.on('error', function (err) {
                self.errorReportingService.reportError(glimpse_common_1.createHttpServerError(err));
            });
            // NOTE: We MUST be subscribed to the 'data' and 'end' events PRIOR to patching 'on()'.
            var oldOn = req.on;
            req.on = function newOn(event, onCallback) {
                var _this = this;
                var onRest = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    onRest[_i - 2] = arguments[_i];
                }
                if (isBufferingData && event === 'data') {
                    try {
                        bufferedData.forEach(function (chunk) {
                            onCallback.call(_this, chunk);
                        });
                    }
                    finally {
                        bufferedData = [];
                        isBufferingData = false;
                    }
                }
                else if (isBufferingEnd && event === 'end') {
                    onCallback.call(this);
                }
                return oldOn.call.apply(oldOn, [this, event, onCallback].concat(onRest));
            };
            // Note: it's possible to write data using the `end` method as well,
            // but that method calls `write` under the hood, and patching both
            // leads to a doubly patched write method, which duplicates the body
            var responseBodyChunks = [];
            var responseBodyLength = 0;
            var oldWrite = res.write;
            var responseStartTime = undefined;
            res.write = function (chunk, encoding) {
                var writeArgs = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    writeArgs[_i - 2] = arguments[_i];
                }
                if (!responseStartTime) {
                    responseStartTime = self.getCurrentTimeStamp();
                    self.raiseResponseStartEvent(req, res, responseStartTime);
                }
                // TODO:  renable this check when we have an effective context tracking implementation in place
                //agent.providers.contextManager.checkContextID('HttpProxy::(response.write())', context.id);
                // Short circuit if we're not actually writing anything
                if (typeof chunk === 'function' || typeof chunk === 'undefined') {
                    return oldWrite.call.apply(oldWrite, [this, chunk, encoding].concat(writeArgs));
                }
                // If we don't have the necessary information to normalize
                // to a string, the underlying API will throw, so we short
                // circuit here and call the underlying API
                if (typeof chunk !== 'string' && !Buffer.isBuffer(chunk)) {
                    return oldWrite.call.apply(oldWrite, [this, chunk, encoding].concat(writeArgs));
                }
                // Save part or all of the chunk to the set of chunks,
                // truncating if necessary to keep the set under the
                // max body size
                var originalChunkLength = chunk.length;
                var normalizedChunk = chunk;
                if (responseBodyLength < maxBodySize) {
                    if (responseBodyLength + originalChunkLength >= maxBodySize) {
                        normalizedChunk = normalizedChunk.slice(0, maxBodySize - responseBodyLength);
                    }
                    responseBodyChunks.push(normalizedChunk);
                }
                responseBodyLength += originalChunkLength;
                return oldWrite.call.apply(oldWrite, [this, chunk, encoding].concat(writeArgs));
            };
            // We override the setHeader method so we can intercept the
            // content-type and set the request ID header if this is the
            // first request for the page. We will know if this request
            // was the first request for the page if it's a) a request
            // for HTML and b) it's not an AJAX request because it's not
            // possible to request HTML content after the initial request
            // *except* via AJAX.
            var oldSetHeader = res.setHeader;
            res.setHeader = function setHeader(name, value) {
                var setHeaderArgs = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    setHeaderArgs[_i - 2] = arguments[_i];
                }
                oldSetHeader.call.apply(oldSetHeader, [this, name, value].concat(setHeaderArgs));
                if (name.toLowerCase() === 'content-type' && value.indexOf('text/html') === 0 && HttpHelper_1.RequestHelper.header(req, IS_AJAX_HEADER) !== 'true') {
                    HttpHelper_1.ResponseHelper.setCookie(res, REQUEST_ID_COOKIE, context.id);
                }
            };
            res.on('finish', function () {
                // TODO:  renable this check when we have an effective context tracking implementation in place
                //agent.providers.contextManager.checkContextID('HttpProxy::(request - on(\'finish\')', context.id);
                if (!requestEndSent) {
                    // If we got here, it means that the `res.end()` method
                    // was called before the request `end` event was fired.
                    // This could happen for a variety of reasons, mostly
                    // when the user calls `res.end` before the request has
                    // finished flushing. Most often, this happens because
                    // the body has not been recieved, but we try and send
                    // whatever body we have receieved so far.
                    self.raiseRequestEndEvent(req, res, requestBodyChunks, requestBodyLength, requestStartTime, multiPartFormSummarizer ? multiPartFormSummarizer.getParts() : []);
                    requestEndSent = true;
                    // We check to see if content length was set, and if it
                    // was and we haven't seen that much of the body yet,
                    // we report an error that not all of the body was captured
                    var contentLength = HttpHelper_1.RequestHelper.header(req, 'content-length');
                    if (contentLength && contentLength > requestBodyLength && self.errorReportingService) {
                        self.errorReportingService.reportError(glimpse_common_1.createHttpServerEarlyRequestTerminationError(req.url));
                    }
                }
                responseStartTime = responseStartTime || self.getCurrentTimeStamp();
                self.raiseResponseEndEvent(req, res, responseBodyChunks, responseBodyLength, responseStartTime);
            });
            if (cb) {
                cb.apply(void 0, [req, res].concat(rest));
            }
        };
    };
    HttpProxy.prototype.setupInspectorExtensions = function (agent) {
        for (var _i = 0, _a = this.inspectors; _i < _a.length; _i++) {
            var inspector = _a[_i];
            inspector.init(agent);
        }
    };
    HttpProxy.prototype.addServerInspector = function (inspector) {
        if (this.proxiedModules.length) {
            throw new Error('Cannot add inspectors after the proxy has been initialized for the first time');
        }
        this.inspectors.push(inspector);
    };
    HttpProxy.prototype.init = function (agent, httpModule, resolvedModulePath, errorReportingService) {
        this.agent = agent;
        this.errorReportingService = errorReportingService;
        // We can only initialize the proxies once, otherwise we will get n
        // copies of all messages because the proxies will nest inside each other
        if (this.proxiedModules.indexOf(httpModule) !== -1) {
            throw new Error('Cannot proxy a module that has already been proxied');
        }
        this.proxiedModules.push(httpModule);
        this.patchCreateServer(agent, httpModule);
        this.setupInspectorExtensions(agent);
        return httpModule;
    };
    ;
    return HttpProxy;
}(ProxyBase_1.ProxyBase));
exports.HttpProxy = HttpProxy;

//# sourceMappingURL=../../maps/inspectors/HttpProxy.js.map
