'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var DateTimeValue_1 = require("../configuration/DateTimeValue");
var moment = require("moment");
var Tracing_1 = require("../tracing/Tracing");
var _ = require("lodash");
var GuidHelper_1 = require("../util/GuidHelper");
var MongoDBEvents_1 = require("../tracing/module_instrumentors/MongoDBEvents");
/**
 * Class that represents a set of data that we pass along as part of the "options"
 * parameter to various MongoDB calls. This lets us pass data between multiple proxy calls on the
 * same call stack or call chain.
 */
var GlimpseMongoDBOptions = (function () {
    function GlimpseMongoDBOptions() {
        this._recordsRead = 0;
        this.messagesSent = {};
    }
    Object.defineProperty(GlimpseMongoDBOptions.prototype, "operationName", {
        /**
         * Get the operation name
         */
        get: function () {
            return this._operationName;
        },
        /**
         * Set the primary operation name for this call chain.  This is what is shown in the custom message.
         */
        set: function (name) {
            this._operationName = name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GlimpseMongoDBOptions.prototype, "correlationId", {
        /**
         * Get correlation ID for messages on this cursor
         */
        get: function () {
            return this._correlationId;
        },
        /**
         * set correlation ID for messages on this cursor
         */
        set: function (guid) {
            this._correlationId = guid;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * set if a message is sent for the given message type
     */
    GlimpseMongoDBOptions.prototype.getMessageSent = function (messageType) {
        return this.messagesSent[messageType];
    };
    /**
     * get if a message is sent for the given message type
     */
    GlimpseMongoDBOptions.prototype.setMessageSent = function (messageType, sent) {
        this.messagesSent[messageType] = sent;
    };
    Object.defineProperty(GlimpseMongoDBOptions.prototype, "recordsRead", {
        get: function () {
            return this._recordsRead;
        },
        set: function (recordsRead) {
            this._recordsRead = recordsRead;
        },
        enumerable: true,
        configurable: true
    });
    GlimpseMongoDBOptions.prototype.incremenetRecordsRead = function () {
        ++this._recordsRead;
    };
    Object.defineProperty(GlimpseMongoDBOptions.prototype, "readStartTime", {
        get: function () {
            return this._readStartTime;
        },
        set: function (readStartTime) {
            this._readStartTime = readStartTime;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Return the GlimpseMongoDBOptions instance from the given object, or return undefined if not available.
     */
    GlimpseMongoDBOptions.get = function (options) {
        var gopts;
        if (options) {
            gopts = options[GlimpseMongoDBOptions.CUSTOM_KEY];
        }
        return gopts;
    };
    /**
     * Remove the GlimpseMongoDBOptions instance from the given object
     */
    GlimpseMongoDBOptions.clear = function (options) {
        if (options && options[GlimpseMongoDBOptions.CUSTOM_KEY]) {
            delete options[GlimpseMongoDBOptions.CUSTOM_KEY];
        }
    };
    /**
     *  Ensure the GlimpseMongoDBOptions instance exists on the given object, and return it.
     */
    GlimpseMongoDBOptions.ensure = function (options) {
        var gopts = options[GlimpseMongoDBOptions.CUSTOM_KEY];
        if (!gopts) {
            gopts = new GlimpseMongoDBOptions();
            options[GlimpseMongoDBOptions.CUSTOM_KEY] = gopts;
        }
        return gopts;
    };
    return GlimpseMongoDBOptions;
}());
GlimpseMongoDBOptions.CUSTOM_KEY = '__glimpse_customOptions';
exports.GlimpseMongoDBOptions = GlimpseMongoDBOptions;
var MongoDBInspector = (function () {
    function MongoDBInspector() {
        this.listeners = {};
    }
    MongoDBInspector.prototype.init = function (agent) {
        var _this = this;
        this.agent = agent;
        this.contextManager = agent.providers.contextManager;
        this.listeners = (_a = {},
            _a[MongoDBEvents_1.EVENT_MONGODB_COLLECTION_INSERT] = function (event) {
                _this.insertInspector(event);
            },
            _a[MongoDBEvents_1.EVENT_MONGODB_COLLECTION_INSERT_METHODS] = function (event) {
                _this.insertMethodsInspector(event);
            },
            _a[MongoDBEvents_1.EVENT_MONGODB_COLLECTION_UPDATE_METHODS] = function (event) {
                _this.updateMethodsInspector(event);
            },
            _a[MongoDBEvents_1.EVENT_MONGODB_COLLECTION_COUNT] = function (event) {
                _this.countInspector(event);
            },
            _a[MongoDBEvents_1.EVENT_MONGODB_COLLECTION_DELETE_METHODS] = function (event) {
                _this.deleteMethodsInspector(event);
            },
            _a[MongoDBEvents_1.EVENT_MONGODB_READ_START] = function (event) {
                _this.readStartInspector(event);
            },
            _a[MongoDBEvents_1.EVENT_MONGODB_READ_RECORD] = function (event) {
                _this.readRecordInspector(event);
            },
            _a[MongoDBEvents_1.EVENT_MONGODB_READ_END] = function (event) {
                _this.readEndInspector(event);
            },
            _a);
        for (var event_1 in this.listeners) {
            if (!this.listeners.hasOwnProperty(event_1)) {
                continue;
            }
            Tracing_1.default.onAlways(event_1, this.listeners[event_1]);
        }
        var _a;
    };
    MongoDBInspector.prototype.removeEventListeners = function () {
        for (var event_2 in this.listeners) {
            if (!this.listeners.hasOwnProperty(event_2)) {
                continue;
            }
            Tracing_1.default.removeEventListener(event_2, this.listeners[event_2]);
        }
    };
    /**
     *  send message indicating first read of a record from mongo
     */
    MongoDBInspector.prototype.sendReadStartMessage = function (err, correlationId, operation, startTime, query, options, ci) {
        var context = this.contextManager.currentContext();
        if (context) {
            var endTime = this.agent.providers.dateTime.now;
            this.agent.broker.createAndSendMessage({
                correlationId: correlationId,
                operation: operation,
                query: query,
                startTime: startTime.format(),
                duration: endTime.diff(startTime),
                options: options,
                connectionHost: ci.host,
                connectionPort: ci.port,
                database: ci.database,
                collection: ci.collectionName
            }, ['data-mongodb-read-start'], undefined /*indices*/, context);
        }
    };
    ;
    /**
     * send message indicating mongodb cursor was closed and a read effectively ended.
     *
     * closeStartTime is the point in time when the close method was called.
     */
    MongoDBInspector.prototype.sendReadEndMessage = function (err, correlationId, closeStartTime, readStartTime, totalRecordsRead) {
        var context = this.contextManager.currentContext();
        if (context) {
            var endTime = this.agent.providers.dateTime.now;
            this.agent.broker.createAndSendMessage({
                correlationId: correlationId,
                startTime: closeStartTime.format(),
                duration: endTime.diff(closeStartTime),
                totalReadTimeDuration: endTime.diff(readStartTime),
                totalRecordsRead: totalRecordsRead
            }, ['data-mongodb-read-end'], undefined /*indices*/, context);
        }
    };
    ;
    /**
     *  sendAfterInsertMessage
     */
    MongoDBInspector.prototype.sendAfterInsertMessage = function (err, operation, startTime, docs, numInserted, insertedIDs, options, ci) {
        var context = this.contextManager.currentContext();
        if (context) {
            var endTime = this.agent.providers.dateTime.now;
            this.agent.broker.createAndSendMessage({
                operation: operation,
                docs: docs,
                count: numInserted,
                insertedIds: insertedIDs,
                startTime: startTime.format(),
                duration: endTime.diff(startTime),
                options: options,
                connectionHost: ci.host,
                connectionPort: ci.port,
                database: ci.database,
                collection: ci.collectionName
            }, ['data-mongodb-insert'], undefined /*indices*/, context);
        }
    };
    ;
    /**
     * method to send an update completed message
     */
    MongoDBInspector.prototype.sendAfterUpdateMessage = function (err, operation, startTime, query, updates, matchedCount, modifiedCount, upsertedCount, options, ci) {
        var context = this.contextManager.currentContext();
        if (context) {
            var endTime = this.agent.providers.dateTime.now;
            this.agent.broker.createAndSendMessage({
                operation: operation,
                query: query,
                updates: updates,
                matchedCount: matchedCount,
                modifiedCount: modifiedCount,
                upsertedCount: upsertedCount,
                startTime: startTime.format(),
                duration: endTime.diff(startTime),
                options: options,
                connectionHost: ci.host,
                connectionPort: ci.port,
                database: ci.database,
                collection: ci.collectionName
            }, ['data-mongodb-update'], undefined /*indices*/, context);
        }
    };
    ;
    /**
     * method to send a delete completed message.
     */
    MongoDBInspector.prototype.sendAfterDeleteMessage = function (err, operation, startTime, query, numDeleted, options, ci) {
        var context = this.contextManager.currentContext();
        if (context) {
            var endTime = this.agent.providers.dateTime.now;
            this.agent.broker.createAndSendMessage({
                operation: operation,
                query: query,
                count: numDeleted,
                startTime: startTime.format(),
                duration: endTime.diff(startTime),
                options: options,
                connectionHost: ci.host,
                connectionPort: ci.port,
                database: ci.database,
                collection: ci.collectionName
            }, ['data-mongodb-delete'], undefined /*indices*/, context);
        }
    };
    ;
    /**
     * Handle insert method
     */
    MongoDBInspector.prototype.insertInspector = function (event) {
        // since insert implementation calls back in on insertMany, we need to override the operation name used
        GlimpseMongoDBOptions.ensure(event.data.originalArgs[1]).operationName = 'insert';
    };
    ;
    /**
     * Notify insert methods including 'insertMany' and 'insertOne'
     */
    MongoDBInspector.prototype.insertMethodsInspector = function (event) {
        var connectionInfo = MongoDBInspector.GetConnectionInfoFromCollection(event.data.originalThis);
        var docs = event.data.originalArgs[0];
        var options = event.data.originalArgs[1];
        var methodName = event.data.methodName;
        var count = 0;
        var insertedIDs = [];
        var result = event.data.result;
        if (typeof options === 'function') {
            options = undefined;
        }
        var operationName = methodName;
        var opts = GlimpseMongoDBOptions.get(options);
        if (opts) {
            if (opts.operationName) {
                operationName = opts.operationName;
            }
            // strip out the custom options as they're no longer necessary
            GlimpseMongoDBOptions.clear(options);
        }
        if (!options) {
            options = {};
        }
        else {
            // strip out the custom options as they're no longer necessary
            GlimpseMongoDBOptions.clear(options);
            options = _.cloneDeep(options);
            // strip out checkKeys as Mongo adds this
            options.checkKeys = undefined;
        }
        if (methodName === 'insertOne') {
            docs = [docs];
        }
        if (!event.data.err) {
            if (methodName === 'insertOne') {
                if (result) {
                    count = result.ops.length;
                    insertedIDs = [result.insertedId];
                }
            }
            else {
                if (result) {
                    count = result.insertedCount;
                    insertedIDs = result.insertedIds;
                }
            }
        }
        this.sendAfterInsertMessage(event.data.err, operationName, DateTimeValue_1.DateTimeValue.fromMomentAndHRTime(event.data.startTime, event.data.hrtime), docs, count, insertedIDs, options, connectionInfo);
    };
    ;
    /**
     * Notify delete methods including 'deleteMany', 'deleteOne', 'findOneAndDelete', 'remove'
     */
    MongoDBInspector.prototype.deleteMethodsInspector = function (event) {
        var originalArgs = event.data.originalArgs;
        var filter = originalArgs[0];
        var options = originalArgs[1];
        var connectionInfo = MongoDBInspector.GetConnectionInfoFromCollection(event.data.originalThis);
        var count = 0;
        var result = event.data.result;
        var methodName = event.data.methodName;
        if (typeof options === 'function') {
            options = undefined;
        }
        if (!options) {
            options = {};
        }
        else {
            GlimpseMongoDBOptions.clear(options);
            options = _.cloneDeep(options);
        }
        if (result) {
            if (methodName === 'findOneAndDelete') {
                if (result.value) {
                    count = 1;
                }
            }
            else if (methodName === 'remove') {
                if (result.result) {
                    count = result.result.n;
                }
            }
            else {
                count = result.deletedCount;
            }
        }
        this.sendAfterDeleteMessage(event.data.err, methodName, DateTimeValue_1.DateTimeValue.fromMomentAndHRTime(event.data.startTime, event.data.hrtime), filter, count, options, connectionInfo);
    };
    ;
    /**
     * Notify update operation
     */
    MongoDBInspector.prototype.updateMethodsInspector = function (event) {
        var connectionInfo = MongoDBInspector.GetConnectionInfoFromCollection(event.data.originalThis);
        var originalArgs = event.data.originalArgs;
        var result = event.data.result;
        var methodName = event.data.methodName;
        var filter = originalArgs[0];
        var update = originalArgs[1];
        var options = originalArgs[2];
        var matchedCount = 0;
        var modifiedCount = 0;
        var upsertedCount = 0;
        if (typeof options === 'function') {
            options = undefined;
        }
        if (!options) {
            options = {};
        }
        else {
            // strip out the custom options as they're no longer necessary
            GlimpseMongoDBOptions.clear(options);
            options = _.cloneDeep(options);
        }
        if (result) {
            matchedCount = result.matchedCount;
            modifiedCount = result.modifiedCount;
            upsertedCount = result.upsertedCount;
            if (methodName === 'findOneAndUpdate') {
                if (result.lastErrorObject.updatedExisting) {
                    upsertedCount = 0;
                    matchedCount = 1;
                    modifiedCount = 1;
                }
                else if (result.lastErrorObject.n > 0) {
                    upsertedCount = 1;
                    matchedCount = 1;
                    modifiedCount = 0;
                }
                else {
                    upsertedCount = 0;
                    matchedCount = 0;
                    modifiedCount = 0;
                }
            }
        }
        this.sendAfterUpdateMessage(event.data.err, event.data.methodName, DateTimeValue_1.DateTimeValue.fromMomentAndHRTime(event.data.startTime, event.data.hrtime), filter, update, matchedCount, modifiedCount, upsertedCount, options, connectionInfo);
    };
    ;
    /**
     *  Inspect collection read count
     */
    MongoDBInspector.prototype.countInspector = function (event) {
        var originalThis = event.data.originalThis;
        var originalArgs = event.data.originalArgs;
        var connectionInfo = MongoDBInspector.GetConnectionInfoFromCollection(originalThis);
        var query = originalArgs[0];
        var options = event.data.originalArgs[1];
        var correlationId = GuidHelper_1.GuidHelper.newGuid();
        var startTime = DateTimeValue_1.DateTimeValue.fromMomentAndHRTime(event.data.startTime, event.data.hrtime);
        if (typeof options === 'function') {
            options = undefined;
        }
        if (!options) {
            options = {};
        }
        this.sendReadStartMessage(event.data.err, correlationId, event.data.methodName, startTime, query, options, connectionInfo);
        // for count, assume that we always read just one record if no error.
        var recordsRead = event.data.err ? 0 : 1;
        this.sendReadEndMessage(event.data.err, correlationId, startTime, startTime, recordsRead);
    };
    ;
    /*
     * send the read start message to mark the begining of a set of read operations
     */
    MongoDBInspector.prototype.readStartInspector = function (event) {
        var originalThis = event.data.originalThis;
        var cursorCustomOpts = GlimpseMongoDBOptions.ensure(originalThis.s.cmd);
        if (!cursorCustomOpts.getMessageSent('data-mongodb-read-start')) {
            cursorCustomOpts.setMessageSent('data-mongodb-read-start', true);
            var connectionInfo = MongoDBInspector.GetConnectionInfoFromCursor(originalThis);
            cursorCustomOpts.operationName = event.data.methodName;
            cursorCustomOpts.readStartTime = DateTimeValue_1.DateTimeValue.fromUnixMillisecondTimestamp(event.timestamp, event.time);
            // check for existing correlation ID, as this will be present if close() is called before next()/each()/forEach()/...
            if (!cursorCustomOpts.correlationId) {
                cursorCustomOpts.correlationId = GuidHelper_1.GuidHelper.newGuid();
            }
            // clone options & clear out Glimpse opts so we don't include them in Glimpse messages
            var opts = _.cloneDeep(originalThis.s.cmd);
            GlimpseMongoDBOptions.clear(opts);
            this.sendReadStartMessage(event.data.err, cursorCustomOpts.correlationId, cursorCustomOpts.operationName, cursorCustomOpts.readStartTime, originalThis.s.cmd.query, opts, connectionInfo);
        }
    };
    /**
     * respond to each record being read through a cursor.
     */
    MongoDBInspector.prototype.readRecordInspector = function (event) {
        var originalThis = event.data.originalThis;
        var operationName = event.data.methodName;
        var cursorCustomOpts = GlimpseMongoDBOptions.ensure(originalThis.s.cmd);
        if (cursorCustomOpts.operationName) {
            operationName = cursorCustomOpts.operationName;
        }
        if (event.data.result) {
            // Kinda' hacky to count number of records read.  Ultimately this logic should be pulled out 
            // into the "tracing" part so that a set of clear logical events are emitted indicating what is happening.  
            //  - for toArray() calls we just get the length of the array.
            //  - for each(), next() will be invoked by the underlying implementation, so we don't want to double-count records. 
            //  - for forEach(), each() will be invoked by the driver.
            var isSpecial = operationName === 'toArray' || operationName === 'each' || operationName === 'forEach';
            if (operationName === 'toArray' && Array.isArray(event.data.result)) {
                cursorCustomOpts.recordsRead = event.data.result.length;
            }
            else if (operationName === 'each' && event.data.methodName === 'each') {
                cursorCustomOpts.incremenetRecordsRead();
            }
            else if (operationName === 'forEach' && event.data.methodName === 'each') {
                cursorCustomOpts.incremenetRecordsRead();
            }
            else if (!isSpecial) {
                cursorCustomOpts.incremenetRecordsRead();
            }
        }
    };
    /**
     * respond to the end of a read operation through a cursor.  Should generally respond to a cursor close.
     */
    MongoDBInspector.prototype.readEndInspector = function (event) {
        var originalThis = event.data.originalThis;
        var cursorCustomOpts = GlimpseMongoDBOptions.ensure(originalThis.s.cmd);
        var correlationId = cursorCustomOpts.correlationId;
        var readStartTime = cursorCustomOpts.readStartTime;
        var totalRecordsRead = cursorCustomOpts.recordsRead;
        if (!correlationId) {
            // account for cases where a cursor is closed before the first record is read.
            correlationId = GuidHelper_1.GuidHelper.newGuid();
            cursorCustomOpts.correlationId = correlationId;
            readStartTime = DateTimeValue_1.DateTimeValue.fromMomentAndHRTime(moment(), process.hrtime());
            totalRecordsRead = 0;
        }
        if (!cursorCustomOpts.getMessageSent('data-mongodb-read-end')) {
            cursorCustomOpts.setMessageSent('data-mongodb-read-end', true);
            this.sendReadEndMessage(event.data.err, correlationId, DateTimeValue_1.DateTimeValue.fromMomentAndHRTime(event.data.startTime, event.data.hrtime), readStartTime, totalRecordsRead);
        }
    };
    /**
     * method to extract connection info details from a MongoDB Cusror istance
     */
    MongoDBInspector.GetConnectionInfoFromCursor = function (cursor) {
        // Mongo driver 2.0 and 2.1 support serverDetails but not availableConnections,
        // but Mongo driver 2.2. supports availableConnections but not serverDetails.
        var host, port;
        if (cursor.topology.s.serverDetails) {
            host = cursor.topology.s.serverDetails.host;
            port = cursor.topology.s.serverDetails.port;
        }
        else if (cursor.topology.s.pool.availableConnections.length) {
            host = cursor.topology.s.pool.availableConnections[0].host;
            port = cursor.topology.s.pool.availableConnections[0].port;
        }
        var dbname = cursor.options.db.s.databaseName;
        return {
            host: host,
            port: port,
            database: dbname,
            collectionName: cursor.ns.substring(dbname.length + 1)
        };
    };
    /**
     * method to extract connection info details from a MongoDB Collection istance
     */
    MongoDBInspector.GetConnectionInfoFromCollection = function (collection) {
        return {
            host: collection.s.topology.s.host,
            port: collection.s.topology.s.port,
            database: collection.s.dbName,
            collectionName: collection.s.name
        };
    };
    return MongoDBInspector;
}());
exports.MongoDBInspector = MongoDBInspector;

//# sourceMappingURL=../../maps/inspectors/MongoDBInspector.js.map
