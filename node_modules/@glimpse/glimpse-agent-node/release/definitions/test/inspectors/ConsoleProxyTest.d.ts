import { IAgent } from '../../IAgent';
import { IContext } from '../../messaging/IContextManager';
import { IStackHelper } from '../../inspectors/util/StackHelper';
import { LogLevel } from '../../inspectors/ConsoleProxy';
/**
 * Interface of the basic methods on a console instance we expect to test
 */
export interface IConsole {
    assert(val: boolean, format: string, ...params: any[]): any;
    log(format: string, ...params: any[]): any;
    info(format: string, ...params: any[]): any;
    warn(format: string, ...params: any[]): any;
    error(format: string, ...params: any[]): any;
    dir(obj: any, options?: Object, ...params: any[]): any;
    time(label?: string, ...params: any[]): any;
    timeEnd(label?: string, ...params: any[]): any;
    trace(format?: string, ...params: any[]): any;
}
/**
 * A class that will allow testing of console logging methods & validation of the message behavior.
 * A ConsoleProxyTest wraps an underlying IConsole interface and then proxies various log methods to
 * underlying IConsole, and validates the messages & contents are as expected.
 *
 * The intention it to use this for unit tests (with a MockConsole instance) and for integration tests
 * (with the actual node console module or a specific instance of Console).
 */
export declare class ConsoleProxyTest {
    private _console;
    private _agent;
    private _server;
    private messageValidator;
    /**
     * Constructor
     */
    constructor(consoleInstance: IConsole, agent: IAgent, server?: any);
    /**
     * helper to get the SourceMapConsumer cache populated.  This lets the messages
     * get produced synchronously instead of async, as loading source map info has to
     * happen async.
     */
    prepSourceMapCache(stackHelper: IStackHelper, done: any): void;
    /**
     * get messages for the given request ID and of the given types
     */
    getMessages(requestId: any, types: any): any;
    /**
     * invoke underlying IConsole's assert() method & validate Glimpse message
     */
    assert(assertVal: boolean, msg: string, ...params: any[]): void;
    /**
     * invoke underlying IConsole's log() method & validate Glimpse message
     */
    log(msg: any, ...params: any[]): void;
    /**
     * invoke underlying IConsole's info() method & validate Glimpse message
     */
    info(msg: string, ...params: any[]): void;
    /**
     * invoke underlying IConsole's warn() method & validate Glimpse message
     */
    warn(msg: string, ...params: any[]): void;
    /**
     * invoke underlying IConsole's error() method & validate Glimpse message
     */
    error(msg: string, ...params: any[]): void;
    /**
     * invoke underlying IConsole's error() method & validate Glimpse message
     */
    trace(msg?: string, ...params: any[]): void;
    /**
     * invoke underlying IConsole's dir() method & validate Glimpse message
     */
    dir(obj: any, options?: Object, ...params: any[]): void;
    /**
     * invoke underlying IConsole's dir() method & validate Glimpse message
     */
    time(label: any, ...params: any[]): void;
    /**
     * invoke underlying IConsole's dir() method & validate Glimpse message
     */
    timeEnd(label: any, ...params: any[]): void;
    /**
     * invoke the underlying console API & validate the result.
     *
     * @testFn - the function to do call the acutal IConsole API
     * @consoleMethodCalled - the method we actually called on the underlying console object.
     * @expectedConsoleMethod - the method we expect to be invoked on the underlying console.  In some cases, this differs from the proxied method.  E.g., error() calls warn().
     * @expectedSeverity - the severity we expect in the Glimpse message
     * @expectMessage - true if we expect a glimpse message to be produced, false if we expect no message.
     */
    private test(testFn, expectedMessage, consoleMethodCalled, expectedConsoleMethodInvoked, expectedSeverity, expectMessage);
    /**
     * Verify that a glimpse 'log-write' message was written for the given context, and verify message  format & contents.
     *
     * @context - the context of the message we want to verify
     * @expectedMessage - the expected, formatted message we expect to see in tme glimpse message's payload
     * @expectedConsoleMethod - the name of the console method we expect to be invoked.
     * @expectedSeverity - the severity we expect in the glimpse message's payload
     * @replacedRegions - array of objects of the form {start:n, end:n} that indicate regions of the message that were replaced by a format command.
     */
    verify(context: IContext, expectedMessage: string | any[], consoleMethodCalled: string, expectedConsoleMethodInvoked: string, expectedSeverity: LogLevel): void;
    /**
     * Verify that no glimpse 'log-write' message was written for the given context
     *
     * @context - the context of the message we want to verify
     * @expectedConsoleMethod - the name of the console method we expect to be invoked. gions of the message that were replaced by a format command.
     */
    verifyNoMessage(context: IContext, expectedConsoleMethod: string): void;
    private static oracleId;
    private static oracles;
    private addOracle(method, args, message);
    static flushOracle(path: string, done: any): void;
}
