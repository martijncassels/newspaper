/// <reference types="node" />
/**
 * This exports a class that can efficiently perform stream-based parsing of multipart/form-data http values.
 * The code is tolerant in the face of errors/malformed bodies in that the parser instance can be queried
 *  after all chunks have been admitted for summaries of the various parts.
 *
 * The parser implements a determinstic state machine which let's us parse the content
 * one character at a time, without backtracking. Each state has a set of transitions that map
 * the next character to a new state.  If no match is found, each state has a "fallback state".
 *
 * Key RFCs:
 *    - RFC 2388 - Returning Values From Forms: multipart/form-data (https://www.ietf.org/rfc/rfc2388.txt)
 *    - RFC 2046 - Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types. (https://tools.ietf.org/html/rfc2046)
 *               - Note section 5.1 of 2046 for definitions on boundary delimiters.
 *    - RFC 2045 - Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies (https://tools.ietf.org/html/rfc2045)
 */
/**
 *  A summary of a single part in a multi-part/form body
 */
export interface IPartSummary {
    rawHeaders: string;
    bodyStartIndex: number;
    bodyEndIndex: number;
}
/**
 * class that performs the parsing.
 */
export declare class MultiPartFormParser {
    private boundary;
    private encoding;
    private stateTable;
    private currentState;
    private parts;
    private rawHeaderSections;
    private consumeHeaders;
    private currentCharacterIndex;
    private currentBoundaryStartIndex;
    constructor(boundary: string, encoding: string);
    /**
     * Add a chunk of body to be parsed.  Once all chunks have been added, the part summaries can
     * be retrieved by calling getParts()
     */
    addChunk(chunk: Buffer | string): void;
    /**
     * Retrieve known parts.  For accurate representation, should only be called after all chunks of the body have been added.
     */
    getParts(): IPartSummary[];
    /**
     * Add all the state transitions for the parser
     */
    private populateStateTable();
    /**
     * resolves indexes for transition states to their state entry instances.  Avoids any runtime lookups into state table
     */
    private resolveStateTable();
    /**
     *  Add a state entry to the state table.  Transitions from `initialState` are defined by the entries in `transitions` array.
     */
    private addStateEntry(initialState, fallBackStateID, transitions, onFallback?, debugDescription?);
    /**
     * Add a set of state transitions for a boundary string.  e.g., `--boundary-delimiter-1`
     *
     * @s: the string to construct state entries for.  A "minor state" will be constructed for each character in this string
     * @initialState:  the initial state of the parser to apply this rule.
     * @finalTransitionState:  the final state we will transition too if the string is matched.
     * @fallBackState:  The fallback state we will revert to if we don't match a character.
     * @nextStateId:  The number at which we should start assigning state IDs.  This should be unique among all the state entries
     */
    private addBoundaryStates(s, initialState, finalTransitionState, fallBackState, nextStateId);
    private notifyStartHeaderSection();
    private notifyEndHeaderSection();
    private notifyStartBodySection();
    private notifyEndBodySection();
    private notifyNextCharacter(c);
    private notifyDone();
    /**
     * scan a buffer that has been added to
     */
    private scanBuffer(chunk);
    /**
     * scan a string of characters that has been added
     */
    private scanString(chunk);
}
