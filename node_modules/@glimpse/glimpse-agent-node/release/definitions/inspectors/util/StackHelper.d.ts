/// <reference types="node" />
import * as url from 'url';
import { IErrorReportingService } from '@glimpse/glimpse-common';
export interface IStackFrame {
    functionName: string;
    fileName: string;
    lineNumber: number;
    columnNumber: number;
    source: string;
}
export interface IStackHelper {
    captureStack(stackTopFunction: any, numFrames: number): IStackFrame[];
    mapFrames(frames: IStackFrame[], callback: (mappedFrames: IStackFrame[]) => void): void;
    tryGetFirstUserCodeFrame(stackFrames: IStackFrame[]): IStackFrame;
}
export declare class StackHelper implements IStackHelper {
    /**
     * cache of generated source files to the SourceMapConsumer instance
     */
    private mapCache;
    /**
     * keep track of any strings we can't parse so we only report an error once per string
     */
    private reportedErrors;
    private errorReportingService;
    constructor(errorService: IErrorReportingService);
    private agentRoot;
    /**
     * capture the current stack trace.
     *
     * @stackTopFunction is a function that will mark the top of the stack in the returned trace.
     * All functions include stackTopFunction & above will be omitted.
     *
     * @numFrames - the number of stack frames to capture
     *
     */
    captureStack(stackTopFunction: any, numFrames: number): IStackFrame[];
    /**
     * will return the first frame on the stack above stackTopFunction and not in the node_modules directory and
     * not a native module.  If such a frame can't be found, it will return the top of the stack.
     */
    tryGetFirstUserCodeFrame(frames: IStackFrame[]): IStackFrame;
    /**
     * returns true if the given frame is for glimpse code
     */
    isGlimpseFrame(frame: IStackFrame): boolean;
    /**
     * returns true if the given frame is for a node built-in function
     */
    isBuiltIn(frame: IStackFrame): boolean;
    /**
     * given an array of stack frames, apply source map information to create a new array of stack frames.
     * The callback will be invoked with the new stack frames with mapping info avaialable
     */
    mapFrames(frames: IStackFrame[], callback: (mappedFrames: IStackFrame[]) => void): void;
    /**
     * given content, look up the source map UI.  Public for testing purposes.
     */
    getMappingUriFromContent(sourceFile: string, data: string): url.Url;
    /**
     * Parse a string form of a single stack frame and return an IStackFrame instance.  Public for testing purposes.
     */
    parseFrameEntry(source: string): IStackFrame;
    /**
     * given the existing stack frame, create map a new stack frame where data has been replaced with values from source maps, if available.
     */
    private mapFrame(frame, callback);
    /**
     * given a stack frame & a sourceMapConsumer, return a new stack frame with the
     * generated filename/line/column values replaced with the values from the source map.
     *
     * If sourceMapConsumer is null, then original fram will be returned.
     */
    private createMappedFrame(sourceMapConsumer, frame);
    /**
     * given a path to a source file, find the source mapping URI, and invoke given callback with UI.
     */
    private getMappingUriFromFile(sourceFile, callback);
    /**
     * given a URI to a source map, create a SourceMapConsumer, and invoke the given callback with it.
     */
    private loadSourceMapConsumer(generatedFile, uri, callback);
}
