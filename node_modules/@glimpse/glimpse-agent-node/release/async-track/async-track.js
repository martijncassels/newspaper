'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
/*tslint:disable:no-var-requires */
var proxiedModule = require('module');
var instrumentConfig = require('./config/instrument-config');
/*tslint:enable:no-var-requires */
var originalRequire = proxiedModule.prototype.require;
var cbConfig = instrumentConfig.cbconfig;
// private instance
var instance;
function getAsyncTrack() {
    if (!instance) {
        instance = new AsyncTrack();
    }
    return instance;
}
exports.getAsyncTrack = getAsyncTrack;
// non-exported implementation
var AsyncTrack = (function () {
    function AsyncTrack() {
        this.asyncIdCounter = 0;
        this.currentAsyncId = 0;
        this.currentAsyncState = undefined;
        this.currentAsyncNamePath = undefined;
        this.handlers = [];
        if (!originalRequire.__asyncTrack_original__) {
            this.asyncTrackInit();
        }
        else {
            throw new Error('AsyncTrack instance initialized more than once!');
        }
    }
    AsyncTrack.prototype.addHandler = function (h) {
        this.handlers.push(h);
    };
    AsyncTrack.prototype.removeHandler = function (h) {
        var index = this.handlers.indexOf(h);
        this.handlers.splice(index, 1);
    };
    AsyncTrack.prototype.getCurrentId = function () {
        return this.currentAsyncId;
    };
    AsyncTrack.prototype.getCurrentContext = function () {
        return this.currentAsyncState;
    };
    AsyncTrack.prototype.getCurrentNamePath = function () {
        return this.currentAsyncNamePath;
    };
    /* tslint:disable:no-any */
    AsyncTrack.prototype.runInContext = function (callback, state) {
        /* tslint:enable:no-any */
        var saveState = this.currentAsyncState;
        try {
            this.currentAsyncState = state;
            return callback();
        }
        finally {
            this.currentAsyncState = saveState;
        }
    };
    AsyncTrack.prototype.raiseWarning = function (msg) {
        this.handlers.forEach(function (h) {
            if (h && h.onWarning) {
                h.onWarning(msg);
            }
        });
    };
    AsyncTrack.prototype.raiseError = function (msg) {
        this.handlers.forEach(function (h) {
            if (h && h.onError) {
                h.onError(msg);
            }
        });
    };
    AsyncTrack.prototype.fatalError = function (msg) {
        this.raiseError(msg);
        // exit process in a timeout so we give chance for any telemetry to flush
        setTimeout(function () {
            process.exit(1);
        }, 1000);
    };
    AsyncTrack.prototype.stamp = function (originalFunction, wrapperFunction, namePath) {
        AsyncTrack.copyProps(originalFunction, wrapperFunction);
        if (originalFunction.__asyncTrack_original__) {
            var name_1 = namePath.join('.');
            this.raiseWarning("originalFunction already has __asyncTrack_original__ for function " + name_1);
        }
        if (wrapperFunction.__asyncTrack_original__) {
            var name_2 = namePath.join('.');
            this.raiseWarning("wrapperFunction already has __asyncTrack_original__for function " + name_2);
        }
        wrapperFunction.__asyncTrack_original__ = originalFunction;
    };
    AsyncTrack.prototype.asyncTrackInit = function () {
        var self = this;
        function asyncTrackRequire(moduleName) {
            var loadedModule = originalRequire.apply(this, arguments);
            // some top level require(name) returns a
            // function that needs to be instrumented
            if (cbConfig[moduleName] && cbConfig.hasOwnProperty(moduleName)) {
                // some top level require(name) returns a
                // function that needs to be instrumented
                if (cbConfig[moduleName].__returnVal__) {
                    var tmpPkg = {};
                    var tmpConfig = {};
                    tmpPkg[moduleName] = loadedModule;
                    tmpConfig[moduleName] = cbConfig[moduleName];
                    self.instrument(tmpPkg, tmpConfig, []);
                    loadedModule = tmpPkg[moduleName];
                }
                else {
                    self.instrument(loadedModule, cbConfig[moduleName], [moduleName]);
                }
            }
            else if (moduleName === 'bluebird') {
                self.instrumentPromise(loadedModule);
            }
            return loadedModule;
        }
        proxiedModule.prototype.require = asyncTrackRequire;
        AsyncTrack.copyProps(originalRequire, proxiedModule.prototype.require);
        this.stamp(originalRequire, proxiedModule.prototype.require, ['module', 'prototype', 'require']);
        // load/instrument common modules that we want to do up-front
        this.instrumentCommon();
    };
    AsyncTrack.prototype.instrumentCommon = function () {
        // instrument top level APIs that have a callback
        this.instrument(global, cbConfig.__builtIn__, ['global']);
        // process is the global process var.  We update it here. ;)
        process = require('process');
        //
        // TODO:  https://github.com/Glimpse/Glimpse.Node/issues/437
        //
        // Some internal modules need to be loaded explicitly for the proxying to take effect.
        // Figure out why this is.  For some reason, the require override doesn't get
        // hit for these methods.
        //
        require('net');
        require('_http_outgoing');
        require('_http_client');
        this.instrumentPromise(global.Promise);
        this.instrumentEventEmitter();
    };
    AsyncTrack.prototype.instrumentEventEmitter = function () {
        var eventEmitter = proxiedModule.prototype.require('events');
        eventEmitter.prototype.addListener = eventEmitter.prototype.on;
        // removeListener needs to have a custom override since the registered event listener
        // is the proxy method, but the method passed to removeListener is the original method.
        // logic below will find the wrapper associated with the passed in method, and remove
        // and correctly remove it's proxy.
        var save = eventEmitter.prototype.removeListener;
        eventEmitter.prototype.removeListener = function asyncTrackRemoveListener(eventName, listener) {
            // If the same function is registered more than once, then removeListener() will remove the first one.
            // we replicate that logic here.
            if (typeof listener === 'function') {
                var listeners = this.listeners(eventName);
                if (listeners) {
                    for (var i = 0; i < listeners.length; i++) {
                        if (listeners[i].__asyncTrack_original__ && listeners[i].__asyncTrack_original__ === listener) {
                            arguments[1] = listeners[i];
                            break;
                        }
                    }
                }
                return save.apply(this, arguments);
            }
            ;
        };
    };
    AsyncTrack.prototype.getNextAsyncId = function () {
        return ++this.asyncIdCounter;
    };
    /**
     * instrument the callback registration functions according
     * to a configuration data structure
     *
     * @param {Object} pkg an object or function that contains the callback registration functions
     * @param {Object} config the configuration data structure
     * @param {Array} namePath a list that represents the path that has been went through
     * to reach the current registration function (for debugging insepction)
     */
    AsyncTrack.prototype.instrument = function (pkg, config, namePath) {
        if ((!pkg) || (!config)) {
            return pkg;
        }
        namePath = namePath ? namePath : [];
        var queue = [{ pkg: pkg, config: config, path: namePath }];
        while (queue.length > 0) {
            var entity = queue.shift();
            pkg = entity.pkg;
            config = entity.config;
            var curPath = entity.path;
            for (var prop in config) {
                if (config.hasOwnProperty(prop)) {
                    if (prop !== '__returnVal__' && prop !== '__configType__' &&
                        prop !== '__parameter__' && prop !== '__new__') {
                        var newPath = curPath.slice(0);
                        newPath.push(prop);
                        if (config[prop].__configType__ === 'package') {
                            if (!(pkg[prop])) {
                                continue;
                            }
                            queue.push({
                                pkg: pkg[prop],
                                config: config[prop],
                                path: newPath
                            });
                        }
                        else if (config[prop].__configType__ === 'cb_type') {
                            this.wrapSetter(pkg, prop, newPath);
                        }
                        else if (config[prop].__configType__ === 'function-package') {
                            if (!(pkg[prop])) {
                                continue;
                            }
                            pkg[prop] = this.instruCbReg(config, prop, pkg[prop], newPath);
                            queue.push({
                                pkg: pkg[prop],
                                config: config[prop],
                                path: newPath
                            });
                        }
                        else if (!(pkg[prop])) {
                            continue;
                        }
                        else {
                            // instrument the method in the pkg
                            pkg[prop] = this.instruCbReg(config, prop, pkg[prop], newPath);
                        }
                    }
                }
            }
        }
    };
    /**
     * This function wraps the callback function.
     *
     * @param {function} callback the original callback function that needs to be wrapped
     * @param {Object} instrumentCBConfig a configuration data struture telling any
     * preference for instrumenting this callback
     * @returns the wrapped callback
     */
    AsyncTrack.prototype.wrapCallback = function (callback, instrumentCBConfig, asyncId, asyncState, namepath) {
        // tslint:disable-next-line:no-null-keyword
        if (callback === undefined || callback === null) {
            // if undefined or null, then we should just skip any attempts at instrumentation
            // if 0 or false, we'll fail fast on the next line, as that indicates potentially
            // something wrong.
            return;
        }
        if ((typeof callback) !== 'function') {
            this.raiseError("callback " + callback + " is not of type function.  Actual type is " + typeof callback + ".");
        }
        if (callback.__asyncTrack_original__ === callback) {
            // treat this as fatal since we've already instrumented this function
            this.fatalError('callback.__asyncTrack_original__ is === callback!');
        }
        if (callback.__asyncTrack_original__) {
            // treat this as fatal since we're trying to instrument a function twice
            this.fatalError('Instrumenting a function twice!');
        }
        var self = this;
        /**
         * The wrapped callback keeps track of all kinds of information including
         * the callback registration and invocation's stack, time, event id etc.
         * @returns the return value of the original callback function
         */
        var wrappedCb = function wrappedCallback() {
            // need test cases to cover this block
            if (instrumentCBConfig) {
                // instrument the parameter of the callback
                // based on the configuration
                for (var paramIdx in instrumentCBConfig) {
                    if (instrumentCBConfig.hasOwnProperty(paramIdx)) {
                        var paramIdxInt = parseInt(paramIdx, 10);
                        if (arguments[paramIdxInt]) {
                            self.instrument(arguments[paramIdxInt], instrumentCBConfig[paramIdx], []);
                        }
                    }
                }
            }
            var saveAsyncState = self.currentAsyncState;
            var saveAsyncId = self.currentAsyncId;
            var saveAsyncNamePath = self.currentAsyncNamePath;
            if (saveAsyncId !== 0) {
                //console.log('non-zero parent of async ID.  need to investigate this.')
            }
            try {
                self.currentAsyncState = AsyncTrack.mergeState(self.currentAsyncState, asyncState);
                self.currentAsyncId = asyncId;
                self.currentAsyncNamePath = namepath;
                self.raiseBeforeInvocation(asyncId);
                return callback.apply(this, arguments);
            }
            finally {
                self.raiseAfterInvocation(asyncId);
                self.currentAsyncId = 0;
                self.currentAsyncState = saveAsyncState;
                self.currentAsyncId = saveAsyncId;
                self.currentAsyncNamePath = saveAsyncNamePath;
            }
        };
        self.stamp(callback, wrappedCb, namepath);
        return wrappedCb;
    };
    AsyncTrack.prototype.raiseBeforeInvocation = function (id) {
        for (var i = 0; i < this.handlers.length; i++) {
            if (this.handlers[i] && this.handlers[i].onBeforeInvocation) {
                this.handlers[i].onBeforeInvocation(id);
            }
        }
    };
    AsyncTrack.prototype.raiseAfterInvocation = function (id) {
        for (var i = 0; i < this.handlers.length; i++) {
            if (this.handlers[i] && this.handlers[i].onAfterInvocation) {
                this.handlers[i].onAfterInvocation(id);
            }
        }
    };
    AsyncTrack.prototype.raiseAsyncTransition = function (parentId, id) {
        var state = undefined;
        for (var i = 0; i < this.handlers.length; i++) {
            if (this.handlers[i] && this.handlers[i].onAsyncTransition) {
                var result = this.handlers[i].onAsyncTransition(parentId, id);
                if (result) {
                    if (!state) {
                        state = {};
                    }
                    AsyncTrack.copyProps(result, state);
                }
            }
        }
        return state;
    };
    // TODO:  need to test this codepath.
    AsyncTrack.prototype.wrapSetter = function (pkg, prop, namePath) {
        var self = this;
        if (typeof pkg[prop] === 'function') {
            var asyncId = this.getNextAsyncId();
            var asyncState = this.raiseAsyncTransition(this.currentAsyncId, asyncId);
            var wrappedCallback = this.wrapCallback(pkg[prop], undefined, asyncId, asyncState, namePath);
            pkg[prop] = wrappedCallback;
        }
        pkg['__asyncTrack_wrapped_' + prop + '__'] = pkg[prop];
        Object.defineProperty(pkg, prop, {
            set: function setOverride(func) {
                if (typeof func === 'function') {
                    var asyncId2 = self.getNextAsyncId();
                    var asyncState2 = self.raiseAsyncTransition(self.currentAsyncId, asyncId2);
                    this['__asyncTrack_wrapped_' + prop + '__'] = self.wrapCallback(func, undefined, asyncId2, asyncState2, namePath);
                }
                else {
                    this['__asyncTrack_wrapped_' + prop + '__'] = func;
                }
            },
            get: function getOverride() {
                return this['__asyncTrack_wrapped_' + prop + '__'];
            }
        });
    };
    /**
     * instrument the callback registration
     *
     * @param {Object} config the instrumentation configuration data structure
     * that corresponds to this registration function
     * @param {string} prop the registration function's property name in its parent package
     * @param {function} origFunc the callback registration function that needs to be instrumented
     * @param {Object} namePath a sequence of package/function names to reach
     * this registration function from the top level scope
     * @returns the instrumented callback registration function
     */
    AsyncTrack.prototype.instruCbReg = function (config, prop, origFunc, namePath) {
        if (!origFunc) {
            return origFunc;
        }
        var wrapper;
        if (origFunc.__asyncTrack_original__) {
            // this is a wrapper function, return itself
            // TODO: investigate why it is rewrapped
            origFunc = origFunc.__asyncTrack_original__;
        }
        var self = this;
        if (config[prop].__returnVal__ && config[prop].callbackArgIdx && !(config[prop].__new__)) {
            // instrument function whose has a callback and its return
            // value also contains functions that can have callback
            wrapper = function wrapperCallbackInParameterListAndReturn() {
                var asyncId = self.getNextAsyncId();
                var asyncState = self.raiseAsyncTransition(self.currentAsyncId, asyncId);
                self.wrapCallbackInParameterList(config[prop].callbackArgIdx, arguments, config[prop].__parameter__, asyncId, asyncState, namePath);
                var ret = origFunc.apply(this, arguments);
                self.instrument(ret, config[prop].__returnVal__, namePath);
                return ret;
            };
        }
        else if (config[prop].__returnVal__ && !(config[prop].__new__)) {
            // instrument function whose return value
            // contains functions that can have callback
            wrapper = function wrapReturn() {
                // TODO:  do we need to raiseAsyncTransition() here?  don't think so...
                //const asyncState = raiseAsyncTransition();
                var ret = origFunc.apply(this, arguments);
                self.instrument(ret, config[prop].__returnVal__, namePath);
                return ret;
            };
        }
        else if (config[prop].__returnVal__ && config[prop].__new__) {
            // instrument constructor whose return value
            // contains functions that can have callback
            wrapper = function wrapReturnFromConstructor() {
                var args = Array.prototype.slice.call(arguments, 0);
                /* tslint:disable:no-null-keyword */
                args.unshift(null);
                /* tslint:enable:no-null-keyword */
                var ctor = (Function.prototype.bind.apply(origFunc, args));
                // TODO:  do we need to call raiseAsyncTransition() here?  don't think so, but should confirm...
                // const asyncState = raiseAsyncTransition();
                var ret = new ctor();
                self.instrument(ret, config[prop].__returnVal__, namePath);
                return ret;
            };
        }
        else if (config[prop].__clearCallback__) {
            // instrument function that has a callback
            //
            // don't think this is necessary
            //
            // wrapper = function wrapClearCallback() {
            //     var ret = origFunc.apply(this, arguments);
            //     return ret;
            // }
        }
        else {
            wrapper = this.wrapTransition(origFunc, config[prop].callbackArgIdx, config[prop].__parameter__, namePath);
        }
        if (wrapper) {
            this.stamp(origFunc, wrapper, namePath);
        }
        else {
            wrapper = origFunc;
        }
        return wrapper;
    };
    AsyncTrack.prototype.wrapTransition = function (originalFunction, callbackArgIndex, parameterConfig, namePath) {
        var self = this;
        var wrapped = function wrappedTransition() {
            var asyncId = self.getNextAsyncId();
            var asyncState = self.raiseAsyncTransition(self.currentAsyncId, asyncId);
            self.wrapCallbackInParameterList(callbackArgIndex, arguments, parameterConfig, asyncId, asyncState, namePath);
            var ret = originalFunction.apply(this, arguments);
            return ret;
        };
        return wrapped;
    };
    // helper function to copy properties from one object to another
    AsyncTrack.copyProps = function (fromObj, toObj) {
        if (!fromObj || !toObj) {
            return;
        }
        for (var prop in fromObj) {
            if (fromObj.hasOwnProperty(prop) && !toObj.hasOwnProperty(prop)) {
                toObj[prop] = fromObj[prop];
            }
        }
    };
    AsyncTrack.mergeState = function (fromObj, toObj) {
        if (!fromObj) {
            return toObj;
        }
        if (!toObj) {
            return fromObj;
        }
        for (var prop in fromObj) {
            if (fromObj.hasOwnProperty(prop) && !toObj.hasOwnProperty(prop)) {
                toObj[prop] = fromObj[prop];
            }
        }
        return toObj;
    };
    /**
     * wrap the callback function in the parameter list
     *
     * @param {function} instrFunc the current callback register wrapper
     * @param {Object} startIdxList an array that contains the the earliest index
     * or a list of possible indices where the callback is in the parameter list
     * @param {Object} args the parameter list of the callback function
     * @param {Object} paramConfig the configuration for wrapping the parameter
     * list of the callback to be wrapped
     * @param {string} location the callback register's location
     * @param {Object} passInfo the object that will be passed from register to the callback
     */
    AsyncTrack.prototype.wrapCallbackInParameterList = function (startIdxList, args, paramConfig, asyncId, asyncState, namePath) {
        var callbackParIdx;
        if (startIdxList.length === 1) {
            callbackParIdx = startIdxList[0];
            for (var i = 0; i < 4; i++) {
                if ((typeof (args[callbackParIdx])) === 'function') {
                    this.wrapCallbackInParameter(callbackParIdx, args, paramConfig, asyncId, asyncState, namePath);
                    break;
                }
                else {
                    callbackParIdx++;
                }
            }
        }
        else {
            for (var _i = 0, startIdxList_1 = startIdxList; _i < startIdxList_1.length; _i++) {
                callbackParIdx = startIdxList_1[_i];
                if ((typeof (args[callbackParIdx])) === 'function') {
                    this.wrapCallbackInParameter(callbackParIdx, args, paramConfig, asyncId, asyncState, namePath);
                    break;
                }
            }
        }
    };
    AsyncTrack.prototype.wrapCallbackInParameter = function (callbackParIdx, args, paramConfig, asyncId, asyncState, namePath) {
        var callback = args[callbackParIdx];
        if (callback.__asyncTrack_original__) {
            callback = callback.__asyncTrack_original__;
        }
        if (callback.__asyncTrack_original__) {
            this.fatalError('callback is instrumented twice!');
        }
        var wrappedCallback = this.wrapCallback(callback, paramConfig, asyncId, asyncState, namePath);
        if (wrappedCallback) {
            args[callbackParIdx] = wrappedCallback;
        }
    };
    AsyncTrack.prototype.createOnFullfilledWrapper = function (originalThen) {
        var thenNamePath = ['global', 'promise', 'prototype', 'then'];
        var self = this;
        function wrapOnFullfilled(onFulfilled, onRejected) {
            var asyncId = self.getNextAsyncId();
            var asyncState = self.raiseAsyncTransition(self.currentAsyncId, asyncId);
            if (typeof onFulfilled === 'function') {
                self.wrapCallbackInParameter(0, arguments, {}, asyncId, asyncState, thenNamePath);
            }
            if (typeof onRejected === 'function') {
                self.wrapCallbackInParameter(1, arguments, {}, asyncId, asyncState, thenNamePath);
            }
            // other libraries may proxy promises, so we want to be sure that our proxies are always hooked up.
            var ret = originalThen.apply(this, arguments);
            if (!ret.then.__asyncTrack_original__) {
                ret.then = self.createOnFullfilledWrapper(ret.then);
            }
            if (!ret.catch.__asyncTrack_original__) {
                ret.catch = self.createOnRejectedWrapper(ret.catch);
            }
            return ret;
        }
        self.stamp(originalThen, wrapOnFullfilled, thenNamePath);
        return wrapOnFullfilled;
    };
    AsyncTrack.prototype.createOnRejectedWrapper = function (originalCatch) {
        var catchNamePath = ['global', 'promise', 'prototype', 'catch'];
        var self = this;
        function wrapOnRejected() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var asyncId = self.getNextAsyncId();
            var asyncState = self.raiseAsyncTransition(self.currentAsyncId, asyncId);
            // bluebird API allows for "filtered catches", where the first n -1 arguments are constructors
            // or filter functions, and the last argument is the catch handler.  Account for that here.
            var callbackIndex = 0;
            if (args.length > 1 && typeof args[args.length - 1] === 'function') {
                callbackIndex = args.length - 1;
            }
            if (typeof args[callbackIndex] === 'function') {
                self.wrapCallbackInParameter(callbackIndex, arguments, {}, asyncId, asyncState, catchNamePath);
            }
            var ret = originalCatch.apply(this, arguments);
            // other libraries may proxy promises, so we want to be sure that our proxies are always hooked up.
            if (!ret.then.__asyncTrack_original__) {
                ret.then = self.createOnFullfilledWrapper(ret.then);
            }
            if (!ret.catch.__asyncTrack_original__) {
                ret.catch = self.createOnRejectedWrapper(ret.catch);
            }
            return ret;
        }
        self.stamp(originalCatch, wrapOnRejected, catchNamePath);
        return wrapOnRejected;
    };
    /**
     * instrumentation of the Promise function requires special handling
     */
    AsyncTrack.prototype.instrumentPromise = function (promiseObj) {
        var promiseThen = promiseObj.prototype.then;
        var promiseCatch = promiseObj.prototype.catch;
        if (!promiseThen.__asyncTrack_original__) {
            promiseObj.prototype.then = this.createOnFullfilledWrapper(promiseThen);
        }
        if (!promiseCatch.__asyncTrack_original__) {
            promiseObj.prototype.catch = this.createOnRejectedWrapper(promiseCatch);
        }
    };
    return AsyncTrack;
}());

//# sourceMappingURL=../../maps/async-track/async-track.js.map
