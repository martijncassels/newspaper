'use strict';

import * as http from 'http';
import * as https from 'https';
import { printBannerGreeting } from '@glimpse/glimpse-common';

export function setupProxy() {
    // Note: http.createServer and https.createServer have different signatures,
    // so we do each one separately here to keep things simple, even if there is
    // some duplicated code
    const oldHttpCreateServer = http.createServer;
    // tslint:disable-next-line:no-any
    (http as any).createServer = function createServer(...args) {
        let callback;

        if (args.length && typeof args[0] === 'function') {
            callback = args[0];
            args.splice(0, 1);
        }

        // NOTE: The callback is not passed through to the old createServer() (as it's added later).
        const server = oldHttpCreateServer.apply(this, args);

        patchServer(server, callback, 'http');

        return server;
    };

    const oldHttpsCreateServer = https.createServer;
    // tslint:disable-next-line:no-any
    (https as any).createServer = function createServer(options, ...args) {
        let callback;

        if (args.length && typeof args[0] === 'function') {
            callback = args[0];
            args.splice(0, 1);
        }

        // NOTE: The callback is not passed through to the old createServer() (as it's added later).
        const server = oldHttpsCreateServer.call(this, options, ...args);

        patchServer(server, callback, 'https');

        return server;
    };
};

function buildApp() {

    // NOTE: Express provides wrappers around http for starting the web server. If used,
    //       apps may not otherwise import http themselves. In that case, the only mechanism
    //       for importing http (and thereby initializing the Glimpse proxy), is importing
    //       express. Since the server uses Express itself and is initialized before the
    //       agent, it needs to defer importing express until after agent initialization.
    //       This ensures that the first import of Express is done by the app itself and
    //       after all of the proxies have been registered.

    const express = require('express');
    const glimpse = require('../routes/glimpse');

    const app = express();

    app.use((req, res, next) => {
        /* eslint-disable camelcase */
        req.__glimpse_inProcessServerRequest = true;
        res.__glimpse_inProcessServerResponse = true;
        /* eslint-enable camelcase */

        next();
    });

    app.use('/glimpse', glimpse);

    return app;
};

interface IGlimpseListenedIncomingMessage extends http.IncomingMessage {
    __glimpse_originalUrl: string | undefined;
}

function patchServerOn(server, app) {
    const oldOn = server.on;
    server.on = function glimpseServerOn(eventName: string, listener, ...onArgs) {
        if (eventName === 'request') {
            const oldListener = listener;

            listener = (req, res) => {
                const glimpseReq: IGlimpseListenedIncomingMessage = req;

                // Express `request` handlers will alter the `res.url`, so we maintain our own "original" URL...
                if (!glimpseReq.__glimpse_originalUrl) {
                    glimpseReq.__glimpse_originalUrl = glimpseReq.url;
                }

                const isGlimpseEndpoint = glimpseReq.__glimpse_originalUrl.indexOf('/glimpse') === 0;
                const isGlimpseEndpointHandler = oldListener === app;

                // Only invoke the listener:
                //   If it's the Glimpse listener *and* the request is for a Glimpse endpoint.
                //     - or -
                //   If it's not the Glimpse listener *and* the request is for an application (i.e. non-Glimpse) endpoint.
                if ((isGlimpseEndpoint && isGlimpseEndpointHandler) || (!isGlimpseEndpoint && !isGlimpseEndpointHandler)) {
                    return oldListener(req, res);
                }
            };
        }

        return oldOn.call(this, eventName, listener, ...onArgs);
    };
}

function patchServer(server: http.Server, callback, protocol: string) {
    const app = buildApp();

    patchServerOn(server, app);

    server.on('request', app);

    // If specified, attach the callback originally passed to createServer()...
    if (callback) {
        server.on('request', callback);
    }

    server.on('listening', () => {
        printBannerGreeting(`${protocol}://localhost:${server.address().port}/glimpse/client`);
    });
}
