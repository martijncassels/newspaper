{"version":3,"sources":["webpack:///agent.js","webpack:///webpack/bootstrap bce023d40630e2735089","webpack:///./src/Bootstrap.js","webpack:///./src/Agent.ts","webpack:///./src/MessagePublisher.ts","webpack:///./~/nanoajax/index.js","webpack:///./src/common/GeneralUtilities.ts","webpack:///./src/common/RequestUtilities.ts","webpack:///./src/common/MessageMixins.ts","webpack:///./src/inspectors/XHRInspector.ts","webpack:///./src/common/GlimpseLogger.ts","webpack:///./src/common/Constants.ts","webpack:///./src/tracing/proxies/XHRProxy.ts","webpack:///./src/tracing/Tracing.ts","webpack:///./src/common/DateTimeUtilities.ts","webpack:///./~/parse-headers/parse-headers.js","webpack:///./~/trim/index.js","webpack:///./~/for-each/index.js","webpack:///./~/is-function/index.js","webpack:///./src/inspectors/HttpRequestUtils.ts","webpack:///./src/common/CallStackUtilities.ts","webpack:///./~/error-stack-parser/error-stack-parser.js","webpack:///./~/stackframe/stackframe.js","webpack:///./src/inspectors/FetchInspector.ts","webpack:///./src/tracing/proxies/FetchProxy.ts","webpack:///./src/inspectors/ResourceTimingInspector.ts","webpack:///./src/tracing/proxies/ResourceTimingProxy.ts","webpack:///./src/common/PerformanceUtilities.ts","webpack:///./src/inspectors/NavigationTimingInspector.ts","webpack:///./src/tracing/proxies/NavigationTimingProxy.ts","webpack:///./src/inspectors/ConsoleInspector.ts","webpack:///./src/tracing/proxies/ConsoleProxy.ts","webpack:///./src/inspectors/PerformanceInspector.ts","webpack:///./src/tracing/proxies/PerformanceProxy.ts","webpack:///./src/tracing/initializeProxies.ts"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","window","Symbol","_interopRequireDefault","obj","__esModule","default","_MessagePublisher","_XHRInspector","_FetchInspector","_ResourceTimingInspector","_NavigationTimingInspector","_ConsoleInspector","_PerformanceInspector","_initializeProxies","_initializeProxies2","messagePublisher","MessagePublisher","XHRInspector","init","FetchInspector","ResourceTimingInspector","NavigationTimingInspector","ConsoleInspector","PerformanceInspector","_classCallCheck","instance","Constructor","TypeError","chunkMessages","messageBodies","maxSize","ranges","sum","lastStart","i","length","push","start","end","serializeRanges","payloads","subBodies","slice","payload","join","Object","defineProperty","value","undefined","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","_nanoajax","_GeneralUtilities","_RequestUtilities","_MessageMixins","this","ordinal","messageQueue","messageTimeout","type","types","Array","isArray","msg","getGuid","context","getRequestId","agent","source","offset","addOffset","performance","now","message","_this","JSON","stringify","setTimeout","sendData","timeout","publishMessage","createMessage","body","ajax","url","getMessageIngressUrl","method","_this2","maxBodySize","bodies","forEach","sendPayload","global","getRequest","cors","XDomainRequest","test","navigator","userAgent","XMLHttpRequest","setDefault","reqfields","params","callback","cb","statusCode","responseText","called","req","status","response","headers","open","success","onload","onreadystatechange","readyState","onerror","ontimeout","onabort","FormData","field","len","setRequestHeader","send","replace","r","Math","random","v","toString","convertBlobToText","blob","encoding","fileReader","FileReader","onloadend","result","readAsText","document","getElementById","getAttribute","getCookie","addEvent","element","eventName","addEventListener","attachEvent","cookie","regexp","RegExp","getHeaderKeys","headerKeys","keys","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","iterator","next","done","header","err","name","normalizeHeaders","normalizedHeaders","hasOwnProperty","headerVal","toLowerCase","parseUrl","parser","createElement","href","parsedPort","parseInt","port","protocol","hostname","isNaN","pathname","search","hash","stringifyUrl","portSuffix","stringifiedUrl","resolveUrl","urlCache","envelope","addCorrelationBegin","correlationId","addCorrelation","addCorrelationEnd","duration","_typeof","constructor","_GlimpseLogger","_GlimpseLogger2","_Constants","_XHRProxy","_Tracing","_Tracing2","_DateTimeUtilities","_parseHeaders","_parseHeaders2","_HttpRequestUtils","_CallStackUtilities","initiatorRegExp","requests","contentType","boundary","getMultiPartFormBoundary","_bodyProperty","size","isTruncated","MAX_HTTP_BODY_SIZE","parts","getMultiPartFormParts","content","Blob","_contentType","createBodyForBlob","bodyProperty","ArrayBuffer","buffer","_bodyProperty2","byteLength","Document","_bodyProperty3","createEmptyBody","_bodyProperty4","_bodyProperty5","_bodyProperty6","event","eventData","data","getStackTrace","frames","createBodyProperty","startTime","getDateTime","Date","timeStamp","identifier","timing","isAjax","requestEntry","tryFindResourceTimingObject","startTimeOffset","timings","responseStart","responseEnd","xhr","getAllResponseHeaders","statusMessage","endTime","_this3","on","EVENT_XHR_REQUEST_SENT","startTimeStamp","before","EVENT_XHR_RESPONSE_RECEIVED","after","error","EVENT_XHR_ERROR","EVENT_XHR_ABORT","GlimpseLogger","logToConsole","console","logger","XHRProxy","handleAsyncRequest","requestHeaders","oldXMLHttpRequest","DONE","statusText","bodyType","responseType","publish","oldSend","_len","arguments","sendArgs","_key","apply","concat","oldSetRequestHeader","_len2","setRequestHeaderArgs","_key2","handleSyncRequest","_len3","_key3","requestEventData","_len4","_key4","e","errorEventData","responseEventData","oldOpen","async","_len5","openArgs","_key5","isInitialized","prop","Tracing","listeners","emitted","listener","splice","toTwoDigits","toThreeDigits","getUTCOffset","date","getTimezoneOffset","sign","abs","hours","floor","minutes","d","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","trim","arg","split","row","index","indexOf","str","left","right","list","isFunction","forEachArray","forEachString","forEachObject","array","string","charAt","object","k","fn","alert","confirm","prompt","getEncodingForBlob","UTF8_ENCODING_MIME_TYPES","mimeType","contentTypeHeader","includeParts","bodyMessage","convertRawHeaders","rawHeaders","h","lines","l","idx","substring","matches","MULTIPART_FORMDATA_REG_EX","exec","firstBoundaryRegExString","firstBoundaryRegEx","partRegExString","partRegEx","firstBoundary","partSummaries","lastIndex","part","headerSectionLength","bodyStartIndex","convertedHeaders","bodySectionLength","bodyEndIndex","bodyLength","requestId","initiatorType","expectedStart","tryGet","computeDelta","p2","entries","getEntriesByType","candidates","curr","__glimpse_requestId","sort","a","b","deltaA","deltaB","delay","maxDelay","_interopRequireWildcard","newObj","getError","Error","stack","e2","stackFrames","ErrorStackParser","parse","fileName","endsWith","newFrames","val","functionName","lineNumber","columnNumber","_errorStackParser","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","root","factory","StackFrame","FIREFOX_SAFARI_STACK_REGEXP","CHROME_IE_STACK_REGEXP","SAFARI_NATIVE_CODE_REGEXP","stacktrace","parseOpera","match","parseV8OrIE","parseFFOrSafari","extractLocation","urlLike","regExp","filtered","filter","line","map","tokens","locationParts","pop","parseOpera9","parseOpera11","parseOpera10","lineRE","argsRaw","functionCall","shift","args","_isNumber","n","parseFloat","isFinite","_capitalize","toUpperCase","_getter","booleanProps","numericProps","stringProps","arrayProps","getArgs","setArgs","getEvalOrigin","evalOrigin","setEvalOrigin","getFunctionName","getFileName","getLineNumber","getColumnNumber","Boolean","j","Number","String","_FetchProxy","initiatorRexExp","parsedHeaders","get","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","request","createHeaders","then","getContentTypeHeader","reason","responseEndOffset","EVENT_FETCH_REQUEST_SENT","EVENT_FETCH_RESPONSE_RECEIVED","EVENT_FETCH_ERROR","FetchProxy","self","fetch","oldFetch","input","Request","clone","requestSentEventData","fetchPromise","responseReceivedEventData","_ResourceTimingProxy","EVENT_RESOURCE_TIMING_COLLECTED","createAndPublishMessage","ResourceTimingProxy","_PerformanceUtilities","_PerformanceUtilities2","UPDATE_INTERVAL","processEntry","entry","nextHopProtocol","redirectStart","redirectEnd","fetchStart","domainLookupStart","domainLookupEnd","connectStart","connectEnd","secureConnectionStart","requestStart","transferSize","encodedBodySize","decodedBodySize","record","resources","entriesToPublish","ingressUrl","resource","reportedEntries","getPerformance","webkitPerformance","msPerformance","mozPerformance","_NavigationTimingProxy","EVENT_NAVIGATION_TIMING_COLLECTED","assign","loadDuration","loadEventEnd","domReadyDuration","domComplete","domInteractive","readyStartDuration","navigationStart","redirectDuration","appcacheDuration","unloadEventDuration","unloadEventEnd","unloadEventStart","lookupDomainDuration","connectDuration","requestDuration","initDomTreeDuration","loadEventDuration","loadEventStart","networkRequestDuration","networkResponseDuration","serverDuration","browserDuration","totalDuration","networkDuration","NavigationTimingProxy","processTimings","domContentLoadedEventEnd","domContentLoadedEventStart","domLoading","firstPaint","firstPaintDuration","chrome","loadTimes","firstPaintTime","startLoadTime","msFirstPaint","LogMessageTypes","_ConsoleProxy","countMap","group","profile","time","mapNull","methods","assert","level","processor","count","tokenTypeByPass","debug","nullByPass","dir","json","dirxml","xml","groupStart","groupCollapsed","groupEnd","info","log","profileStart","profileEnd","table","applyType","mapStart","timespan_begin","timeEnd","mapEnd","timespan_end","trace","warn","NOTIFY_CONSOLE_EVENT_OCCURED","library","suppressMessage","deriveTokenType","label","currentCount","assertion","newArgs","processAsDir","getElementsByTagName","nodeCount","outerHTML","getAndApplyLabel","isCollapsed","stackStart","group_begin","stackEnd","group_end","mixin","coreStart","coreEnd","tokenSupport","ConsoleProxy","__glimpse_enabled","methodKey","__glimpse_original","oldFunction","newFunction","__glimpse_proxy","_PerformanceProxy","markIdCache","EVENT_PERFORMANCE_MARK","mark","EVENT_PERFORMANCE_MEASURE","measure","isBuiltIn","startMarkMessageId","startMarkId","endMarkMessageId","endMarkId","correlationMessageIds","category","PerformanceProxy","measureIdCount","tempMeasureName","oldMeasure","tempMeasureEntry","getPerformanceEntryByName","initializeMark","clearMeasures","getEntriesByName","oldMark","performanceEntry","startMark","endMark","_self$oldMeasure","getMarkId","instrumentMark","instrumentMeasure","initializeProxies","proxyName","proxies","proxy","isSupported"],"mappings":"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","file":"agent.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tif (window.Symbol) {\n\t    __webpack_require__(1);\n\t}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _MessagePublisher = __webpack_require__(2);\n\t\n\tvar _XHRInspector = __webpack_require__(7);\n\t\n\tvar _FetchInspector = __webpack_require__(21);\n\t\n\tvar _ResourceTimingInspector = __webpack_require__(23);\n\t\n\tvar _NavigationTimingInspector = __webpack_require__(26);\n\t\n\tvar _ConsoleInspector = __webpack_require__(28);\n\t\n\tvar _PerformanceInspector = __webpack_require__(30);\n\t\n\tvar _initializeProxies = __webpack_require__(32);\n\t\n\tvar _initializeProxies2 = _interopRequireDefault(_initializeProxies);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar messagePublisher = new _MessagePublisher.MessagePublisher();\n\t// We initialize the inspectors before the proxies so that they are wired up and\n\t// ready to receive events from proxies in case a proxy wants to emit an event\n\t// in its `init` method (the Resource Timing proxy does this).\n\tnew _XHRInspector.XHRInspector().init(messagePublisher);\n\tnew _FetchInspector.FetchInspector().init(messagePublisher);\n\tnew _ResourceTimingInspector.ResourceTimingInspector().init(messagePublisher);\n\tnew _NavigationTimingInspector.NavigationTimingInspector().init(messagePublisher);\n\tnew _ConsoleInspector.ConsoleInspector().init(messagePublisher);\n\tnew _PerformanceInspector.PerformanceInspector().init(messagePublisher);\n\t(0, _initializeProxies2['default'])();\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.MessagePublisher = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\texports.chunkMessages = chunkMessages;\n\texports.serializeRanges = serializeRanges;\n\t\n\tvar _nanoajax = __webpack_require__(3);\n\t\n\tvar _GeneralUtilities = __webpack_require__(4);\n\t\n\tvar _RequestUtilities = __webpack_require__(5);\n\t\n\tvar _MessageMixins = __webpack_require__(6);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * break a list of messages into group so that the groups are under maxSize.\n\t * If any individual message is over maxSize, it will be grouped on its own.\n\t * returns an of IRange instances, where start is inclusive & end is exclusive.\n\t *\n\t * Exported for test purposes.\n\t */\n\tfunction chunkMessages(messageBodies, maxSize) {\n\t    var ranges = [];\n\t    var sum = 0;\n\t    var lastStart = 0;\n\t    for (var i = 0; i < messageBodies.length; i++) {\n\t        sum += messageBodies[i].length;\n\t        if (messageBodies[i].length > maxSize) {\n\t            if (lastStart !== i) {\n\t                // when a single message is over the limit, we want to send previous messages in their own batch\n\t                ranges.push({ start: lastStart, end: i });\n\t            }\n\t            ranges.push({ start: i, end: i + 1 });\n\t            lastStart = i + 1;\n\t            sum = 0;\n\t        } else if (sum > maxSize) {\n\t            ranges.push({ start: lastStart, end: i });\n\t            lastStart = i;\n\t            sum = messageBodies[i].length;\n\t        }\n\t    }\n\t    if (lastStart < messageBodies.length) {\n\t        ranges.push({ start: lastStart, end: messageBodies.length });\n\t    }\n\t    return ranges;\n\t}\n\t/**\n\t * given an array of serialized message bodies & array of ranges,\n\t * break them into JSON-serialized sub-arrays as defined by the ranges.\n\t *\n\t * Exported for test purposes.\n\t */\n\tfunction serializeRanges(messageBodies, ranges) {\n\t    var payloads = [];\n\t    for (var i = 0; i < ranges.length; i++) {\n\t        if (ranges[i].end > ranges[i].start) {\n\t            var subBodies = messageBodies.slice(ranges[i].start, ranges[i].end);\n\t            var payload = '[' + subBodies.join(',') + ']';\n\t            payloads.push(payload);\n\t        }\n\t    }\n\t    return payloads;\n\t}\n\t\n\tvar MessagePublisher = exports.MessagePublisher = function () {\n\t    function MessagePublisher() {\n\t        _classCallCheck(this, MessagePublisher);\n\t\n\t        this.ordinal = 1;\n\t        this.messageQueue = [];\n\t        this.messageTimeout = undefined;\n\t    }\n\t\n\t    _createClass(MessagePublisher, [{\n\t        key: 'createMessage',\n\t        value: function createMessage(type, payload) {\n\t            var types = Array.isArray(type) ? type : [type];\n\t            var msg = {\n\t                id: (0, _GeneralUtilities.getGuid)(),\n\t                types: types,\n\t                payload: payload,\n\t                context: {\n\t                    id: (0, _RequestUtilities.getRequestId)(),\n\t                    type: 'Request'\n\t                },\n\t                ordinal: this.ordinal++,\n\t                agent: {\n\t                    source: 'browser'\n\t                },\n\t                offset: 0\n\t            };\n\t            (0, _MessageMixins.addOffset)(performance.now(), msg);\n\t            return msg;\n\t        }\n\t    }, {\n\t        key: 'publishMessage',\n\t        value: function publishMessage(message) {\n\t            var _this = this;\n\t\n\t            // finish getting message ready for sending\n\t            message.payload = JSON.stringify(message); // tslint:disable-line:no-string-literal\n\t            // add messages to queu\n\t            this.messageQueue.push(message);\n\t            // only setup the timeout if we need to\n\t            if (!this.messageTimeout) {\n\t                this.messageTimeout = setTimeout(function () {\n\t                    _this.messageTimeout = undefined;\n\t                    _this.sendData();\n\t                }, MessagePublisher.timeout);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'createAndPublishMessage',\n\t        value: function createAndPublishMessage(type, payload) {\n\t            this.publishMessage(this.createMessage(type, payload));\n\t        }\n\t    }, {\n\t        key: 'sendPayload',\n\t        value: function sendPayload(body) {\n\t            // send data with all the data that we have batched up\n\t            (0, _nanoajax.ajax)({\n\t                url: (0, _RequestUtilities.getMessageIngressUrl)(),\n\t                method: 'POST',\n\t                body: body\n\t            }, function () {\n\t                // not doing anything atm\n\t            });\n\t        }\n\t    }, {\n\t        key: 'sendData',\n\t        value: function sendData() {\n\t            var _this2 = this;\n\t\n\t            // we'll chunk the pooled messages into individual requests to try stay under\n\t            // some size limit for http payloads.\n\t            var maxBodySize = 100000;\n\t            var bodies = [];\n\t            this.messageQueue.forEach(function (m) {\n\t                bodies.push(JSON.stringify(m));\n\t            });\n\t            var ranges = chunkMessages(bodies, maxBodySize);\n\t            var payloads = serializeRanges(bodies, ranges);\n\t            payloads.forEach(function (payload) {\n\t                _this2.sendPayload(payload);\n\t            });\n\t            this.messageQueue = [];\n\t        }\n\t    }]);\n\t\n\t    return MessagePublisher;\n\t}();\n\t\n\tMessagePublisher.timeout = 250;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {// Best place to find information on XHR features is:\n\t// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\n\t\n\tvar reqfields = [\n\t  'responseType', 'withCredentials', 'timeout', 'onprogress'\n\t]\n\t\n\t// Simple and small ajax function\n\t// Takes a parameters object and a callback function\n\t// Parameters:\n\t//  - url: string, required\n\t//  - headers: object of `{header_name: header_value, ...}`\n\t//  - body:\n\t//      + string (sets content type to 'application/x-www-form-urlencoded' if not set in headers)\n\t//      + FormData (doesn't set content type so that browser will set as appropriate)\n\t//  - method: 'GET', 'POST', etc. Defaults to 'GET' or 'POST' based on body\n\t//  - cors: If your using cross-origin, you will need this true for IE8-9\n\t//\n\t// The following parameters are passed onto the xhr object.\n\t// IMPORTANT NOTE: The caller is responsible for compatibility checking.\n\t//  - responseType: string, various compatability, see xhr docs for enum options\n\t//  - withCredentials: boolean, IE10+, CORS only\n\t//  - timeout: long, ms timeout, IE8+\n\t//  - onprogress: callback, IE10+\n\t//\n\t// Callback function prototype:\n\t//  - statusCode from request\n\t//  - response\n\t//    + if responseType set and supported by browser, this is an object of some type (see docs)\n\t//    + otherwise if request completed, this is the string text of the response\n\t//    + if request is aborted, this is \"Abort\"\n\t//    + if request times out, this is \"Timeout\"\n\t//    + if request errors before completing (probably a CORS issue), this is \"Error\"\n\t//  - request object\n\t//\n\t// Returns the request object. So you can call .abort() or other methods\n\t//\n\t// DEPRECATIONS:\n\t//  - Passing a string instead of the params object has been removed!\n\t//\n\texports.ajax = function (params, callback) {\n\t  // Any variable used more than once is var'd here because\n\t  // minification will munge the variables whereas it can't munge\n\t  // the object access.\n\t  var headers = params.headers || {}\n\t    , body = params.body\n\t    , method = params.method || (body ? 'POST' : 'GET')\n\t    , called = false\n\t\n\t  var req = getRequest(params.cors)\n\t\n\t  function cb(statusCode, responseText) {\n\t    return function () {\n\t      if (!called) {\n\t        callback(req.status === undefined ? statusCode : req.status,\n\t                 req.status === 0 ? \"Error\" : (req.response || req.responseText || responseText),\n\t                 req)\n\t        called = true\n\t      }\n\t    }\n\t  }\n\t\n\t  req.open(method, params.url, true)\n\t\n\t  var success = req.onload = cb(200)\n\t  req.onreadystatechange = function () {\n\t    if (req.readyState === 4) success()\n\t  }\n\t  req.onerror = cb(null, 'Error')\n\t  req.ontimeout = cb(null, 'Timeout')\n\t  req.onabort = cb(null, 'Abort')\n\t\n\t  if (body) {\n\t    setDefault(headers, 'X-Requested-With', 'XMLHttpRequest')\n\t\n\t    if (!global.FormData || !(body instanceof global.FormData)) {\n\t      setDefault(headers, 'Content-Type', 'application/x-www-form-urlencoded')\n\t    }\n\t  }\n\t\n\t  for (var i = 0, len = reqfields.length, field; i < len; i++) {\n\t    field = reqfields[i]\n\t    if (params[field] !== undefined)\n\t      req[field] = params[field]\n\t  }\n\t\n\t  for (var field in headers)\n\t    req.setRequestHeader(field, headers[field])\n\t\n\t  req.send(body)\n\t\n\t  return req\n\t}\n\t\n\tfunction getRequest(cors) {\n\t  // XDomainRequest is only way to do CORS in IE 8 and 9\n\t  // But XDomainRequest isn't standards-compatible\n\t  // Notably, it doesn't allow cookies to be sent or set by servers\n\t  // IE 10+ is standards-compatible in its XMLHttpRequest\n\t  // but IE 10 can still have an XDomainRequest object, so we don't want to use it\n\t  if (cors && global.XDomainRequest && !/MSIE 1/.test(navigator.userAgent))\n\t    return new XDomainRequest\n\t  if (global.XMLHttpRequest)\n\t    return new XMLHttpRequest\n\t}\n\t\n\tfunction setDefault(obj, key, value) {\n\t  obj[key] = obj[key] || value\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.getGuid = getGuid;\n\texports.convertBlobToText = convertBlobToText;\n\tfunction getGuid() {\n\t    return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n\t        /* tslint:disable:no-bitwise */\n\t        var r = Math.random() * 16 | 0,\n\t            v = c === 'x' ? r : r & 0x3 | 0x8;\n\t        /* tslint:enable:no-bitwise */\n\t        return v.toString(16);\n\t    });\n\t}\n\tfunction convertBlobToText(blob, encoding, cb) {\n\t    var fileReader = new FileReader();\n\t    fileReader.onloadend = function () {\n\t        cb(fileReader.result);\n\t    };\n\t    fileReader.readAsText(blob, encoding);\n\t}\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.getRequestId = getRequestId;\n\texports.addEvent = addEvent;\n\texports.getCookie = getCookie;\n\texports.getHeaderKeys = getHeaderKeys;\n\texports.normalizeHeaders = normalizeHeaders;\n\texports.getMessageIngressUrl = getMessageIngressUrl;\n\texports.parseUrl = parseUrl;\n\texports.stringifyUrl = stringifyUrl;\n\texports.resolveUrl = resolveUrl;\n\t\n\tvar _GeneralUtilities = __webpack_require__(4);\n\t\n\tfunction getRequestId() {\n\t    // NOTE: agent should look to see if it can get the id\n\t    //       from a script tag first, then if it can't find\n\t    //       it there look to for a cookie (in the case where\n\t    //       we can't inject a script tag) and finally it will\n\t    //       create one which will be used moving forward\n\t    //       (CDN scenario).\n\t    var id = document.getElementById('__glimpse_browser_agent').getAttribute('data-request-id');\n\t    if (!id) {\n\t        id = getCookie('.Glimpse.RequestId');\n\t    }\n\t    if (!id) {\n\t        id = (0, _GeneralUtilities.getGuid)();\n\t    }\n\t    return id;\n\t}\n\tfunction addEvent(element, eventName, cb) {\n\t    if (element.addEventListener) {\n\t        element.addEventListener(eventName, cb, false);\n\t    } else if (element.attachEvent) {\n\t        element.attachEvent('on' + eventName, cb);\n\t    }\n\t}\n\tfunction getCookie(cookie) {\n\t    // Modified from https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie\n\t    var regexp = new RegExp('(?:(?:^|.*;\\\\s*)' + cookie + '\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$');\n\t    return document.cookie.replace(regexp, '$1');\n\t}\n\tfunction getHeaderKeys(headers) {\n\t    var headerKeys = [];\n\t    // tslint:disable-next-line:no-any\n\t    if (headers.keys) {\n\t        // tslint:disable-next-line:no-any\n\t        var _iteratorNormalCompletion = true;\n\t        var _didIteratorError = false;\n\t        var _iteratorError = undefined;\n\t\n\t        try {\n\t            for (var _iterator = headers.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t                var header = _step.value;\n\t\n\t                headerKeys.push(header);\n\t            }\n\t        } catch (err) {\n\t            _didIteratorError = true;\n\t            _iteratorError = err;\n\t        } finally {\n\t            try {\n\t                if (!_iteratorNormalCompletion && _iterator['return']) {\n\t                    _iterator['return']();\n\t                }\n\t            } finally {\n\t                if (_didIteratorError) {\n\t                    throw _iteratorError;\n\t                }\n\t            }\n\t        }\n\t    } else if (headers.forEach) {\n\t        headers.forEach(function (value, name) {\n\t            return headerKeys.push(name);\n\t        });\n\t    }\n\t    return headerKeys;\n\t}\n\t// Headers are not technically case sensitive, and the browser often normalizes\n\t// header so that they are all lower case and all strings. This method does the\n\t// same so that headers are always normalized from the browser agent in all cases.\n\tfunction normalizeHeaders(headers) {\n\t    var normalizedHeaders = {};\n\t    for (var header in headers) {\n\t        if (!headers.hasOwnProperty(header)) {\n\t            continue;\n\t        }\n\t        var headerVal = headers[header];\n\t        // tslint:disable-next-line:no-null-keyword\n\t        if (headerVal !== undefined && headerVal !== null && typeof headerVal !== 'string') {\n\t            headerVal = headerVal.toString();\n\t        }\n\t        normalizedHeaders[header.toLowerCase()] = headerVal;\n\t    }\n\t    return normalizedHeaders;\n\t}\n\tfunction getMessageIngressUrl() {\n\t    return document.getElementById('__glimpse_browser_agent').getAttribute('data-message-ingress-template');\n\t}\n\tfunction parseUrl(url) {\n\t    var parser = document.createElement('a');\n\t    parser.href = url;\n\t    var parsedPort = parseInt(parser.port, 10);\n\t    return {\n\t        protocol: parser.protocol,\n\t        hostname: parser.hostname,\n\t        port: isNaN(parsedPort) ? undefined : parsedPort,\n\t        pathname: parser.pathname,\n\t        search: parser.search,\n\t        hash: parser.hash\n\t    };\n\t}\n\tfunction stringifyUrl(url) {\n\t    var portSuffix = url.port !== undefined ? ':' + url.port : '';\n\t    var stringifiedUrl = url.protocol + '//' + url.hostname + portSuffix + url.pathname;\n\t    if (url.search) {\n\t        stringifiedUrl += url.search;\n\t    }\n\t    if (url.hash) {\n\t        stringifiedUrl += url.hash;\n\t    }\n\t    return stringifiedUrl;\n\t}\n\tvar urlCache = {};\n\tfunction resolveUrl(url) {\n\t    if (urlCache[url]) {\n\t        return urlCache[url];\n\t    }\n\t    return urlCache[url] = stringifyUrl(parseUrl(url));\n\t}\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.addOffset = addOffset;\n\texports.addCorrelationBegin = addCorrelationBegin;\n\texports.addCorrelationEnd = addCorrelationEnd;\n\texports.addCorrelation = addCorrelation;\n\tfunction addOffset(offset, envelope) {\n\t    envelope.offset = offset;\n\t}\n\tfunction addCorrelationBegin(correlationId, envelope) {\n\t    envelope.types.push('correlation-begin');\n\t    addCorrelation(correlationId, envelope);\n\t}\n\tfunction addCorrelationEnd(correlationId, duration, envelope) {\n\t    envelope.types.push('correlation-end');\n\t    envelope.payload.duration = duration;\n\t    addCorrelation(correlationId, envelope);\n\t}\n\tfunction addCorrelation(correlationId, envelope) {\n\t    envelope.types.push('correlation');\n\t    envelope.payload.correlationId = correlationId;\n\t}\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.XHRInspector = undefined;\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _GlimpseLogger = __webpack_require__(8);\n\t\n\tvar _GlimpseLogger2 = _interopRequireDefault(_GlimpseLogger);\n\t\n\tvar _MessageMixins = __webpack_require__(6);\n\t\n\tvar _Constants = __webpack_require__(9);\n\t\n\tvar _XHRProxy = __webpack_require__(10);\n\t\n\tvar _Tracing = __webpack_require__(11);\n\t\n\tvar _Tracing2 = _interopRequireDefault(_Tracing);\n\t\n\tvar _DateTimeUtilities = __webpack_require__(12);\n\t\n\tvar _RequestUtilities = __webpack_require__(5);\n\t\n\tvar _parseHeaders = __webpack_require__(13);\n\t\n\tvar _parseHeaders2 = _interopRequireDefault(_parseHeaders);\n\t\n\tvar _HttpRequestUtils = __webpack_require__(17);\n\t\n\tvar _CallStackUtilities = __webpack_require__(18);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar XHRInspector = exports.XHRInspector = function () {\n\t    function XHRInspector() {\n\t        _classCallCheck(this, XHRInspector);\n\t\n\t        this.initiatorRegExp = /xmlhttprequest/i;\n\t        this.requests = {};\n\t    }\n\t\n\t    _createClass(XHRInspector, [{\n\t        key: 'createBodyProperty',\n\t        value: function createBodyProperty(headers, body, cb) {\n\t            //\n\t            // Note on use of setTimeout() below.  This is done to ensure all code paths execute asynchronously,\n\t            // irrespective of whether createBodyForBlob is called.  For a more in-depth discussion,\n\t            // see https://nodejs.org/dist/latest-v7.x/docs/api/process.html#process_process_nexttick_callback_args\n\t            //\n\t            if (!body) {\n\t                var bodyProperty = (0, _HttpRequestUtils.createEmptyBody)(false);\n\t                setTimeout(function () {\n\t                    return cb(bodyProperty);\n\t                }, 0);\n\t            } else {\n\t                //\n\t                // according to MDN docs, body here can be one of the following types:\n\t                // ArrayBufferView | Blob | Document | string | FormData.  We need to\n\t                // account for all of these.\n\t                //\n\t                if (typeof body === 'string') {\n\t                    var contentType = headers['content-type'];\n\t                    var boundary = (0, _HttpRequestUtils.getMultiPartFormBoundary)(contentType);\n\t                    var _bodyProperty = {\n\t                        size: body.length,\n\t                        encoding: 'utf8',\n\t                        isTruncated: body.length > _Constants.MAX_HTTP_BODY_SIZE,\n\t                        parts: (0, _HttpRequestUtils.getMultiPartFormParts)(boundary, body),\n\t                        content: body.slice(0, _Constants.MAX_HTTP_BODY_SIZE)\n\t                    };\n\t                    setTimeout(function () {\n\t                        return cb(_bodyProperty);\n\t                    }, 0);\n\t                } else if (body instanceof Blob) {\n\t                    var _contentType = headers['content-type'];\n\t                    var blob = body;\n\t                    (0, _HttpRequestUtils.createBodyForBlob)(_contentType, blob, true, function (bodyProperty) {\n\t                        cb(bodyProperty);\n\t                    });\n\t                } else if (body instanceof ArrayBuffer || body.buffer && body.buffer instanceof ArrayBuffer) {\n\t                    var buffer = void 0;\n\t                    if (body instanceof ArrayBuffer) {\n\t                        buffer = body;\n\t                    } else {\n\t                        buffer = body.buffer;\n\t                    }\n\t                    // TODO:  support body capture when body is ArrayBuffer\n\t                    var _bodyProperty2 = {\n\t                        size: buffer.byteLength,\n\t                        encoding: 'none',\n\t                        isTruncated: true,\n\t                        parts: [],\n\t                        content: ''\n\t                    };\n\t                    setTimeout(function () {\n\t                        return cb(_bodyProperty2);\n\t                    }, 0);\n\t                } else if (body instanceof Document) {\n\t                    // TODO:  support body capture when body is Document\n\t                    var doc = body;\n\t                    var _bodyProperty3 = (0, _HttpRequestUtils.createEmptyBody)(true);\n\t                    setTimeout(function () {\n\t                        return cb(_bodyProperty3);\n\t                    }, 0);\n\t                } else if (body instanceof FormData) {\n\t                    // TODO:  support body capture when body is FormData\n\t                    var fd = body;\n\t                    var _bodyProperty4 = (0, _HttpRequestUtils.createEmptyBody)(true);\n\t                    setTimeout(function () {\n\t                        return cb(_bodyProperty4);\n\t                    }, 0);\n\t                } else if ((typeof body === 'undefined' ? 'undefined' : _typeof(body)) === 'object') {\n\t                    // TODO:  support body capture when body is object\n\t                    var _bodyProperty5 = (0, _HttpRequestUtils.createEmptyBody)(true);\n\t                    setTimeout(function () {\n\t                        return cb(_bodyProperty5);\n\t                    }, 0);\n\t                } else {\n\t                    var _bodyProperty6 = (0, _HttpRequestUtils.createEmptyBody)(true);\n\t                    setTimeout(function () {\n\t                        return cb(_bodyProperty6);\n\t                    }, 0);\n\t                }\n\t            }\n\t        }\n\t    }, {\n\t        key: 'before',\n\t        value: function before(event) {\n\t            var _this = this;\n\t\n\t            var eventData = event.data;\n\t            var url = (0, _RequestUtilities.parseUrl)(eventData.url);\n\t            var headers = (0, _RequestUtilities.normalizeHeaders)(eventData.headers);\n\t            (0, _CallStackUtilities.getStackTrace)(function (frames) {\n\t                _this.createBodyProperty(headers, eventData.body, function (body) {\n\t                    var startTime = (0, _DateTimeUtilities.getDateTime)(new Date(event.timeStamp));\n\t                    var msg = _this.messagePublisher.createMessage(['data-http-request', 'call-stack'], {\n\t                        correlationId: eventData.id,\n\t                        protocol: {\n\t                            identifier: url.protocol.replace(/\\:$/, '').toLowerCase()\n\t                        },\n\t                        url: eventData.url,\n\t                        method: eventData.method,\n\t                        startTime: startTime,\n\t                        timing: {\n\t                            startTime: 0\n\t                        },\n\t                        headers: headers,\n\t                        isAjax: true,\n\t                        body: body,\n\t                        frames: frames.slice(0, 1)\n\t                    });\n\t                    (0, _MessageMixins.addOffset)(event.offset, msg);\n\t                    _this.messagePublisher.publishMessage(msg);\n\t                });\n\t            });\n\t        }\n\t    }, {\n\t        key: 'after',\n\t        value: function after(event, requestEntry) {\n\t            var _this2 = this;\n\t\n\t            var eventData = event.data;\n\t            (0, _HttpRequestUtils.tryFindResourceTimingObject)(event.data.id, this.initiatorRegExp, eventData.url, requestEntry.startTimeOffset, function (timings) {\n\t                var offset = timings ? timings.startTime : requestEntry.startTimeOffset;\n\t                // start here is relative to this http client request, so it is always 0\n\t                var startTime = 0;\n\t                // leave responseStart undefined if no timings instance since this is optional and we don't know accurate value\n\t                var responseStart = timings && timings.responseStart >= timings.startTime ? timings.responseStart - timings.startTime : undefined;\n\t                var responseEnd = timings ? timings.responseEnd - timings.startTime : event.offset - requestEntry.startTimeOffset;\n\t                var headers = (0, _parseHeaders2['default'])(eventData.xhr.getAllResponseHeaders());\n\t                // TODO: https://github.com/Glimpse/Glimpse.Node.Prototype/issues/307\n\t                // Add support for base64 encoding non-text content by setting the encoding here\n\t                _this2.createBodyProperty(headers, eventData.body, function (body) {\n\t                    var msg = _this2.messagePublisher.createMessage('data-http-response', {\n\t                        correlationId: eventData.id,\n\t                        url: eventData.url,\n\t                        headers: headers,\n\t                        statusCode: eventData.statusCode,\n\t                        statusMessage: eventData.statusMessage,\n\t                        endTime: (0, _DateTimeUtilities.getDateTime)(new Date(event.timeStamp)),\n\t                        duration: responseEnd,\n\t                        timing: {\n\t                            startTime: 0,\n\t                            responseEnd: responseEnd\n\t                        },\n\t                        body: body\n\t                    });\n\t                    if (responseStart !== undefined) {\n\t                        msg.payload.timing.responseStart = responseStart;\n\t                    }\n\t                    (0, _MessageMixins.addOffset)(offset, msg);\n\t                    _this2.messagePublisher.publishMessage(msg);\n\t                });\n\t            });\n\t        }\n\t    }, {\n\t        key: 'numOutstandingRequests',\n\t        value: function numOutstandingRequests() {\n\t            return Object.keys(this.requests).length;\n\t        }\n\t    }, {\n\t        key: 'init',\n\t        value: function init(messagePublisher) {\n\t            var _this3 = this;\n\t\n\t            this.messagePublisher = messagePublisher;\n\t            _Tracing2['default'].on(_XHRProxy.EVENT_XHR_REQUEST_SENT, function (event) {\n\t                _this3.requests[event.data.id] = {\n\t                    startTimeStamp: event.timeStamp,\n\t                    startTimeOffset: event.offset\n\t                };\n\t                _this3.before(event);\n\t            });\n\t            _Tracing2['default'].on(_XHRProxy.EVENT_XHR_RESPONSE_RECEIVED, function (event) {\n\t                var requestEntry = _this3.requests[event.data.id];\n\t                if (!requestEntry) {\n\t                    _GlimpseLogger2['default'].error('Glimpse Internal Error: could not find associated master data, some inspection data will be lost.');\n\t                    return;\n\t                }\n\t                _this3.after(event, requestEntry);\n\t                delete _this3.requests[event.data.id];\n\t            });\n\t            _Tracing2['default'].on(_XHRProxy.EVENT_XHR_ERROR, function (data) {\n\t                delete _this3.requests[data.data.id];\n\t            });\n\t            _Tracing2['default'].on(_XHRProxy.EVENT_XHR_ABORT, function (data) {\n\t                delete _this3.requests[data.data.id];\n\t            });\n\t        }\n\t    }]);\n\n\t    return XHRInspector;\n\t}();\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar GlimpseLogger = exports.GlimpseLogger = function () {\n\t    function GlimpseLogger(logToConsole) {\n\t        _classCallCheck(this, GlimpseLogger);\n\t\n\t        this.logToConsole = logToConsole;\n\t    }\n\t\n\t    _createClass(GlimpseLogger, [{\n\t        key: \"error\",\n\t        value: function error(message) {\n\t            if (this.logToConsole) {\n\t                // tslint:disable-next-line:no-console\n\t                console.error(message);\n\t            }\n\t        }\n\t    }]);\n\t\n\t    return GlimpseLogger;\n\t}();\n\t\n\tvar logger = new GlimpseLogger((false));\n\texports[\"default\"] = logger;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar MAX_HTTP_BODY_SIZE = exports.MAX_HTTP_BODY_SIZE = 132000;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.XHRProxy = exports.EVENT_XHR_ABORT = exports.EVENT_XHR_ERROR = exports.EVENT_XHR_RESPONSE_RECEIVED = exports.EVENT_XHR_REQUEST_SENT = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _GlimpseLogger = __webpack_require__(8);\n\t\n\tvar _GlimpseLogger2 = _interopRequireDefault(_GlimpseLogger);\n\t\n\tvar _Tracing = __webpack_require__(11);\n\t\n\tvar _Tracing2 = _interopRequireDefault(_Tracing);\n\t\n\tvar _GeneralUtilities = __webpack_require__(4);\n\t\n\tvar _RequestUtilities = __webpack_require__(5);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar EVENT_XHR_REQUEST_SENT = exports.EVENT_XHR_REQUEST_SENT = 'invoke|pre|XMLHttpRequest.request-sent';\n\tvar EVENT_XHR_RESPONSE_RECEIVED = exports.EVENT_XHR_RESPONSE_RECEIVED = 'notify|XMLHttpRequest.response-received';\n\tvar EVENT_XHR_ERROR = exports.EVENT_XHR_ERROR = 'notify|XMLHttpRequest.error';\n\tvar EVENT_XHR_ABORT = exports.EVENT_XHR_ABORT = 'notify|XMLHttpRequest.abort';\n\t/**\n\t * Proxy which wraps XHR usage and its various supporting functions.\n\t *\n\t * NOTE: Don't add any headers within this proxy, breaks CORS scenarioes.\n\t */\n\t\n\tvar XHRProxy = exports.XHRProxy = function () {\n\t    function XHRProxy() {\n\t        _classCallCheck(this, XHRProxy);\n\t    }\n\t\n\t    _createClass(XHRProxy, [{\n\t        key: 'isSupported',\n\t        value: function isSupported() {\n\t            // Note: TypeScript doesn't know about XMLHttpRequest existing on Window, so we\n\t            // reference the property this way to get around TypeScript\n\t            //tslint:disable-next-line:no-any\n\t            return !!(window && typeof window.XMLHttpRequest !== 'undefined');\n\t        }\n\t    }, {\n\t        key: 'init',\n\t        value: function init() {\n\t            if (XHRProxy.isInitialized) {\n\t                _GlimpseLogger2['default'].error('Glimpse Error: Cannot initialize the XHR Proxy more than once.');\n\t                return;\n\t            }\n\t            //tslint:disable-next-line:no-any\n\t            var oldXMLHttpRequest = window.XMLHttpRequest;\n\t            function XMLHttpRequest() {\n\t                var xhr = new oldXMLHttpRequest();\n\t                var id = (0, _GeneralUtilities.getGuid)();\n\t                function handleAsyncRequest(method, url) {\n\t                    var requestHeaders = {};\n\t                    xhr.addEventListener('readystatechange', function () {\n\t                        if (xhr.readyState === oldXMLHttpRequest.DONE) {\n\t                            var eventData = {\n\t                                id: id,\n\t                                xhr: xhr,\n\t                                url: (0, _RequestUtilities.resolveUrl)(url),\n\t                                statusCode: xhr.status,\n\t                                statusMessage: xhr.statusText,\n\t                                bodyType: xhr.responseType,\n\t                                body: xhr.response\n\t                            };\n\t                            _Tracing2['default'].publish(EVENT_XHR_RESPONSE_RECEIVED, eventData);\n\t                        }\n\t                        ;\n\t                    });\n\t                    xhr.addEventListener('error', function () {\n\t                        var eventData = {\n\t                            id: id,\n\t                            xhr: xhr,\n\t                            error: xhr.statusText\n\t                        };\n\t                        _Tracing2['default'].publish(EVENT_XHR_ERROR, eventData);\n\t                    });\n\t                    xhr.addEventListener('abort', function () {\n\t                        var eventData = {\n\t                            id: id,\n\t                            xhr: xhr\n\t                        };\n\t                        _Tracing2['default'].publish(EVENT_XHR_ABORT, eventData);\n\t                    });\n\t                    var oldSend = xhr.send;\n\t                    xhr.send = function send(body) {\n\t                        var eventData = {\n\t                            id: id,\n\t                            xhr: xhr,\n\t                            method: method,\n\t                            url: (0, _RequestUtilities.resolveUrl)(url),\n\t                            body: body,\n\t                            headers: requestHeaders\n\t                        };\n\t                        _Tracing2['default'].publish(EVENT_XHR_REQUEST_SENT, eventData);\n\t\n\t                        for (var _len = arguments.length, sendArgs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t                            sendArgs[_key - 1] = arguments[_key];\n\t                        }\n\t\n\t                        oldSend.call.apply(oldSend, [this, body].concat(sendArgs));\n\t                    };\n\t                    var oldSetRequestHeader = xhr.setRequestHeader;\n\t                    xhr.setRequestHeader = function setRequestHeader(header, value) {\n\t                        requestHeaders[header] = value;\n\t\n\t                        for (var _len2 = arguments.length, setRequestHeaderArgs = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n\t                            setRequestHeaderArgs[_key2 - 2] = arguments[_key2];\n\t                        }\n\t\n\t                        oldSetRequestHeader.call.apply(oldSetRequestHeader, [this, header, value].concat(setRequestHeaderArgs));\n\t                    };\n\t                }\n\t                function handleSyncRequest(method, url) {\n\t                    var oldSend = xhr.send;\n\t                    var requestHeaders = {};\n\t                    var oldSetRequestHeader = xhr.setRequestHeader;\n\t                    xhr.setRequestHeader = function setRequestHeader(header, value) {\n\t                        requestHeaders[header] = value;\n\t\n\t                        for (var _len3 = arguments.length, setRequestHeaderArgs = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n\t                            setRequestHeaderArgs[_key3 - 2] = arguments[_key3];\n\t                        }\n\t\n\t                        oldSetRequestHeader.call.apply(oldSetRequestHeader, [this, header, value].concat(setRequestHeaderArgs));\n\t                    };\n\t                    xhr.send = function send(body) {\n\t                        var requestEventData = {\n\t                            id: id,\n\t                            xhr: xhr,\n\t                            method: method,\n\t                            url: (0, _RequestUtilities.resolveUrl)(url),\n\t                            body: body,\n\t                            headers: requestHeaders\n\t                        };\n\t                        _Tracing2['default'].publish(EVENT_XHR_REQUEST_SENT, requestEventData);\n\t                        try {\n\t                            for (var _len4 = arguments.length, sendArgs = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n\t                                sendArgs[_key4 - 1] = arguments[_key4];\n\t                            }\n\t\n\t                            oldSend.call.apply(oldSend, [this, body].concat(sendArgs));\n\t                        } catch (e) {\n\t                            var errorEventData = {\n\t                                id: id,\n\t                                xhr: xhr,\n\t                                error: e.message\n\t                            };\n\t                            _Tracing2['default'].publish(EVENT_XHR_ERROR, errorEventData);\n\t                            throw e;\n\t                        }\n\t                        var responseEventData = {\n\t                            id: id,\n\t                            xhr: xhr,\n\t                            url: (0, _RequestUtilities.resolveUrl)(url),\n\t                            statusCode: xhr.status,\n\t                            statusMessage: xhr.statusText || '',\n\t                            bodyType: xhr.responseType,\n\t                            body: xhr.response\n\t                        };\n\t                        _Tracing2['default'].publish(EVENT_XHR_RESPONSE_RECEIVED, responseEventData);\n\t                    };\n\t                }\n\t                var oldOpen = xhr.open;\n\t                xhr.open = function open(method, url) {\n\t                    var async = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\t\n\t                    for (var _len5 = arguments.length, openArgs = Array(_len5 > 3 ? _len5 - 3 : 0), _key5 = 3; _key5 < _len5; _key5++) {\n\t                        openArgs[_key5 - 3] = arguments[_key5];\n\t                    }\n\t\n\t                    var result = oldOpen.call.apply(oldOpen, [this, method, url, async].concat(openArgs));\n\t                    // If the url equals the message ingress url, that means it's\n\t                    // a Glimpse message and we don't want to profile it\n\t                    if (url !== (0, _RequestUtilities.getMessageIngressUrl)()) {\n\t                        if (async) {\n\t                            handleAsyncRequest(method, url);\n\t                        } else {\n\t                            handleSyncRequest(method, url);\n\t                        }\n\t                    }\n\t                    return result;\n\t                };\n\t                return xhr;\n\t            }\n\t            // Copy the states (and anything else) from the original object to our proxy\n\t            for (var prop in oldXMLHttpRequest) {\n\t                if (oldXMLHttpRequest.hasOwnProperty(prop)) {\n\t                    XMLHttpRequest[prop] = oldXMLHttpRequest[prop];\n\t                }\n\t            }\n\t            // Note: TypeScript doesn't know about XMLHttpRequest existing on Window, so we\n\t            // reference the property this way to get around TypeScript, but we also have to\n\t            // disable tslint in the process\n\t            /* tslint:disable */\n\t            window['XMLHttpRequest'] = XMLHttpRequest;\n\t            /* tslint:enable */\n\t            XHRProxy.isInitialized = true;\n\t        }\n\t    }]);\n\t\n\t    return XHRProxy;\n\t}();\n\t\n\tXHRProxy.isInitialized = false;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * The Tracing module provides mechanisms for registering to receive tracing\n\t * events from proxies.\n\t *\n\t * This module is pretty similar to a standard EventEmitter, but has a few\n\t * key differences. This module provides the ability to filter out which\n\t * events you would like to receive, based on criteria of your choosing.\n\t *\n\t * Tracing can hurt performance in some cases, and filtering is a way for\n\t * the profiling application to improve performance whenever the data is not\n\t * explicitly needed.\n\t *\n\t * @module tracing/Tracing\n\t */\n\tvar Tracing = function () {\n\t    function Tracing() {\n\t        _classCallCheck(this, Tracing);\n\t\n\t        this.listeners = {};\n\t    }\n\t    /**\n\t     * Publishes an event, similar to the `EventEmitter.emit` method except that it\n\t     * does not accept more than one data argument.\n\t     *\n\t     * @param {string} event - The name of the event to fire, and should include a\n\t     *      descriptive namespace, e.g. `http.request:request-created`\n\t     * @param {object} data - The data associated with the event\n\t     * @returns {boolean} - Whether or not the event was published to any listeners\n\t     */\n\t\n\t\n\t    _createClass(Tracing, [{\n\t        key: \"publish\",\n\t        value: function publish(event, data) {\n\t            var listeners = this.listeners[event];\n\t            if (!listeners || listeners.length === 0) {\n\t                return false;\n\t            }\n\t            var emitted = false;\n\t            var message = {\n\t                offset: performance.now(),\n\t                timeStamp: Date.now(),\n\t                data: data\n\t            };\n\t            var _iteratorNormalCompletion = true;\n\t            var _didIteratorError = false;\n\t            var _iteratorError = undefined;\n\t\n\t            try {\n\t                for (var _iterator = listeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t                    var listener = _step.value;\n\t\n\t                    emitted = true;\n\t                    listener.listener(message);\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError = true;\n\t                _iteratorError = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion && _iterator[\"return\"]) {\n\t                        _iterator[\"return\"]();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError) {\n\t                        throw _iteratorError;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return emitted;\n\t        }\n\t        /**\n\t         * Register to always receive an event without any filtering. This module is\n\t         * returned from this method, making it possible to chain `removeEventListener`\n\t         * calls.\n\t         *\n\t         * Note: if any other listeners are filtering this event, registering with\n\t         * this method will prevent the proxies from enabling any performance\n\t         * optimizations.\n\t         *\n\t         * Calling this method is equivalent to calling `onFiltered(event, listener, () => true)`\n\t         *\n\t         * @param {string} event - The name of the event to listen to, e.g.\n\t         *      `http.request:request-created`\n\t         * @param {function} listener - The callback to call when the event is emitted\n\t         */\n\t\n\t    }, {\n\t        key: \"on\",\n\t        value: function on(event, listener) {\n\t            if (!this.listeners[event]) {\n\t                this.listeners[event] = [];\n\t            }\n\t            this.listeners[event].push({\n\t                listener: listener\n\t            });\n\t            return this;\n\t        }\n\t        /**\n\t         * Removes exactly one registered event listener. If the same callback is\n\t         * registered more than once, only the first copy is removed. This behavior\n\t         * mimics that of EventEmitter.removeEventListener\n\t         *\n\t         * @param {string} event - The name of the event to remove the listener for,\n\t         *      e.g. `http.request:request-created`\n\t         * @param {function} listener - The listener to remove\n\t         * @returns {object} A refernce to this module, making it possible to chain\n\t         *      removeEventListener calls\n\t         */\n\t\n\t    }, {\n\t        key: \"removeEventListener\",\n\t        value: function removeEventListener(event, listener) {\n\t            var listeners = this.listeners[event];\n\t            if (!listeners) {\n\t                // Matches Node.js removeEventListener return signature\n\t                return this;\n\t            }\n\t            for (var i = 0; i < listeners.length; i++) {\n\t                if (listeners[i].listener === listener) {\n\t                    this.listeners[event].splice(i, 1);\n\t                    break;\n\t                }\n\t            }\n\t            return this;\n\t        }\n\t        /**\n\t         * Removes all listeners for the given event. If no event is specified, then\n\t         * all event listeners for all events are removed.\n\t         *\n\t         * @param {string} event - (Optional) The event to remove listeners for\n\t         * @returns {object} A refernce to this module, making it possible to chain calls\n\t         */\n\t\n\t    }, {\n\t        key: \"removeAllListeners\",\n\t        value: function removeAllListeners(event) {\n\t            if (event) {\n\t                if (this.listeners[event]) {\n\t                    this.listeners[event] = [];\n\t                }\n\t            } else {\n\t                this.listeners = {};\n\t            }\n\t            return this;\n\t        }\n\t        /**\n\t         * Returns the number of listeners for the given event. This behavior\n\t         * mimics that of EventEmitter.listenerCount\n\t         *\n\t         * @param {string} event - The event to count listeners for\n\t         * @returns {number} The number of listeners for the given event\n\t         */\n\t\n\t    }, {\n\t        key: \"listenerCount\",\n\t        value: function listenerCount(event) {\n\t            if (!this.listeners[event]) {\n\t                return 0;\n\t            }\n\t            return this.listeners[event].length;\n\t        }\n\t    }]);\n\t\n\t    return Tracing;\n\t}();\n\t\n\texports[\"default\"] = new Tracing();\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.getDateTime = getDateTime;\n\tfunction toTwoDigits(value) {\n\t    return value < 10 ? '0' + value : value;\n\t}\n\tfunction toThreeDigits(value) {\n\t    if (value < 10) {\n\t        return '00' + value;\n\t    }\n\t    if (value < 100) {\n\t        return '0' + value;\n\t    }\n\t    return value;\n\t}\n\tfunction getUTCOffset(date) {\n\t    var offset = date.getTimezoneOffset();\n\t    var sign = offset >= 0 ? '+' : '-';\n\t    offset = Math.abs(offset);\n\t    var hours = toTwoDigits(Math.floor(offset / 60));\n\t    var minutes = toTwoDigits(offset % 60);\n\t    return sign + hours + minutes;\n\t}\n\t// Convert time according to the format string: 'YYYY-MM-DDTHH:mm:ss.SSS ZZ'\n\t// Output should look like: \"2016-06-08T09:07:11.021 -0700\"\n\tfunction getDateTime() {\n\t    var d = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();\n\t\n\t    return d.getFullYear() + '-' + toTwoDigits(d.getMonth() + 1) + '-' + toTwoDigits(d.getDate()) + 'T' + toTwoDigits(d.getHours()) + ':' + toTwoDigits(d.getMinutes()) + ':' + toTwoDigits(d.getSeconds()) + '.' + toThreeDigits(d.getMilliseconds()) + getUTCOffset(d);\n\t}\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar trim = __webpack_require__(14)\n\t  , forEach = __webpack_require__(15)\n\t  , isArray = function(arg) {\n\t      return Object.prototype.toString.call(arg) === '[object Array]';\n\t    }\n\t\n\tmodule.exports = function (headers) {\n\t  if (!headers)\n\t    return {}\n\t\n\t  var result = {}\n\t\n\t  forEach(\n\t      trim(headers).split('\\n')\n\t    , function (row) {\n\t        var index = row.indexOf(':')\n\t          , key = trim(row.slice(0, index)).toLowerCase()\n\t          , value = trim(row.slice(index + 1))\n\t\n\t        if (typeof(result[key]) === 'undefined') {\n\t          result[key] = value\n\t        } else if (isArray(result[key])) {\n\t          result[key].push(value)\n\t        } else {\n\t          result[key] = [ result[key], value ]\n\t        }\n\t      }\n\t  )\n\t\n\t  return result\n\t}\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\n\t\n\texports = module.exports = trim;\n\t\n\tfunction trim(str){\n\t  return str.replace(/^\\s*|\\s*$/g, '');\n\t}\n\t\n\texports.left = function(str){\n\t  return str.replace(/^\\s*/, '');\n\t};\n\t\n\texports.right = function(str){\n\t  return str.replace(/\\s*$/, '');\n\t};\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar isFunction = __webpack_require__(16)\n\t\n\tmodule.exports = forEach\n\t\n\tvar toString = Object.prototype.toString\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty\n\t\n\tfunction forEach(list, iterator, context) {\n\t    if (!isFunction(iterator)) {\n\t        throw new TypeError('iterator must be a function')\n\t    }\n\t\n\t    if (arguments.length < 3) {\n\t        context = this\n\t    }\n\t    \n\t    if (toString.call(list) === '[object Array]')\n\t        forEachArray(list, iterator, context)\n\t    else if (typeof list === 'string')\n\t        forEachString(list, iterator, context)\n\t    else\n\t        forEachObject(list, iterator, context)\n\t}\n\t\n\tfunction forEachArray(array, iterator, context) {\n\t    for (var i = 0, len = array.length; i < len; i++) {\n\t        if (hasOwnProperty.call(array, i)) {\n\t            iterator.call(context, array[i], i, array)\n\t        }\n\t    }\n\t}\n\t\n\tfunction forEachString(string, iterator, context) {\n\t    for (var i = 0, len = string.length; i < len; i++) {\n\t        // no such thing as a sparse string.\n\t        iterator.call(context, string.charAt(i), i, string)\n\t    }\n\t}\n\t\n\tfunction forEachObject(object, iterator, context) {\n\t    for (var k in object) {\n\t        if (hasOwnProperty.call(object, k)) {\n\t            iterator.call(context, object[k], k, object)\n\t        }\n\t    }\n\t}\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = isFunction\n\t\n\tvar toString = Object.prototype.toString\n\t\n\tfunction isFunction (fn) {\n\t  var string = toString.call(fn)\n\t  return string === '[object Function]' ||\n\t    (typeof fn === 'function' && string !== '[object RegExp]') ||\n\t    (typeof window !== 'undefined' &&\n\t     // IE8 and below\n\t     (fn === window.setTimeout ||\n\t      fn === window.alert ||\n\t      fn === window.confirm ||\n\t      fn === window.prompt))\n\t};\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.createEmptyBody = createEmptyBody;\n\texports.createBodyForBlob = createBodyForBlob;\n\texports.getMultiPartFormBoundary = getMultiPartFormBoundary;\n\texports.getMultiPartFormParts = getMultiPartFormParts;\n\texports.tryFindResourceTimingObject = tryFindResourceTimingObject;\n\t\n\tvar _GeneralUtilities = __webpack_require__(4);\n\t\n\tvar _Constants = __webpack_require__(9);\n\t\n\t/**\n\t * set of regular expressions that match a mime type when the encoding of a payload is UTF8\n\t */\n\tvar UTF8_ENCODING_MIME_TYPES = [/^text\\//, /^application\\/.*?xml/, /^application\\/json/, /^application\\/javascript/, /^application\\/x-www-form-urlencoded/, /^multipart\\/form-data/];\n\t/**\n\t * Infer the encoding type given a blob\n\t *\n\t * @param blob The blob to get the encoding for\n\t */\n\tfunction getEncodingForBlob(blob) {\n\t    var encoding = 'none';\n\t    var _iteratorNormalCompletion = true;\n\t    var _didIteratorError = false;\n\t    var _iteratorError = undefined;\n\t\n\t    try {\n\t        for (var _iterator = UTF8_ENCODING_MIME_TYPES[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t            var mimeType = _step.value;\n\t\n\t            if (mimeType.test(blob.type)) {\n\t                encoding = 'utf8';\n\t                break;\n\t            }\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError = true;\n\t        _iteratorError = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion && _iterator['return']) {\n\t                _iterator['return']();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError) {\n\t                throw _iteratorError;\n\t            }\n\t        }\n\t    }\n\t\n\t    return encoding;\n\t}\n\tfunction createEmptyBody(isTruncated) {\n\t    return {\n\t        size: 0,\n\t        encoding: 'none',\n\t        content: '',\n\t        isTruncated: isTruncated\n\t    };\n\t}\n\tfunction createBodyForBlob(contentTypeHeader, blob, includeParts, cb) {\n\t    // TODO: https://github.com/Glimpse/Glimpse.Node.Prototype/issues/307\n\t    // Add support for base64 encoding non-text content by setting the encoding here\n\t    // Note on use of setTimeout() below.  This is done to ensure all code paths execute asynchronously,\n\t    // irrespective of whether convertBlobtoText is called.  For a more in-depth discussion,\n\t    // see https://nodejs.org/dist/latest-v7.x/docs/api/process.html#process_process_nexttick_callback_args\n\t    if (blob.size) {\n\t        var encoding = getEncodingForBlob(blob);\n\t        switch (encoding) {\n\t            case 'utf8':\n\t                (0, _GeneralUtilities.convertBlobToText)(blob, encoding, function (content) {\n\t                    var boundary = getMultiPartFormBoundary(contentTypeHeader);\n\t                    var parts = boundary && includeParts ? getMultiPartFormParts(boundary, content) : [];\n\t                    content = content.slice(0, _Constants.MAX_HTTP_BODY_SIZE);\n\t                    var bodyMessage = {\n\t                        size: blob.size,\n\t                        encoding: encoding,\n\t                        content: content,\n\t                        isTruncated: blob.size > content.length\n\t                    };\n\t                    if (parts && includeParts) {\n\t                        bodyMessage.parts = parts;\n\t                    }\n\t                    cb(bodyMessage);\n\t                });\n\t                break;\n\t            default:\n\t                setTimeout(function () {\n\t                    return cb({\n\t                        size: blob.size,\n\t                        encoding: encoding,\n\t                        content: '',\n\t                        isTruncated: true\n\t                    });\n\t                }, 0);\n\t                break;\n\t        }\n\t    } else {\n\t        setTimeout(function () {\n\t            return cb(createEmptyBody(false));\n\t        }, 0);\n\t    }\n\t}\n\t/**\n\t * Function to convert a string to a map from header-name => string[] of header values\n\t *\n\t * @param rawHeaders raw headers string\n\t */\n\tfunction convertRawHeaders(rawHeaders) {\n\t    var h = {};\n\t    rawHeaders = rawHeaders.trim();\n\t    var lines = rawHeaders.split('\\r\\n');\n\t    lines.forEach(function (l) {\n\t        var idx = l.indexOf(':');\n\t        if (idx > 0) {\n\t            var name = l.substring(0, idx).trim().toLowerCase();\n\t            var value = l.substring(idx + 1, l.length).trim();\n\t            if (!h[name]) {\n\t                h[name] = [];\n\t            }\n\t            h[name].push(value);\n\t        }\n\t    });\n\t    return h;\n\t}\n\t/**\n\t * Regular expression to pull boundary delimiter from multipart/form-data content type.\n\t * valid boundary characters taken from grammar defined in https://www.ietf.org/rfc/rfc2046.txt, Appendix A\n\t */\n\tvar MULTIPART_FORMDATA_REG_EX = /\\s*(multipart\\/form-data)\\s*;.*boundary\\s*=\\s*\"?([0-9a-zA-Z'()+_,-.\\/:=?]+)\"?/i;\n\t/**\n\t * Get the boundary delimiter for a multipart/forma-data content-type header.\n\t * If boundary paramter doesn't exist, or if content-type is not multipart/form-data\n\t * this will return undefined;\n\t *\n\t * @param contentTypeHeader the value of the Content-Type header\n\t */\n\tfunction getMultiPartFormBoundary(contentTypeHeader) {\n\t    var matches = MULTIPART_FORMDATA_REG_EX.exec(contentTypeHeader);\n\t    if (matches) {\n\t        return matches[2];\n\t    }\n\t    return undefined;\n\t}\n\t/**\n\t * Given a multipart-form/data encoded body & a boundary delimiter, this will return an\n\t * array of IPartSummary interfaces describing the parts.\n\t *\n\t * @param boundary The boundary delimiter string used in a multipart/form-data message\n\t * @param body The text body.\n\t */\n\tfunction getMultiPartFormParts(boundary, body) {\n\t    boundary = '--' + boundary;\n\t    var firstBoundaryRegExString = '^((\\\\r\\\\n)?' + boundary + '\\\\s*?\\\\r\\\\n)';\n\t    var firstBoundaryRegEx = new RegExp(firstBoundaryRegExString, 'gm');\n\t    // captures:\n\t    //    $1:  optional header section\n\t    //    $2:  CRLFCRLF seperating headers & body, or if no headers, separating boundary marker & body\n\t    //    $3:  body section\n\t    //    $4:  next boundary marker\n\t    //    $5:  content after closing boundary\n\t    //    $6:  \"--\" indicating end of multipart bodies.  If this part matches, then we've found the last boundary delimiter\n\t    //    $7:  trailing whitespace\n\t    var partRegExString = '([\\\\s\\\\S]*?)(\\\\r\\\\n\\\\r\\\\n)([\\\\s\\\\S]*?)(\\\\r\\\\n' + boundary + ')((--)|(\\\\s*?\\\\r\\\\n))';\n\t    var partRegEx = new RegExp(partRegExString, 'gm');\n\t    var firstBoundary = firstBoundaryRegEx.exec(body);\n\t    var partSummaries = [];\n\t    if (firstBoundary) {\n\t        // start searching for parts immediately after the first boundary reg ex match.  Back up two to include trailing \\r\\n\n\t        partRegEx.lastIndex = firstBoundaryRegEx.lastIndex - 2;\n\t        while (true) {\n\t            var part = partRegEx.exec(body);\n\t            if (!part) {\n\t                break;\n\t            }\n\t            var headerSectionLength = part[1] ? part[1].length : 0;\n\t            var bodyStartIndex = part.index + headerSectionLength + part[2].length;\n\t            var convertedHeaders = part[1] ? convertRawHeaders(part[1]) : {};\n\t            var bodySectionLength = part[3] ? part[3].length : 0;\n\t            partSummaries.push({\n\t                headers: convertedHeaders,\n\t                bodyStartIndex: part.index + part[1].length + part[2].length,\n\t                bodyEndIndex: bodyStartIndex + bodySectionLength,\n\t                bodyLength: bodySectionLength\n\t            });\n\t            if (part[6]) {\n\t                // found trailing -- after boundary, which indicates we're done\n\t                break;\n\t            }\n\t        }\n\t    }\n\t    return partSummaries;\n\t}\n\t/**\n\t * Asynchronously attempts to find a PerformanceResourceTiming object that matches the given initiatorType and url and\n\t * whose startTime is within two milliseconds of `expectedStart` parameter. Specified callback will invoked with the\n\t * matching PerformanceResourceTiming object, or with undefined if unable to find matching object.\n\t * Will attempt lookup up to 8 times, with a delay increasing exponentially from 1ms up to 256ms, for a maximum delay of 511ms\n\t *\n\t * @param initiatorType A RegExp that will match the expected value for the initiatorType of the target PerformanceResourceTiming instance\n\t * @param url - expected URL of the target PerformanceResourceTiming instance\n\t * @param expectedStart - the expected start time for the target PerformanceResourceTiming instance\n\t * @param cb - callback to invoke when target is found, or when max number of lookup attempts has been made\n\t */\n\tfunction tryFindResourceTimingObject(requestId, initiatorType, url, expectedStart, cb) {\n\t    if (!(performance && performance.getEntriesByType)) {\n\t        setTimeout(function () {\n\t            return cb(undefined);\n\t        });\n\t        return;\n\t    }\n\t    var maxDelay = 1024; // milliseconds\n\t    var delay = 1;\n\t    function tryGet() {\n\t        function computeDelta(p2) {\n\t            return Math.abs(p2.startTime - expectedStart);\n\t        }\n\t        // try to find this request\n\t        var entries = performance.getEntriesByType('resource');\n\t        var target = undefined;\n\t        var candidates = [];\n\t        for (var i = 0; i < entries.length; i++) {\n\t            var curr = entries[i];\n\t            if (requestId && curr.__glimpse_requestId === requestId) {\n\t                // if we've already matched this PerformanceResourceTiming with this specific request, then use it\n\t                target = curr;\n\t                break;\n\t            } else if (initiatorType.test(curr.initiatorType) && curr.name === url && expectedStart <= curr.startTime && !curr.__glimpse_requestId) {\n\t                candidates.push(curr);\n\t            }\n\t        }\n\t        if (!target) {\n\t            candidates.sort(function (a, b) {\n\t                var deltaA = computeDelta(a);\n\t                var deltaB = computeDelta(b);\n\t                // sort by smallest delta between startTime & expectedStart\n\t                return deltaA - deltaB;\n\t            });\n\t            if (candidates.length > 0) {\n\t                target = candidates[0];\n\t                target.__glimpse_requestId = requestId;\n\t            }\n\t        }\n\t        if (target || delay >= maxDelay) {\n\t            cb(target);\n\t        } else {\n\t            delay *= 2;\n\t            setTimeout(tryGet, delay);\n\t        }\n\t        return target;\n\t    }\n\t    setTimeout(tryGet, delay);\n\t}\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.getStackTrace = getStackTrace;\n\t\n\tvar _errorStackParser = __webpack_require__(19);\n\t\n\tvar ErrorStackParser = _interopRequireWildcard(_errorStackParser);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tfunction getStackTrace(cb) {\n\t    // stacktrace-js library has a Get method that will try to apply sourcemaps, however\n\t    // that will trigger a download of the source, and will show up as an XHR request\n\t    // in glimpse, which we don't want.  When we disable source-maps, then\n\t    // stacktrace-js will reject a promise, which causes undesired debugger breakpoints\n\t    // when the user has their app open in f12 tools. The easiest thing here is to put\n\t    // generate the error ourself, and use the error-stack-parser library to parse the\n\t    // error into stack frames.\n\t    // this logic to get an error comes from stacktrace-js library.\n\t    // See https://github.com/stacktracejs/stacktrace.js/blob/master/stacktrace.js#L25-L32\n\t    function getError() {\n\t        var err = new Error();\n\t        if (!err.stack) {\n\t            try {\n\t                // Error must be thrown to get stack in IE\n\t                throw new Error();\n\t            } catch (e2) {\n\t                err = e2;\n\t            }\n\t        }\n\t        return err;\n\t    }\n\t    var stackFrames = ErrorStackParser.parse(getError());\n\t    // slice off top frames where glimpse code is on the stack.\n\t    for (var i = 0; i < stackFrames.length; i++) {\n\t        if (stackFrames[i].fileName && !stackFrames[i].fileName.endsWith('/glimpse/agent/agent.js?hash={hash}')) {\n\t            stackFrames = stackFrames.slice(i);\n\t            break;\n\t        }\n\t    }\n\t    // strip out any extra properties we don't want to send w/ the glimpse message\n\t    var newFrames = [];\n\t    stackFrames.forEach(function (val, index) {\n\t        newFrames[index] = {\n\t            fileName: val.fileName,\n\t            functionName: val.functionName,\n\t            lineNumber: val.lineNumber,\n\t            columnNumber: val.columnNumber\n\t        };\n\t    });\n\t    // various tests are expecting this to run asynchronously, which we'll eventually need if we ever hook up\n\t    // source maps.  Even though we don't need it today, we'll leave this as an async function.\n\t    window.setTimeout(function () {\n\t        cb(newFrames);\n\t    }, 0);\n\t}\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {\n\t    'use strict';\n\t    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\t\n\t    /* istanbul ignore next */\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(20)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof exports === 'object') {\n\t        module.exports = factory(require('stackframe'));\n\t    } else {\n\t        root.ErrorStackParser = factory(root.StackFrame);\n\t    }\n\t}(this, function ErrorStackParser(StackFrame) {\n\t    'use strict';\n\t\n\t    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+\\:\\d+/;\n\t    var CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+\\:\\d+|\\(native\\))/m;\n\t    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code\\])?$/;\n\t\n\t    return {\n\t        /**\n\t         * Given an Error object, extract the most information from it.\n\t         *\n\t         * @param {Error} error object\n\t         * @return {Array} of StackFrames\n\t         */\n\t        parse: function ErrorStackParser$$parse(error) {\n\t            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n\t                return this.parseOpera(error);\n\t            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n\t                return this.parseV8OrIE(error);\n\t            } else if (error.stack) {\n\t                return this.parseFFOrSafari(error);\n\t            } else {\n\t                throw new Error('Cannot parse given Error object');\n\t            }\n\t        },\n\t\n\t        // Separate line and column numbers from a string of the form: (URI:Line:Column)\n\t        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n\t            // Fail-fast but return locations like \"(native)\"\n\t            if (urlLike.indexOf(':') === -1) {\n\t                return [urlLike];\n\t            }\n\t\n\t            var regExp = /(.+?)(?:\\:(\\d+))?(?:\\:(\\d+))?$/;\n\t            var parts = regExp.exec(urlLike.replace(/[\\(\\)]/g, ''));\n\t            return [parts[1], parts[2] || undefined, parts[3] || undefined];\n\t        },\n\t\n\t        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n\t            var filtered = error.stack.split('\\n').filter(function(line) {\n\t                return !!line.match(CHROME_IE_STACK_REGEXP);\n\t            }, this);\n\t\n\t            return filtered.map(function(line) {\n\t                if (line.indexOf('(eval ') > -1) {\n\t                    // Throw away eval information until we implement stacktrace.js/stackframe#8\n\t                    line = line.replace(/eval code/g, 'eval').replace(/(\\(eval at [^\\()]*)|(\\)\\,.*$)/g, '');\n\t                }\n\t                var tokens = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '(').split(/\\s+/).slice(1);\n\t                var locationParts = this.extractLocation(tokens.pop());\n\t                var functionName = tokens.join(' ') || undefined;\n\t                var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];\n\t\n\t                return new StackFrame({\n\t                    functionName: functionName,\n\t                    fileName: fileName,\n\t                    lineNumber: locationParts[1],\n\t                    columnNumber: locationParts[2],\n\t                    source: line\n\t                });\n\t            }, this);\n\t        },\n\t\n\t        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n\t            var filtered = error.stack.split('\\n').filter(function(line) {\n\t                return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n\t            }, this);\n\t\n\t            return filtered.map(function(line) {\n\t                // Throw away eval information until we implement stacktrace.js/stackframe#8\n\t                if (line.indexOf(' > eval') > -1) {\n\t                    line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval\\:\\d+\\:\\d+/g, ':$1');\n\t                }\n\t\n\t                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n\t                    // Safari eval frames only have function names and nothing else\n\t                    return new StackFrame({\n\t                        functionName: line\n\t                    });\n\t                } else {\n\t                    var tokens = line.split('@');\n\t                    var locationParts = this.extractLocation(tokens.pop());\n\t                    var functionName = tokens.join('@') || undefined;\n\t\n\t                    return new StackFrame({\n\t                        functionName: functionName,\n\t                        fileName: locationParts[0],\n\t                        lineNumber: locationParts[1],\n\t                        columnNumber: locationParts[2],\n\t                        source: line\n\t                    });\n\t                }\n\t            }, this);\n\t        },\n\t\n\t        parseOpera: function ErrorStackParser$$parseOpera(e) {\n\t            if (!e.stacktrace || (e.message.indexOf('\\n') > -1 &&\n\t                e.message.split('\\n').length > e.stacktrace.split('\\n').length)) {\n\t                return this.parseOpera9(e);\n\t            } else if (!e.stack) {\n\t                return this.parseOpera10(e);\n\t            } else {\n\t                return this.parseOpera11(e);\n\t            }\n\t        },\n\t\n\t        parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n\t            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n\t            var lines = e.message.split('\\n');\n\t            var result = [];\n\t\n\t            for (var i = 2, len = lines.length; i < len; i += 2) {\n\t                var match = lineRE.exec(lines[i]);\n\t                if (match) {\n\t                    result.push(new StackFrame({\n\t                        fileName: match[2],\n\t                        lineNumber: match[1],\n\t                        source: lines[i]\n\t                    }));\n\t                }\n\t            }\n\t\n\t            return result;\n\t        },\n\t\n\t        parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n\t            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n\t            var lines = e.stacktrace.split('\\n');\n\t            var result = [];\n\t\n\t            for (var i = 0, len = lines.length; i < len; i += 2) {\n\t                var match = lineRE.exec(lines[i]);\n\t                if (match) {\n\t                    result.push(\n\t                        new StackFrame({\n\t                            functionName: match[3] || undefined,\n\t                            fileName: match[2],\n\t                            lineNumber: match[1],\n\t                            source: lines[i]\n\t                        })\n\t                    );\n\t                }\n\t            }\n\t\n\t            return result;\n\t        },\n\t\n\t        // Opera 10.65+ Error.stack very similar to FF/Safari\n\t        parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n\t            var filtered = error.stack.split('\\n').filter(function(line) {\n\t                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n\t            }, this);\n\t\n\t            return filtered.map(function(line) {\n\t                var tokens = line.split('@');\n\t                var locationParts = this.extractLocation(tokens.pop());\n\t                var functionCall = (tokens.shift() || '');\n\t                var functionName = functionCall\n\t                        .replace(/<anonymous function(: (\\w+))?>/, '$2')\n\t                        .replace(/\\([^\\)]*\\)/g, '') || undefined;\n\t                var argsRaw;\n\t                if (functionCall.match(/\\(([^\\)]*)\\)/)) {\n\t                    argsRaw = functionCall.replace(/^[^\\(]+\\(([^\\)]*)\\)$/, '$1');\n\t                }\n\t                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?\n\t                    undefined : argsRaw.split(',');\n\t\n\t                return new StackFrame({\n\t                    functionName: functionName,\n\t                    args: args,\n\t                    fileName: locationParts[0],\n\t                    lineNumber: locationParts[1],\n\t                    columnNumber: locationParts[2],\n\t                    source: line\n\t                });\n\t            }, this);\n\t        }\n\t    };\n\t}));\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {\n\t    'use strict';\n\t    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\t\n\t    /* istanbul ignore next */\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof exports === 'object') {\n\t        module.exports = factory();\n\t    } else {\n\t        root.StackFrame = factory();\n\t    }\n\t}(this, function() {\n\t    'use strict';\n\t    function _isNumber(n) {\n\t        return !isNaN(parseFloat(n)) && isFinite(n);\n\t    }\n\t\n\t    function _capitalize(str) {\n\t        return str[0].toUpperCase() + str.substring(1);\n\t    }\n\t\n\t    function _getter(p) {\n\t        return function() {\n\t            return this[p];\n\t        };\n\t    }\n\t\n\t    var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];\n\t    var numericProps = ['columnNumber', 'lineNumber'];\n\t    var stringProps = ['fileName', 'functionName', 'source'];\n\t    var arrayProps = ['args'];\n\t\n\t    var props = booleanProps.concat(numericProps, stringProps, arrayProps);\n\t\n\t    function StackFrame(obj) {\n\t        if (obj instanceof Object) {\n\t            for (var i = 0; i < props.length; i++) {\n\t                if (obj.hasOwnProperty(props[i]) && obj[props[i]] !== undefined) {\n\t                    this['set' + _capitalize(props[i])](obj[props[i]]);\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    StackFrame.prototype = {\n\t        getArgs: function() {\n\t            return this.args;\n\t        },\n\t        setArgs: function(v) {\n\t            if (Object.prototype.toString.call(v) !== '[object Array]') {\n\t                throw new TypeError('Args must be an Array');\n\t            }\n\t            this.args = v;\n\t        },\n\t\n\t        getEvalOrigin: function() {\n\t            return this.evalOrigin;\n\t        },\n\t        setEvalOrigin: function(v) {\n\t            if (v instanceof StackFrame) {\n\t                this.evalOrigin = v;\n\t            } else if (v instanceof Object) {\n\t                this.evalOrigin = new StackFrame(v);\n\t            } else {\n\t                throw new TypeError('Eval Origin must be an Object or StackFrame');\n\t            }\n\t        },\n\t\n\t        toString: function() {\n\t            var functionName = this.getFunctionName() || '{anonymous}';\n\t            var args = '(' + (this.getArgs() || []).join(',') + ')';\n\t            var fileName = this.getFileName() ? ('@' + this.getFileName()) : '';\n\t            var lineNumber = _isNumber(this.getLineNumber()) ? (':' + this.getLineNumber()) : '';\n\t            var columnNumber = _isNumber(this.getColumnNumber()) ? (':' + this.getColumnNumber()) : '';\n\t            return functionName + args + fileName + lineNumber + columnNumber;\n\t        }\n\t    };\n\t\n\t    for (var i = 0; i < booleanProps.length; i++) {\n\t        StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);\n\t        StackFrame.prototype['set' + _capitalize(booleanProps[i])] = (function(p) {\n\t            return function(v) {\n\t                this[p] = Boolean(v);\n\t            };\n\t        })(booleanProps[i]);\n\t    }\n\t\n\t    for (var j = 0; j < numericProps.length; j++) {\n\t        StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);\n\t        StackFrame.prototype['set' + _capitalize(numericProps[j])] = (function(p) {\n\t            return function(v) {\n\t                if (!_isNumber(v)) {\n\t                    throw new TypeError(p + ' must be a Number');\n\t                }\n\t                this[p] = Number(v);\n\t            };\n\t        })(numericProps[j]);\n\t    }\n\t\n\t    for (var k = 0; k < stringProps.length; k++) {\n\t        StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);\n\t        StackFrame.prototype['set' + _capitalize(stringProps[k])] = (function(p) {\n\t            return function(v) {\n\t                this[p] = String(v);\n\t            };\n\t        })(stringProps[k]);\n\t    }\n\t\n\t    return StackFrame;\n\t}));\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.FetchInspector = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _GlimpseLogger = __webpack_require__(8);\n\t\n\tvar _GlimpseLogger2 = _interopRequireDefault(_GlimpseLogger);\n\t\n\tvar _MessageMixins = __webpack_require__(6);\n\t\n\tvar _FetchProxy = __webpack_require__(22);\n\t\n\tvar _Tracing = __webpack_require__(11);\n\t\n\tvar _Tracing2 = _interopRequireDefault(_Tracing);\n\t\n\tvar _DateTimeUtilities = __webpack_require__(12);\n\t\n\tvar _RequestUtilities = __webpack_require__(5);\n\t\n\tvar _HttpRequestUtils = __webpack_require__(17);\n\t\n\tvar _CallStackUtilities = __webpack_require__(18);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar FetchInspector = exports.FetchInspector = function () {\n\t    function FetchInspector() {\n\t        _classCallCheck(this, FetchInspector);\n\t\n\t        this.initiatorRexExp = /(^$)|(other)/i;\n\t        this.requests = {};\n\t    }\n\t\n\t    _createClass(FetchInspector, [{\n\t        key: 'createHeaders',\n\t        value: function createHeaders(headers) {\n\t            var parsedHeaders = {};\n\t            var headerKeys = (0, _RequestUtilities.getHeaderKeys)(headers);\n\t            var _iteratorNormalCompletion = true;\n\t            var _didIteratorError = false;\n\t            var _iteratorError = undefined;\n\t\n\t            try {\n\t                for (var _iterator = headerKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t                    var header = _step.value;\n\t\n\t                    parsedHeaders[header] = headers.get(header);\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError = true;\n\t                _iteratorError = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion && _iterator['return']) {\n\t                        _iterator['return']();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError) {\n\t                        throw _iteratorError;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return parsedHeaders;\n\t        }\n\t    }, {\n\t        key: 'getContentTypeHeader',\n\t        value: function getContentTypeHeader(headers) {\n\t            var val = void 0;\n\t            val = headers.get('content-type');\n\t            if (!val) {\n\t                var headerKeys = (0, _RequestUtilities.getHeaderKeys)(headers);\n\t                var _iteratorNormalCompletion2 = true;\n\t                var _didIteratorError2 = false;\n\t                var _iteratorError2 = undefined;\n\t\n\t                try {\n\t                    for (var _iterator2 = headerKeys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t                        var header = _step2.value;\n\t\n\t                        if (header.toLowerCase() === 'content-type') {\n\t                            val = headers[header];\n\t                            break;\n\t                        }\n\t                    }\n\t                } catch (err) {\n\t                    _didIteratorError2 = true;\n\t                    _iteratorError2 = err;\n\t                } finally {\n\t                    try {\n\t                        if (!_iteratorNormalCompletion2 && _iterator2['return']) {\n\t                            _iterator2['return']();\n\t                        }\n\t                    } finally {\n\t                        if (_didIteratorError2) {\n\t                            throw _iteratorError2;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t            return val;\n\t        }\n\t    }, {\n\t        key: 'before',\n\t        value: function before(event) {\n\t            var _this = this;\n\t\n\t            var eventData = event.data;\n\t            (0, _CallStackUtilities.getStackTrace)(function (frames) {\n\t                var publishMessage = function publishMessage(body) {\n\t                    var url = (0, _RequestUtilities.parseUrl)(eventData.request.url);\n\t                    var startTime = (0, _DateTimeUtilities.getDateTime)(new Date(event.timeStamp));\n\t                    var msg = _this.messagePublisher.createMessage(['data-http-request', 'call-stack'], {\n\t                        correlationId: eventData.id,\n\t                        protocol: {\n\t                            identifier: url.protocol.replace(/\\:$/, '').toLowerCase()\n\t                        },\n\t                        url: eventData.request.url,\n\t                        method: eventData.request.method,\n\t                        startTime: startTime,\n\t                        timing: {\n\t                            startTime: 0\n\t                        },\n\t                        headers: _this.createHeaders(eventData.request.headers),\n\t                        isAjax: true,\n\t                        body: body,\n\t                        frames: frames.slice(0, 1)\n\t                    });\n\t                    (0, _MessageMixins.addOffset)(event.offset, msg);\n\t                    _this.messagePublisher.publishMessage(msg);\n\t                };\n\t                eventData.request.blob().then(function (blob) {\n\t                    var contentTypeHeader = _this.getContentTypeHeader(eventData.request.headers);\n\t                    (0, _HttpRequestUtils.createBodyForBlob)(contentTypeHeader, blob, true, function (body) {\n\t                        publishMessage(body);\n\t                    });\n\t                }, function (reason) {\n\t                    // Safari 10.1 fails to obtain the request body as a blob, so publish the message with a \"truncated\" body...\n\t                    // (https://github.com/Glimpse/Glimpse.Browser.Agent/issues/192)\n\t                    publishMessage((0, _HttpRequestUtils.createEmptyBody)( /* truncated: */true));\n\t                });\n\t            });\n\t        }\n\t    }, {\n\t        key: 'after',\n\t        value: function after(event, requestEntry) {\n\t            var _this2 = this;\n\t\n\t            var eventData = event.data;\n\t            eventData.response.blob().then(function (blob) {\n\t                var responseEndOffset = performance.now();\n\t                // for fetch events, the initiator type is an empty string on chrome, and 'other' on firefox.\n\t                (0, _HttpRequestUtils.tryFindResourceTimingObject)(event.data.id, _this2.initiatorRexExp, event.data.response.url, requestEntry.startTimeOffset, function (timings) {\n\t                    // we make a best-effort to find the PerformanceResourceTiming instance associated with this request.  If we have one,\n\t                    // we use it, but if not, we fall back to using times associated with when different proxy methods were invoked\n\t                    var offset = timings ? timings.startTime : requestEntry.startTimeOffset;\n\t                    var startTime = 0;\n\t                    // leave responseStart undefined if no timings instance since this is optional and we don't know accurate value\n\t                    var responseStart = timings && timings.responseStart >= timings.startTime ? timings.responseStart - timings.startTime : undefined;\n\t                    var responseEnd = timings ? timings.responseEnd - timings.startTime : responseEndOffset - requestEntry.startTimeOffset;\n\t                    var contentTypeHeader = _this2.getContentTypeHeader(eventData.response.headers);\n\t                    (0, _HttpRequestUtils.createBodyForBlob)(contentTypeHeader, blob, true, function (body) {\n\t                        var statusCode = void 0;\n\t                        switch (eventData.response.type) {\n\t                            case 'error':\n\t                                // TODO: publish an error message here. See https://github.com/Glimpse/Glimpse.Browser.Agent/issues/134\n\t                                return;\n\t                            case 'opaque':\n\t                                statusCode = -1;\n\t                                break;\n\t                            case 'opaqueredirect':\n\t                                statusCode = -2;\n\t                                break;\n\t                            default:\n\t                                statusCode = eventData.response.status;\n\t                                break;\n\t                        }\n\t                        var msg = _this2.messagePublisher.createMessage('data-http-response', {\n\t                            correlationId: eventData.id,\n\t                            url: eventData.response.url,\n\t                            headers: _this2.createHeaders(eventData.response.headers),\n\t                            statusCode: statusCode,\n\t                            statusMessage: eventData.response.statusText,\n\t                            endTime: (0, _DateTimeUtilities.getDateTime)(new Date(event.timeStamp)),\n\t                            duration: responseEnd,\n\t                            timing: {\n\t                                startTime: startTime,\n\t                                responseEnd: responseEnd\n\t                            },\n\t                            body: body\n\t                        });\n\t                        if (responseStart !== undefined) {\n\t                            msg.payload.timing.responseStart = responseStart;\n\t                        }\n\t                        (0, _MessageMixins.addOffset)(offset, msg);\n\t                        _this2.messagePublisher.publishMessage(msg);\n\t                    });\n\t                });\n\t            });\n\t        }\n\t    }, {\n\t        key: 'numOutstandingRequests',\n\t        value: function numOutstandingRequests() {\n\t            return Object.keys(this.requests).length;\n\t        }\n\t    }, {\n\t        key: 'init',\n\t        value: function init(messagePublisher) {\n\t            var _this3 = this;\n\t\n\t            this.messagePublisher = messagePublisher;\n\t            _Tracing2['default'].on(_FetchProxy.EVENT_FETCH_REQUEST_SENT, function (event) {\n\t                _this3.requests[event.data.id] = {\n\t                    startTimeStamp: event.timeStamp,\n\t                    startTimeOffset: event.offset\n\t                };\n\t                _this3.before(event);\n\t            });\n\t            _Tracing2['default'].on(_FetchProxy.EVENT_FETCH_RESPONSE_RECEIVED, function (event) {\n\t                var requestEntry = _this3.requests[event.data.id];\n\t                if (!requestEntry) {\n\t                    _GlimpseLogger2['default'].error('Glimpse Internal Error: could not find associated master data, some inspection data will be lost.');\n\t                    return;\n\t                }\n\t                _this3.after(event, requestEntry);\n\t                delete _this3.requests[event.data.id];\n\t            });\n\t            _Tracing2['default'].on(_FetchProxy.EVENT_FETCH_ERROR, function (data) {\n\t                delete _this3.requests[data.data.id];\n\t            });\n\t        }\n\t    }]);\n\n\t    return FetchInspector;\n\t}();\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.FetchProxy = exports.EVENT_FETCH_ERROR = exports.EVENT_FETCH_RESPONSE_RECEIVED = exports.EVENT_FETCH_REQUEST_SENT = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _Tracing = __webpack_require__(11);\n\t\n\tvar _Tracing2 = _interopRequireDefault(_Tracing);\n\t\n\tvar _GeneralUtilities = __webpack_require__(4);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar EVENT_FETCH_REQUEST_SENT = exports.EVENT_FETCH_REQUEST_SENT = 'invoke|pre|fetch.request-sent';\n\tvar EVENT_FETCH_RESPONSE_RECEIVED = exports.EVENT_FETCH_RESPONSE_RECEIVED = 'notify|fetch.response-received';\n\tvar EVENT_FETCH_ERROR = exports.EVENT_FETCH_ERROR = 'notify|fetch.error';\n\t/**\n\t * Proxy which wraps fetch usage and its various supporting functions.\n\t *\n\t * NOTE: Don't add any headers within this proxy, breaks CORS scenarioes.\n\t */\n\t\n\tvar FetchProxy = exports.FetchProxy = function () {\n\t    function FetchProxy() {\n\t        _classCallCheck(this, FetchProxy);\n\t    }\n\t\n\t    _createClass(FetchProxy, [{\n\t        key: 'isSupported',\n\t        value: function isSupported() {\n\t            return !!(self && typeof self.fetch !== 'undefined');\n\t        }\n\t    }, {\n\t        key: 'init',\n\t        value: function init() {\n\t            // Note: we use `self` instead of `window` in case we're in a worker thread\n\t            // See https://developer.mozilla.org/en-US/docs/Web/API/Window/self\n\t            // Only initialize if this browser supports the Fetch API\n\t            if (self.fetch) {\n\t                var oldFetch = self.fetch;\n\t                self.fetch = function fetch(input, init) {\n\t                    // Create a request object if one wasn't specified, or clone the\n\t                    // existing one if it was so we can safely read the body.\n\t                    var request = void 0;\n\t\n\t                    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n\t                        args[_key - 2] = arguments[_key];\n\t                    }\n\t\n\t                    if (input instanceof Request) {\n\t                        request = input.clone();\n\t                    } else {\n\t                        // OK, so I know this looks weird, but the use of Promises\n\t                        // here provides a unique challenge. If you instantiate a\n\t                        // Request object directly, it will throw an exception if the\n\t                        // input is malformed. However, the `fetch()` API is wrapped\n\t                        // in a promise, which means malformed input does _not_ throw\n\t                        // when passed to `fetch()`. Instead it causes the promise to\n\t                        // reject. We do _not_ want to pick up on this case though,\n\t                        // because we would otherwise publish an ERROR_EVENT, which\n\t                        // we do _not_ want in this case. So we detect malformed input,\n\t                        // and return the promise directly without listening to it.\n\t                        try {\n\t                            request = new Request(input, init);\n\t                        } catch (e) {\n\t                            return oldFetch.call.apply(oldFetch, [this, input, init].concat(args));\n\t                        }\n\t                    }\n\t                    var id = (0, _GeneralUtilities.getGuid)();\n\t                    // Publish the request message\n\t                    var requestSentEventData = {\n\t                        id: id,\n\t                        request: request\n\t                    };\n\t                    _Tracing2['default'].publish(EVENT_FETCH_REQUEST_SENT, requestSentEventData);\n\t                    // Call the original fetch method. We wait for the response to be\n\t                    // received using the promise, and publish the resulting\n\t                    var fetchPromise = oldFetch.call.apply(oldFetch, [this, input, init].concat(args));\n\t                    fetchPromise.then(function (response) {\n\t                        var responseReceivedEventData = {\n\t                            id: id,\n\t                            response: response.clone()\n\t                        };\n\t                        _Tracing2['default'].publish(EVENT_FETCH_RESPONSE_RECEIVED, responseReceivedEventData);\n\t                    }, function (error) {\n\t                        var errorEventData = {\n\t                            id: id,\n\t                            error: error\n\t                        };\n\t                        _Tracing2['default'].publish(EVENT_FETCH_ERROR, errorEventData);\n\t                    });\n\t                    return fetchPromise;\n\t                };\n\t            }\n\t        }\n\t    }]);\n\n\t    return FetchProxy;\n\t}();\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.ResourceTimingInspector = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _ResourceTimingProxy = __webpack_require__(24);\n\t\n\tvar _Tracing = __webpack_require__(11);\n\t\n\tvar _Tracing2 = _interopRequireDefault(_Tracing);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar ResourceTimingInspector = exports.ResourceTimingInspector = function () {\n\t    function ResourceTimingInspector() {\n\t        _classCallCheck(this, ResourceTimingInspector);\n\t    }\n\t\n\t    _createClass(ResourceTimingInspector, [{\n\t        key: 'init',\n\t        value: function init(messagePublisher) {\n\t            _Tracing2['default'].on(_ResourceTimingProxy.EVENT_RESOURCE_TIMING_COLLECTED, function (event) {\n\t                // TODO: Eventually, we'll add more logic here to clean up data in\n\t                // https://github.com/Glimpse/Glimpse.Browser.Agent/issues/29.\n\t                messagePublisher.createAndPublishMessage('browser-resource', {\n\t                    timings: event.data\n\t                });\n\t            });\n\t        }\n\t    }]);\n\n\t    return ResourceTimingInspector;\n\t}();\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.ResourceTimingProxy = exports.EVENT_RESOURCE_TIMING_COLLECTED = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _Tracing = __webpack_require__(11);\n\t\n\tvar _Tracing2 = _interopRequireDefault(_Tracing);\n\t\n\tvar _RequestUtilities = __webpack_require__(5);\n\t\n\tvar _PerformanceUtilities = __webpack_require__(25);\n\t\n\tvar _PerformanceUtilities2 = _interopRequireDefault(_PerformanceUtilities);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar UPDATE_INTERVAL = 1000;\n\tvar EVENT_RESOURCE_TIMING_COLLECTED = exports.EVENT_RESOURCE_TIMING_COLLECTED = 'notify|performance.resource-collected';\n\t\n\tvar ResourceTimingProxy = exports.ResourceTimingProxy = function () {\n\t    function ResourceTimingProxy() {\n\t        _classCallCheck(this, ResourceTimingProxy);\n\t    }\n\t\n\t    _createClass(ResourceTimingProxy, [{\n\t        key: 'isSupported',\n\t        value: function isSupported() {\n\t            // Don't initialize if this browser doesn't support resource timing\n\t            return !!(_PerformanceUtilities2['default'] && _PerformanceUtilities2['default'].getEntriesByType);\n\t        }\n\t    }, {\n\t        key: 'init',\n\t        value: function init() {\n\t            function processEntry(entry) {\n\t                // This sheds any extra properties that may be introduced to resource timing\n\t                // or are browser specific, and ensures the data matches our interface for it.\n\t                return {\n\t                    name: entry.name,\n\t                    startTime: entry.startTime,\n\t                    duration: entry.duration,\n\t                    initiatorType: entry.initiatorType,\n\t                    nextHopProtocol: entry.nextHopProtocol,\n\t                    redirectStart: entry.redirectStart,\n\t                    redirectEnd: entry.redirectEnd,\n\t                    fetchStart: entry.fetchStart,\n\t                    domainLookupStart: entry.domainLookupStart,\n\t                    domainLookupEnd: entry.domainLookupEnd,\n\t                    connectStart: entry.connectStart,\n\t                    connectEnd: entry.connectEnd,\n\t                    secureConnectionStart: entry.secureConnectionStart,\n\t                    requestStart: entry.requestStart,\n\t                    responseStart: entry.responseStart,\n\t                    responseEnd: entry.responseEnd,\n\t                    transferSize: entry.transferSize,\n\t                    encodedBodySize: entry.encodedBodySize,\n\t                    decodedBodySize: entry.decodedBodySize\n\t                };\n\t            }\n\t            // Eventually we want to switch to using Performance Observers once browsers\n\t            // start to implement, but currently none do, so we poll for entries instead\n\t            // https://w3c.github.io/performance-timeline/#dom-performanceobserver\n\t            var reportedEntries = {};\n\t            function record() {\n\t                var resources = _PerformanceUtilities2['default'].getEntriesByType('resource');\n\t                var entriesToPublish = [];\n\t                var ingressUrl = (0, _RequestUtilities.getMessageIngressUrl)();\n\t                var _iteratorNormalCompletion = true;\n\t                var _didIteratorError = false;\n\t                var _iteratorError = undefined;\n\t\n\t                try {\n\t                    for (var _iterator = resources[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t                        var resource = _step.value;\n\t\n\t                        // Create a unique id for the entry, a combination of the start time\n\t                        // and resolved URL\n\t                        var id = resource.startTime + '#' + resource.name;\n\t                        if (!reportedEntries[id] && resource.name.indexOf(ingressUrl) === -1) {\n\t                            reportedEntries[id] = true;\n\t                            entriesToPublish.push(processEntry(resource));\n\t                        }\n\t                    }\n\t                } catch (err) {\n\t                    _didIteratorError = true;\n\t                    _iteratorError = err;\n\t                } finally {\n\t                    try {\n\t                        if (!_iteratorNormalCompletion && _iterator['return']) {\n\t                            _iterator['return']();\n\t                        }\n\t                    } finally {\n\t                        if (_didIteratorError) {\n\t                            throw _iteratorError;\n\t                        }\n\t                    }\n\t                }\n\t\n\t                if (entriesToPublish.length) {\n\t                    _Tracing2['default'].publish(EVENT_RESOURCE_TIMING_COLLECTED, entriesToPublish);\n\t                }\n\t                setTimeout(record, UPDATE_INTERVAL);\n\t            }\n\t            ;\n\t            record();\n\t        }\n\t    }]);\n\n\t    return ResourceTimingProxy;\n\t}();\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\tfunction getPerformance() {\n\t    // tslint:disable:no-any\n\t    return window.performance || window.webkitPerformance || window.msPerformance || window.mozPerformance;\n\t}\n\texports[\"default\"] = getPerformance();\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.NavigationTimingInspector = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _NavigationTimingProxy = __webpack_require__(27);\n\t\n\tvar _Tracing = __webpack_require__(11);\n\t\n\tvar _Tracing2 = _interopRequireDefault(_Tracing);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar NavigationTimingInspector = exports.NavigationTimingInspector = function () {\n\t    function NavigationTimingInspector() {\n\t        _classCallCheck(this, NavigationTimingInspector);\n\t    }\n\t\n\t    _createClass(NavigationTimingInspector, [{\n\t        key: 'init',\n\t        value: function init(messagePublisher) {\n\t            _Tracing2['default'].on(_NavigationTimingProxy.EVENT_NAVIGATION_TIMING_COLLECTED, function (event) {\n\t                var data = event.data;\n\t                var message = Object.assign({ loadDuration: data.loadEventEnd - data.fetchStart,\n\t                    // time spent constructing the DOM tree\n\t                    domReadyDuration: data.domComplete - data.domInteractive,\n\t                    // time consumed preparing the new page\n\t                    readyStartDuration: data.fetchStart - data.navigationStart,\n\t                    // time spent during redirection\n\t                    redirectDuration: data.redirectEnd - data.redirectStart,\n\t                    // appCache\n\t                    appcacheDuration: data.domainLookupStart - data.fetchStart,\n\t                    // time spent unloading documents\n\t                    unloadEventDuration: data.unloadEventEnd - data.unloadEventStart,\n\t                    // DNS query time\n\t                    lookupDomainDuration: data.domainLookupEnd - data.domainLookupStart,\n\t                    // TCP connection time\n\t                    connectDuration: data.connectEnd - data.connectStart,\n\t                    // time spent during the request\n\t                    requestDuration: data.responseEnd - data.requestStart,\n\t                    // request to completion of the DOM loading\n\t                    initDomTreeDuration: data.domInteractive - data.responseEnd,\n\t                    // load event time\n\t                    loadEventDuration: data.loadEventEnd - data.loadEventStart,\n\t                    // time spent on the network making the outgoing request\n\t                    networkRequestDuration: data.requestStart - data.navigationStart,\n\t                    // time spent on the network receiving the incoming response\n\t                    networkResponseDuration: data.responseEnd - data.responseStart,\n\t                    // time spent on the server processing the request\n\t                    serverDuration: data.responseEnd - data.requestStart,\n\t                    // time spent on the browser handling the response\n\t                    browserDuration: data.loadEventEnd - data.responseStart,\n\t                    // total time\n\t                    totalDuration: data.loadEventEnd - data.navigationStart }, event.data);\n\t                // time spent on the network for the whole request/response\n\t                message.networkDuration = message.networkRequestDuration + message.networkResponseDuration;\n\t                // TODO: Eventually, we'll add more logic here to clean up data in\n\t                // https://github.com/Glimpse/Glimpse.Browser.Agent/issues/29.\n\t                messagePublisher.createAndPublishMessage('browser-navigation-timing', message);\n\t            });\n\t        }\n\t    }]);\n\n\t    return NavigationTimingInspector;\n\t}();\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.NavigationTimingProxy = exports.EVENT_NAVIGATION_TIMING_COLLECTED = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _Tracing = __webpack_require__(11);\n\t\n\tvar _Tracing2 = _interopRequireDefault(_Tracing);\n\t\n\tvar _PerformanceUtilities = __webpack_require__(25);\n\t\n\tvar _PerformanceUtilities2 = _interopRequireDefault(_PerformanceUtilities);\n\t\n\tvar _RequestUtilities = __webpack_require__(5);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar EVENT_NAVIGATION_TIMING_COLLECTED = exports.EVENT_NAVIGATION_TIMING_COLLECTED = 'notify|performance.navigation-timing';\n\t\n\tvar NavigationTimingProxy = exports.NavigationTimingProxy = function () {\n\t    function NavigationTimingProxy() {\n\t        _classCallCheck(this, NavigationTimingProxy);\n\t    }\n\t\n\t    _createClass(NavigationTimingProxy, [{\n\t        key: 'isSupported',\n\t        value: function isSupported() {\n\t            return !!(_PerformanceUtilities2['default'] && _PerformanceUtilities2['default'].timing);\n\t        }\n\t    }, {\n\t        key: 'init',\n\t        value: function init() {\n\t            var _this = this;\n\t\n\t            // setup/regiter strategy to run later\n\t            (0, _RequestUtilities.addEvent)(window, 'load', function () {\n\t                setTimeout(function () {\n\t                    _this.processTimings(_PerformanceUtilities2['default'].timing);\n\t                });\n\t            });\n\t        }\n\t    }, {\n\t        key: 'processEntry',\n\t        value: function processEntry(entry) {\n\t            // This sheds any extra properties that may be introduced to navigation\n\t            // timing or are browser specific, and ensures the data matches our\n\t            // interface for it.\n\t            return {\n\t                connectEnd: entry.connectEnd,\n\t                connectStart: entry.connectStart,\n\t                domComplete: entry.domComplete,\n\t                domContentLoadedEventEnd: entry.domContentLoadedEventEnd,\n\t                domContentLoadedEventStart: entry.domContentLoadedEventStart,\n\t                domInteractive: entry.domInteractive,\n\t                domLoading: entry.domLoading,\n\t                domainLookupEnd: entry.domainLookupEnd,\n\t                domainLookupStart: entry.domainLookupStart,\n\t                fetchStart: entry.fetchStart,\n\t                firstPaint: entry.firstPaint,\n\t                firstPaintDuration: 0,\n\t                loadEventEnd: entry.loadEventEnd,\n\t                loadEventStart: entry.loadEventStart,\n\t                navigationStart: entry.navigationStart,\n\t                redirectEnd: entry.redirectEnd,\n\t                redirectStart: entry.redirectStart,\n\t                requestStart: entry.requestStart,\n\t                responseEnd: entry.responseEnd,\n\t                responseStart: entry.responseStart,\n\t                secureConnectionStart: entry.secureConnectionStart,\n\t                unloadEventEnd: entry.unloadEventEnd,\n\t                unloadEventStart: entry.unloadEventStart\n\t            };\n\t        }\n\t    }, {\n\t        key: 'processTimings',\n\t        value: function processTimings(timing) {\n\t            var eventData = this.processEntry(timing);\n\t            // time to first paint\n\t            // tslint:disable-next-line:no-any\n\t            if (eventData.firstPaint === undefined) {\n\t                // All times are relative times to the start time within the\n\t                // same objects\n\t                var firstPaint = 0;\n\t                var firstPaintDuration = 0;\n\t                //tslint:disable-next-line:no-any\n\t                if (window.chrome && window.chrome.loadTimes) {\n\t                    //tslint:disable-next-line:no-any\n\t                    var loadTimes = window.chrome.loadTimes();\n\t                    firstPaint = loadTimes.firstPaintTime * 1000;\n\t                    firstPaintDuration = firstPaint - loadTimes.startLoadTime * 1000;\n\t                } else if (typeof timing.msFirstPaint === 'number') {\n\t                    firstPaint = timing.msFirstPaint;\n\t                    firstPaintDuration = firstPaint - timing.navigationStart;\n\t                }\n\t                eventData.firstPaint = firstPaint;\n\t                eventData.firstPaintDuration = firstPaintDuration;\n\t            }\n\t            _Tracing2['default'].publish(EVENT_NAVIGATION_TIMING_COLLECTED, eventData);\n\t        }\n\t    }]);\n\n\t    return NavigationTimingProxy;\n\t}();\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.ConsoleInspector = exports.LogMessageTypes = undefined;\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _ConsoleProxy = __webpack_require__(29);\n\t\n\tvar _Tracing = __webpack_require__(11);\n\t\n\tvar _Tracing2 = _interopRequireDefault(_Tracing);\n\t\n\tvar _GeneralUtilities = __webpack_require__(4);\n\t\n\tvar _MessageMixins = __webpack_require__(6);\n\t\n\tvar _CallStackUtilities = __webpack_require__(18);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar LogMessageTypes = exports.LogMessageTypes = undefined;\n\t(function (LogMessageTypes) {\n\t    LogMessageTypes[LogMessageTypes[\"json\"] = 0] = \"json\";\n\t    LogMessageTypes[LogMessageTypes[\"xml\"] = 1] = \"xml\";\n\t    LogMessageTypes[LogMessageTypes[\"table\"] = 2] = \"table\";\n\t    LogMessageTypes[LogMessageTypes[\"assert\"] = 3] = \"assert\";\n\t    LogMessageTypes[LogMessageTypes[\"count\"] = 4] = \"count\";\n\t    LogMessageTypes[LogMessageTypes[\"timespan_begin\"] = 5] = \"timespan_begin\";\n\t    LogMessageTypes[LogMessageTypes[\"timespan_end\"] = 6] = \"timespan_end\";\n\t    LogMessageTypes[LogMessageTypes[\"group_begin\"] = 7] = \"group_begin\";\n\t    LogMessageTypes[LogMessageTypes[\"group_end\"] = 8] = \"group_end\";\n\t})(LogMessageTypes || (exports.LogMessageTypes = LogMessageTypes = {}));\n\t\n\tvar ConsoleInspector = exports.ConsoleInspector = function () {\n\t    function ConsoleInspector() {\n\t        var _this = this;\n\t\n\t        _classCallCheck(this, ConsoleInspector);\n\t\n\t        this.countMap = {};\n\t        this.stack = {\n\t            group: [],\n\t            profile: []\n\t        };\n\t        this.map = {\n\t            time: {}\n\t        };\n\t        this.mapNull = {\n\t            time: undefined\n\t        };\n\t        this.methods = {\n\t            assert: {\n\t                level: 'Error',\n\t                processor: function processor(message, data) {\n\t                    return _this.assert(message, data);\n\t                }\n\t            },\n\t            count: {\n\t                level: 'Debug',\n\t                processor: function processor(message, data) {\n\t                    return _this.count(message, data);\n\t                },\n\t                tokenTypeByPass: true\n\t            },\n\t            debug: {\n\t                level: 'Debug',\n\t                nullByPass: true\n\t            },\n\t            dir: {\n\t                level: 'Log',\n\t                nullByPass: true,\n\t                processor: function processor(message, data) {\n\t                    return _this.dir(message, data, LogMessageTypes.json);\n\t                },\n\t                tokenTypeByPass: true\n\t            },\n\t            dirxml: {\n\t                level: 'Log',\n\t                nullByPass: true,\n\t                processor: function processor(message, data) {\n\t                    return _this.dir(message, data, LogMessageTypes.xml);\n\t                },\n\t                tokenTypeByPass: true\n\t            },\n\t            error: {\n\t                level: 'Error',\n\t                nullByPass: true\n\t            },\n\t            group: {\n\t                level: undefined,\n\t                processor: function processor(message, data) {\n\t                    return _this.groupStart(message, data, false);\n\t                }\n\t            },\n\t            groupCollapsed: {\n\t                level: undefined,\n\t                processor: function processor(message, data) {\n\t                    return _this.groupStart(message, data, true);\n\t                }\n\t            },\n\t            groupEnd: {\n\t                level: undefined,\n\t                processor: function processor(message, data) {\n\t                    return _this.groupEnd(message, data);\n\t                }\n\t            },\n\t            info: {\n\t                level: 'Info',\n\t                nullByPass: true\n\t            },\n\t            log: {\n\t                level: 'Log',\n\t                nullByPass: true\n\t            },\n\t            profile: {\n\t                level: 'Debug',\n\t                processor: function processor(message, data) {\n\t                    return _this.profileStart(message, data);\n\t                },\n\t                tokenTypeByPass: true\n\t            },\n\t            profileEnd: {\n\t                level: 'Debug',\n\t                processor: function processor(message, data) {\n\t                    return _this.profileEnd(message, data);\n\t                },\n\t                tokenTypeByPass: true\n\t            },\n\t            table: {\n\t                level: 'Log',\n\t                nullByPass: true,\n\t                processor: function processor(message, data) {\n\t                    return _this.applyType(message, data, LogMessageTypes.table);\n\t                },\n\t                tokenTypeByPass: true\n\t            },\n\t            time: {\n\t                level: 'Debug',\n\t                processor: function processor(message, data) {\n\t                    return _this.mapStart('time', message, data, LogMessageTypes.timespan_begin);\n\t                },\n\t                tokenTypeByPass: true\n\t            },\n\t            timeEnd: {\n\t                level: 'Debug',\n\t                processor: function processor(message, data) {\n\t                    return _this.mapEnd('time', message, data, LogMessageTypes.timespan_end);\n\t                },\n\t                tokenTypeByPass: true\n\t            },\n\t            timeStamp: {\n\t                level: 'Debug',\n\t                processor: function processor(message, data) {\n\t                    return _this.timeStamp(message, data);\n\t                },\n\t                tokenTypeByPass: true\n\t            },\n\t            trace: {\n\t                level: 'Debug',\n\t                processor: function processor(message, data) {\n\t                    return _this.trace(message, data);\n\t                }\n\t            },\n\t            warn: {\n\t                level: 'Warning',\n\t                nullByPass: true\n\t            }\n\t        };\n\t    }\n\t\n\t    _createClass(ConsoleInspector, [{\n\t        key: 'init',\n\t        value: function init(messagePublisher) {\n\t            var _this2 = this;\n\t\n\t            _Tracing2['default'].on(_ConsoleProxy.NOTIFY_CONSOLE_EVENT_OCCURED, function (event) {\n\t                var data = event.data;\n\t                var payload = {\n\t                    method: data.method,\n\t                    arguments: data.arguments,\n\t                    offset: event.offset\n\t                };\n\t                _this2.publishMessage(messagePublisher, payload);\n\t            });\n\t        }\n\t    }, {\n\t        key: 'publishMessage',\n\t        value: function publishMessage(messagePublisher, data) {\n\t            var info = this.methods[data.method];\n\t            // in the case where we have no args or a nullByPass is in effect then we shouldn't log messages\n\t            if (!data.arguments || data.arguments.constructor !== Array || info.nullByPass && data.arguments.length === 0) {\n\t                return;\n\t            }\n\t            // build base message\n\t            var payload = {\n\t                message: data.arguments,\n\t                library: 'Browser Console',\n\t                level: info.level\n\t            };\n\t            var message = messagePublisher.createMessage('log-write', payload);\n\t            (0, _MessageMixins.addOffset)(data.offset, message);\n\t            // run through any custom processors\n\t            var suppressMessage = false;\n\t            if (info.processor) {\n\t                suppressMessage = info.processor(message, data) || false;\n\t            }\n\t            // normalize token format\n\t            if (!info.tokenTypeByPass) {\n\t                this.deriveTokenType(message);\n\t            }\n\t            if (!suppressMessage) {\n\t                (0, _CallStackUtilities.getStackTrace)(function (frames) {\n\t                    message.payload.frames = frames;\n\t                    message.types.push('call-stack');\n\t                    messagePublisher.publishMessage(message);\n\t                });\n\t            }\n\t        }\n\t        // api specific targets\n\t\n\t    }, {\n\t        key: 'count',\n\t        value: function count(message, data) {\n\t            // chrome treats no args the same as ''\n\t            var label = data.arguments.length > 0 ? String(data.arguments[0]) : '';\n\t            // for record the label\n\t            message.payload.message = label;\n\t            // track ongoing progress\n\t            var currentCount = (this.countMap[label] || 0) + 1;\n\t            this.countMap[label] = currentCount;\n\t            // record the applyType\n\t            this.applyType(message, data, LogMessageTypes.count);\n\t            // record the addition count data\n\t            message.payload.count = currentCount;\n\t        }\n\t    }, {\n\t        key: 'assert',\n\t        value: function assert(message, data) {\n\t            var assertion = data.arguments.length > 0 ? data.arguments[0] : false;\n\t            // if we have no args|null|undefined|0 we will treat it as a fail\n\t            if (assertion) {\n\t                return true;\n\t            } else {\n\t                message.payload.message = message.payload.message.slice(1);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'dir',\n\t        value: function dir(message, data, type) {\n\t            var newArgs = data.arguments.length > 0 ? [data.arguments[0]] : data.arguments; // tslint:disable-line:no-any\n\t            var processAsDir = false;\n\t            var value = newArgs[0];\n\t            if (type === LogMessageTypes.xml && value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.getElementsByTagName && 'outerHTML' in value) {\n\t                var nodeCount = value.getElementsByTagName('*').length;\n\t                // Safety checks to deal with large data payloads\n\t                if (nodeCount > 100) {\n\t                    newArgs = 'Node with more than `100` decendents aren\\'t supported.';\n\t                } else {\n\t                    value = value.outerHTML;\n\t                    if (value.length > 2500) {\n\t                        newArgs = 'Node with more than `2500` characters aren\\'t supported.';\n\t                    } else {\n\t                        newArgs[0] = value;\n\t                    }\n\t                }\n\t                processAsDir = true;\n\t            } else if (type === LogMessageTypes.json) {\n\t                processAsDir = true;\n\t            }\n\t            // this is setup this way so that in non valid `LogMessageTypes.xml` cases, we essentually\n\t            // treat it as plain console.log\n\t            if (processAsDir) {\n\t                // we only care about the first arg in this case\n\t                message.payload.message = newArgs;\n\t                this.applyType(message, data, type);\n\t            } else {\n\t                this.deriveTokenType(message);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'timeStamp',\n\t        value: function timeStamp(message, data) {\n\t            this.getAndApplyLabel(message, data);\n\t        }\n\t    }, {\n\t        key: 'groupStart',\n\t        value: function groupStart(message, data, isCollapsed) {\n\t            message.payload.isCollapsed = isCollapsed;\n\t            this.stackStart('group', message, data, LogMessageTypes.group_begin);\n\t        }\n\t    }, {\n\t        key: 'groupEnd',\n\t        value: function groupEnd(message, data) {\n\t            return this.stackEnd('group', message, data, LogMessageTypes.group_end);\n\t        }\n\t    }, {\n\t        key: 'profileStart',\n\t        value: function profileStart(message, data) {\n\t            this.getAndApplyLabel(message, data);\n\t            this.stackStart('profile', message, data, LogMessageTypes.timespan_begin);\n\t        }\n\t    }, {\n\t        key: 'profileEnd',\n\t        value: function profileEnd(message, data) {\n\t            this.getAndApplyLabel(message, data);\n\t            var result = this.stackEnd('profile', message, data, LogMessageTypes.timespan_end);\n\t            return result;\n\t        }\n\t    }, {\n\t        key: 'trace',\n\t        value: function trace(message, data) {\n\t            // for trace methods include 'log-display-callstack' message type so callstack will be displayed\n\t            message.types.push('log-display-callstack');\n\t            // make a copy of the message since we're going to modify it.\n\t            message.payload.message = Array.prototype.slice.call(message.payload.message, 0);\n\t            if (message.payload.message[0] === undefined) {\n\t                message.payload.message[0] = 'Trace:';\n\t            } else {\n\t                message.payload.message[0] = 'Trace: ' + message.payload.message[0];\n\t            }\n\t        }\n\t        // common/shared helpers\n\t\n\t    }, {\n\t        key: 'applyType',\n\t        value: function applyType(message, data, mixin) {\n\t            var type = LogMessageTypes[mixin].replace('_', '-');\n\t            message.types.push('log-' + type);\n\t        }\n\t    }, {\n\t        key: 'getAndApplyLabel',\n\t        value: function getAndApplyLabel(message, data) {\n\t            var label = data.arguments.length > 0 ? String(data.arguments[0]) : undefined;\n\t            // for mapEnds we dump the args and just use the label\n\t            message.payload.message = label;\n\t            return label;\n\t        }\n\t    }, {\n\t        key: 'stackStart',\n\t        value: function stackStart(type, message, data, mixin) {\n\t            var group = this.coreStart(message, data, mixin);\n\t            this.stack[type].push(group);\n\t        }\n\t    }, {\n\t        key: 'stackEnd',\n\t        value: function stackEnd(type, message, data, mixin) {\n\t            var group = this.stack[type].pop();\n\t            if (group) {\n\t                this.coreEnd(group, message, data, mixin);\n\t            } else {\n\t                return true;\n\t            }\n\t        }\n\t    }, {\n\t        key: 'mapStart',\n\t        value: function mapStart(type, message, data, mixin) {\n\t            var label = this.getAndApplyLabel(message, data);\n\t            var group = this.coreStart(message, data, mixin);\n\t            if (label !== undefined) {\n\t                this.map[type][label] = group;\n\t            } else {\n\t                this.mapNull[type] = group;\n\t            }\n\t        }\n\t    }, {\n\t        key: 'mapEnd',\n\t        value: function mapEnd(type, message, data, mixin) {\n\t            var label = this.getAndApplyLabel(message, data);\n\t            var group = label !== undefined ? this.map[type][label] : this.mapNull[type];\n\t            if (group) {\n\t                if (label !== undefined) {\n\t                    delete this.map[type][label];\n\t                } else {\n\t                    this.mapNull[type] = undefined;\n\t                }\n\t            } else {\n\t                // if no match is found we should match to page load\n\t                group = { correlationId: (0, _GeneralUtilities.getGuid)(), time: 0 };\n\t            }\n\t            this.coreEnd(group, message, data, mixin);\n\t        }\n\t    }, {\n\t        key: 'coreStart',\n\t        value: function coreStart(message, data, mixin) {\n\t            var correlationId = (0, _GeneralUtilities.getGuid)();\n\t            var time = data.offset;\n\t            (0, _MessageMixins.addCorrelationBegin)(correlationId, message);\n\t            // add action begin specific data\n\t            this.applyType(message, data, mixin);\n\t            return {\n\t                correlationId: correlationId,\n\t                time: time\n\t            };\n\t        }\n\t    }, {\n\t        key: 'coreEnd',\n\t        value: function coreEnd(group, message, data, mixin) {\n\t            var time = data.offset;\n\t            // add action begin specific data\n\t            this.applyType(message, data, mixin);\n\t            (0, _MessageMixins.addCorrelationEnd)(group.correlationId, time - group.time, message);\n\t        }\n\t    }, {\n\t        key: 'deriveTokenType',\n\t        value: function deriveTokenType(message) {\n\t            if (message.payload.message !== undefined && message.payload.message !== null // tslint:disable-line:no-null-keyword\n\t            && message.payload.message !== 'string') {\n\t                message.types.push('log-token-printf');\n\t                message.payload.tokenSupport = 'browser';\n\t            }\n\t        }\n\t    }]);\n\n\t    return ConsoleInspector;\n\t}();\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.ConsoleProxy = exports.NOTIFY_CONSOLE_EVENT_OCCURED = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _Tracing = __webpack_require__(11);\n\t\n\tvar _Tracing2 = _interopRequireDefault(_Tracing);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar NOTIFY_CONSOLE_EVENT_OCCURED = exports.NOTIFY_CONSOLE_EVENT_OCCURED = 'notify|event|console';\n\t// tslint:disable-line:no-any\n\t\n\tvar ConsoleProxy = exports.ConsoleProxy = function () {\n\t    function ConsoleProxy() {\n\t        _classCallCheck(this, ConsoleProxy);\n\t\n\t        // NOTE: this should probably be pulled from the inspector,\n\t        //       but that raising a dependency question and whether\n\t        //       one should know about the other. Was thinking about\n\t        //       adding a neutral party but thats overkill.\n\t        this.methods = ['assert', 'count', 'debug', 'dir', 'dirxml', 'error', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log', 'profile', 'profileEnd', 'table', 'time', 'timeEnd', 'timeStamp', 'trace', 'warn'];\n\t    }\n\t\n\t    _createClass(ConsoleProxy, [{\n\t        key: 'isSupported',\n\t        value: function isSupported() {\n\t            // IE9 and older throws an exception if we try and write a value to\n\t            // an undefined preoprty on console methods, so we test here if we\n\t            // can write to `console.log`, and if not return not supported\n\t            try {\n\t                // tslint:disable-next-line:no-any\n\t                console.log.__glimpse_enabled = true;\n\t                // tslint:disable-next-line:no-any\n\t                delete console.log.__glimpse_enabled;\n\t            } catch (e) {\n\t                return false;\n\t            }\n\t            return !!(window && typeof window.console !== 'undefined');\n\t        }\n\t    }, {\n\t        key: 'init',\n\t        value: function init() {\n\t            this.methods.forEach(function (methodKey) {\n\t                if (methodKey && console[methodKey] && !console[methodKey].__glimpse_original) {\n\t                    console[methodKey] = function (key) {\n\t                        var oldFunction = console[key];\n\t                        var newFunction = function newFunction() {\n\t                            var args = Array.prototype.slice.call(arguments);\n\t                            _Tracing2['default'].publish(NOTIFY_CONSOLE_EVENT_OCCURED, { method: key, arguments: args });\n\t                            return oldFunction.apply(this, arguments);\n\t                        };\n\t                        oldFunction.__glimpse_proxy = newFunction;\n\t                        newFunction.__glimpse_original = oldFunction;\n\t                        return newFunction;\n\t                    }(methodKey);\n\t                }\n\t            });\n\t        }\n\t    }]);\n\n\t    return ConsoleProxy;\n\t}();\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.PerformanceInspector = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _Tracing = __webpack_require__(11);\n\t\n\tvar _Tracing2 = _interopRequireDefault(_Tracing);\n\t\n\tvar _PerformanceProxy = __webpack_require__(31);\n\t\n\tvar _MessageMixins = __webpack_require__(6);\n\t\n\tvar _CallStackUtilities = __webpack_require__(18);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar PerformanceInspector = exports.PerformanceInspector = function () {\n\t    function PerformanceInspector() {\n\t        _classCallCheck(this, PerformanceInspector);\n\t\n\t        this.markIdCache = {};\n\t    }\n\t\n\t    _createClass(PerformanceInspector, [{\n\t        key: 'init',\n\t        value: function init(messagePublisher) {\n\t            var _this = this;\n\t\n\t            this.messagePublisher = messagePublisher;\n\t            _Tracing2['default'].on(_PerformanceProxy.EVENT_PERFORMANCE_MARK, function (data) {\n\t                return _this.mark(data);\n\t            });\n\t            _Tracing2['default'].on(_PerformanceProxy.EVENT_PERFORMANCE_MEASURE, function (data) {\n\t                return _this.measure(data);\n\t            });\n\t        }\n\t    }, {\n\t        key: 'mark',\n\t        value: function mark(data) {\n\t            var _this2 = this;\n\t\n\t            var eventData = data.data;\n\t            var message = this.messagePublisher.createMessage('debug-timestamp', {\n\t                name: eventData.name\n\t            });\n\t            // Save the internal ID <> message ID correlation for lookup in measure\n\t            // events. We do this two stage caching level so that proxies don't need\n\t            // to know anything about the details of how message IDs work.\n\t            this.markIdCache[eventData.id] = message.id;\n\t            // Override the message offset directly. We override it manually instead\n\t            // of using `addOffset` because that method adjust the offset we pass to\n\t            // be relative to `performance.timing.requestStart - performance.timing.fetchStart`\n\t            // however the offsets we receive here are from performance.timing, so they\n\t            // are already relative to the proper time, and so shouldn't be adjusted\n\t            message.offset = eventData.startTime;\n\t            // If the mark is a built-in mark, then we skip collecting the stack trace\n\t            // because there is no actual stack trace associated with the mark\n\t            if (eventData.isBuiltIn) {\n\t                // Wrap the publish in a set timeout to make the asynchronicity\n\t                // of this method consistent across different event configurations\n\t                setTimeout(function () {\n\t                    return _this2.messagePublisher.publishMessage(message);\n\t                }, 0);\n\t            } else {\n\t                // We create the message first, and add frames later, to ensure that\n\t                // the mark ID cache is filled and waiting when `performance.measure`\n\t                // is called, which may occur before the getStackTrace callback is\n\t                // called.\n\t                (0, _CallStackUtilities.getStackTrace)(function (frames) {\n\t                    message.payload.frames = frames;\n\t                    _this2.messagePublisher.publishMessage(message);\n\t                });\n\t            }\n\t        }\n\t    }, {\n\t        key: 'measure',\n\t        value: function measure(data) {\n\t            var eventData = data.data;\n\t            var startMarkMessageId = this.markIdCache[eventData.startMarkId];\n\t            var endMarkMessageId = this.markIdCache[eventData.endMarkId];\n\t            var message = this.messagePublisher.createMessage('debug-timestamp-measurement', {\n\t                correlationMessageIds: [startMarkMessageId, endMarkMessageId],\n\t                category: 'duration',\n\t                name: eventData.name\n\t            });\n\t            (0, _MessageMixins.addOffset)(data.offset, message);\n\t            this.messagePublisher.publishMessage(message);\n\t        }\n\t    }]);\n\n\t    return PerformanceInspector;\n\t}();\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.PerformanceProxy = exports.EVENT_PERFORMANCE_MEASURE = exports.EVENT_PERFORMANCE_MARK = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _Tracing = __webpack_require__(11);\n\t\n\tvar _Tracing2 = _interopRequireDefault(_Tracing);\n\t\n\tvar _PerformanceUtilities = __webpack_require__(25);\n\t\n\tvar _PerformanceUtilities2 = _interopRequireDefault(_PerformanceUtilities);\n\t\n\tvar _GeneralUtilities = __webpack_require__(4);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar EVENT_PERFORMANCE_MARK = exports.EVENT_PERFORMANCE_MARK = 'invoke|post|performance.mark';\n\tvar EVENT_PERFORMANCE_MEASURE = exports.EVENT_PERFORMANCE_MEASURE = 'invoke|post|performance.measure';\n\tvar measureIdCount = 1;\n\t\n\tvar PerformanceProxy = exports.PerformanceProxy = function () {\n\t    function PerformanceProxy() {\n\t        _classCallCheck(this, PerformanceProxy);\n\t\n\t        this.markIdCache = {};\n\t    }\n\t\n\t    _createClass(PerformanceProxy, [{\n\t        key: 'getMarkId',\n\t        value: function getMarkId(name) {\n\t            // Check if we have a cached mark entry, and if so, return it\n\t            if (this.markIdCache[name]) {\n\t                return this.markIdCache[name];\n\t            }\n\t            // If we got here, then that means there is not a cached mark entry,\n\t            // meaning we haven't seen the mark before. This can happen for two reasons:\n\t            // 1) The name is not a known mark name. Technically it shouldn't ever\n\t            //    get to this method, because `performance.measure` will throw first\n\t            // 2) The name is a built-in performance timing mark that the browser\n\t            //    generated on page load. These are stored in `performance.timing`\n\t            // This checks if we have a built-in `performance.timing` mark. If\n\t            // we do have a built in `performance.timing` mark, we create a mark\n\t            // message for this retroactively and publish a mark event. Note:\n\t            // if this built in mark was already referenced, it will be in the\n\t            // cache, meaning that this code will not be run twice for the same mark\n\t            if (_PerformanceUtilities2['default'].timing[name]) {\n\t                // We do a little hack here to get the `startTime` of the entry\n\t                // by measuring this mark against itself and getting the\n\t                // resulting performance entry\n\t                var tempMeasureName = '__glimpse_measure-' + measureIdCount++;\n\t                this.oldMeasure.call(_PerformanceUtilities2['default'], tempMeasureName, name, name);\n\t                var tempMeasureEntry = this.getPerformanceEntryByName(tempMeasureName);\n\t                var eventData = this.initializeMark(name, tempMeasureEntry.startTime, true);\n\t                // We clear the measure entry now so we can keep the `performance.getEntries`\n\t                // history clean for users who want to query performance entries\n\t                _PerformanceUtilities2['default'].clearMeasures(tempMeasureName);\n\t                _Tracing2['default'].publish(EVENT_PERFORMANCE_MARK, eventData);\n\t                return eventData.id;\n\t            }\n\t            // If we got here, then it means the mark name is not valid. We _shouldn't_\n\t            // ever get here, because the browser's native `performance.measure` method\n\t            // will throw if the name is not know before this method is called.\n\t            return undefined;\n\t        }\n\t    }, {\n\t        key: 'getPerformanceEntryByName',\n\t        value: function getPerformanceEntryByName(name) {\n\t            return _PerformanceUtilities2['default'].getEntriesByName(name).pop();\n\t        }\n\t    }, {\n\t        key: 'initializeMark',\n\t        value: function initializeMark(name, startTime, isBuiltIn) {\n\t            var id = (0, _GeneralUtilities.getGuid)();\n\t            var eventData = {\n\t                id: id,\n\t                name: name,\n\t                startTime: startTime,\n\t                isBuiltIn: isBuiltIn\n\t            };\n\t            // We only need to store the newest ID in the cache because `performance.measure`\n\t            // always grabs the newest mark with a given name. For more info, see\n\t            // https://www.w3.org/TR/user-timing/#dom-performance-measure\n\t            this.markIdCache[name] = id;\n\t            return eventData;\n\t        }\n\t    }, {\n\t        key: 'instrumentMark',\n\t        value: function instrumentMark() {\n\t            var oldMark = _PerformanceUtilities2['default'].mark;\n\t            var self = this;\n\t            _PerformanceUtilities2['default'].mark = function mark(name) {\n\t                for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t                    args[_key - 1] = arguments[_key];\n\t                }\n\t\n\t                oldMark.call.apply(oldMark, [this, name].concat(args));\n\t                var performanceEntry = self.getPerformanceEntryByName(name);\n\t                var eventData = self.initializeMark(performanceEntry.name, performanceEntry.startTime, false);\n\t                _Tracing2['default'].publish(EVENT_PERFORMANCE_MARK, eventData);\n\t            };\n\t        }\n\t    }, {\n\t        key: 'instrumentMeasure',\n\t        value: function instrumentMeasure() {\n\t            this.oldMeasure = _PerformanceUtilities2['default'].measure;\n\t            var self = this;\n\t            _PerformanceUtilities2['default'].measure = function measure(name, startMark, endMark) {\n\t                var _self$oldMeasure;\n\t\n\t                for (var _len2 = arguments.length, args = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n\t                    args[_key2 - 3] = arguments[_key2];\n\t                }\n\t\n\t                (_self$oldMeasure = self.oldMeasure).call.apply(_self$oldMeasure, [this, name, startMark, endMark].concat(args));\n\t                var startMarkId = self.getMarkId(startMark);\n\t                var endMarkId = self.getMarkId(endMark);\n\t                if (startMarkId && endMarkId) {\n\t                    var eventData = {\n\t                        name: name,\n\t                        startMarkId: startMarkId,\n\t                        endMarkId: endMarkId\n\t                    };\n\t                    _Tracing2['default'].publish(EVENT_PERFORMANCE_MEASURE, eventData);\n\t                }\n\t            };\n\t        }\n\t    }, {\n\t        key: 'isSupported',\n\t        value: function isSupported() {\n\t            return !!(_PerformanceUtilities2['default'] && _PerformanceUtilities2['default'].getEntriesByName);\n\t        }\n\t    }, {\n\t        key: 'init',\n\t        value: function init() {\n\t            if (_PerformanceUtilities2['default'].mark) {\n\t                this.instrumentMark();\n\t            }\n\t            if (_PerformanceUtilities2['default'].measure) {\n\t                this.instrumentMeasure();\n\t            }\n\t        }\n\t    }]);\n\n\t    return PerformanceProxy;\n\t}();\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports['default'] = initializeProxies;\n\t\n\tvar _XHRProxy = __webpack_require__(10);\n\t\n\tvar _FetchProxy = __webpack_require__(22);\n\t\n\tvar _ResourceTimingProxy = __webpack_require__(24);\n\t\n\tvar _NavigationTimingProxy = __webpack_require__(27);\n\t\n\tvar _ConsoleProxy = __webpack_require__(29);\n\t\n\tvar _PerformanceProxy = __webpack_require__(31);\n\t\n\tvar proxies = {\n\t    XHRProxy: _XHRProxy.XHRProxy,\n\t    FetchProxy: _FetchProxy.FetchProxy,\n\t    ResourceTimingProxy: _ResourceTimingProxy.ResourceTimingProxy,\n\t    NavigationTimingProxy: _NavigationTimingProxy.NavigationTimingProxy,\n\t    ConsoleProxy: _ConsoleProxy.ConsoleProxy,\n\t    PerformanceProxy: _PerformanceProxy.PerformanceProxy\n\t};\n\tfunction initializeProxies() {\n\t    for (var proxyName in proxies) {\n\t        if (proxies.hasOwnProperty(proxyName)) {\n\t            var proxy = new proxies[proxyName]();\n\t            // Only initiate (attach) proxies if they are\n\t            // able to be used in the client.\n\t            if (proxy.isSupported()) {\n\t                proxy.init();\n\t            }\n\t        }\n\t    }\n\t}\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// agent.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap bce023d40630e2735089","if (window.Symbol) {\n    require('./Agent');\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Bootstrap.js","import { MessagePublisher } from './MessagePublisher';\n\nimport { XHRInspector } from './inspectors/XHRInspector';\nimport { FetchInspector } from './inspectors/FetchInspector';\nimport { ResourceTimingInspector } from './inspectors/ResourceTimingInspector';\nimport { NavigationTimingInspector } from './inspectors/NavigationTimingInspector';\nimport { ConsoleInspector } from './inspectors/ConsoleInspector';\nimport { PerformanceInspector } from './inspectors/PerformanceInspector';\n\nimport initializeProxies from './tracing/initializeProxies';\n\nconst messagePublisher = new MessagePublisher();\n\n// We initialize the inspectors before the proxies so that they are wired up and\n// ready to receive events from proxies in case a proxy wants to emit an event\n// in its `init` method (the Resource Timing proxy does this).\nnew XHRInspector().init(messagePublisher);\nnew FetchInspector().init(messagePublisher);\nnew ResourceTimingInspector().init(messagePublisher);\nnew NavigationTimingInspector().init(messagePublisher);\nnew ConsoleInspector().init(messagePublisher);\nnew PerformanceInspector().init(messagePublisher);\n\ninitializeProxies();\n\n\n\n// WEBPACK FOOTER //\n// ./src/Agent.ts","import { ajax } from 'nanoajax';\nimport { getGuid } from './common/GeneralUtilities';\nimport { getRequestId, getMessageIngressUrl } from './common/RequestUtilities';\nimport { addOffset } from './common/MessageMixins';\n\nexport interface IMessage {\n    context: {\n        id: string,\n        type: string\n    };\n    id: string;\n    ordinal: number;\n    payload;\n    types: string[];\n    agent: {\n        source: 'browser';\n    };\n    offset: number;\n}\n\ninterface IRange {\n    start: number;\n    end: number;\n}\n\n/**\n * break a list of messages into group so that the groups are under maxSize.\n * If any individual message is over maxSize, it will be grouped on its own.\n * returns an of IRange instances, where start is inclusive & end is exclusive.\n *\n * Exported for test purposes.\n */\nexport function chunkMessages(messageBodies: string[], maxSize: number): IRange[] {\n    const ranges: IRange[] = [];\n    let sum = 0;\n    let lastStart = 0;\n\n    for (let i = 0; i < messageBodies.length; i++) {\n        sum += messageBodies[i].length;\n        if (messageBodies[i].length > maxSize) {\n            if (lastStart !== i) {\n                // when a single message is over the limit, we want to send previous messages in their own batch\n                ranges.push({ start: lastStart, end: i });\n            }\n            ranges.push({ start: i, end: i + 1 });\n            lastStart = i + 1;\n            sum = 0;\n        }\n        else if (sum > maxSize) {\n            ranges.push({ start: lastStart, end: i });\n            lastStart = i;\n            sum = messageBodies[i].length;\n        }\n    }\n\n    if (lastStart < messageBodies.length) {\n        ranges.push({ start: lastStart, end: messageBodies.length });\n    }\n\n    return ranges;\n}\n\n/**\n * given an array of serialized message bodies & array of ranges,\n * break them into JSON-serialized sub-arrays as defined by the ranges.\n *\n * Exported for test purposes.\n */\nexport function serializeRanges(messageBodies: string[], ranges: IRange[]): string[] {\n    const payloads: string[] = [];\n\n    for (let i = 0; i < ranges.length; i++) {\n        if (ranges[i].end > ranges[i].start) {\n            const subBodies = messageBodies.slice(ranges[i].start, ranges[i].end);\n            const payload = '[' + subBodies.join(',') + ']';\n            payloads.push(payload);\n        }\n    }\n    return payloads;\n}\n\nexport interface IMessagePublisher {\n    createMessage(type: string | string[], payload): IMessage;\n\n    publishMessage(message: IMessage): void;\n\n    createAndPublishMessage(type: string, payload): void;\n}\n\nexport class MessagePublisher implements IMessagePublisher {\n    private static timeout = 250;\n    private ordinal = 1;\n    private messageQueue: IMessage[] = [];\n    private messageTimeout = undefined;\n\n    public createMessage(type: string | string[], payload): IMessage {\n        const types = Array.isArray(type) ? type : [type];\n        const msg: IMessage = {\n            id: getGuid(),\n            types,\n            payload,\n            context: {\n                id: getRequestId(),\n                type: 'Request'\n            },\n            ordinal: this.ordinal++,\n            agent: {\n                source: 'browser'\n            },\n            offset: 0\n        };\n\n        addOffset(performance.now(), msg);\n        return msg;\n\n    }\n\n    public publishMessage(message: IMessage): void {\n        // finish getting message ready for sending\n        message.payload = JSON.stringify(message); // tslint:disable-line:no-string-literal\n\n        // add messages to queu\n        this.messageQueue.push(message);\n\n        // only setup the timeout if we need to\n        if (!this.messageTimeout) {\n            this.messageTimeout = setTimeout(() => {\n                this.messageTimeout = undefined;\n                this.sendData();\n            }, MessagePublisher.timeout);\n        }\n    };\n\n    public createAndPublishMessage(type: string, payload): void {\n        this.publishMessage(this.createMessage(type, payload));\n    };\n\n    private sendPayload(body) {\n        // send data with all the data that we have batched up\n        ajax({\n            url: getMessageIngressUrl(),\n            method: 'POST',\n            body: body\n        }, () => {\n            // not doing anything atm\n        });\n    }\n\n    private sendData() {\n        // we'll chunk the pooled messages into individual requests to try stay under\n        // some size limit for http payloads.\n\n        const maxBodySize = 100000;\n        const bodies: string[] = [];\n\n        this.messageQueue.forEach((m) => {\n            bodies.push(JSON.stringify(m));\n        });\n\n        const ranges = chunkMessages(bodies, maxBodySize);\n        const payloads = serializeRanges(bodies, ranges);\n\n        payloads.forEach((payload) => {\n            this.sendPayload(payload);\n        });\n\n        this.messageQueue = [];\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/MessagePublisher.ts","// Best place to find information on XHR features is:\n// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\n\nvar reqfields = [\n  'responseType', 'withCredentials', 'timeout', 'onprogress'\n]\n\n// Simple and small ajax function\n// Takes a parameters object and a callback function\n// Parameters:\n//  - url: string, required\n//  - headers: object of `{header_name: header_value, ...}`\n//  - body:\n//      + string (sets content type to 'application/x-www-form-urlencoded' if not set in headers)\n//      + FormData (doesn't set content type so that browser will set as appropriate)\n//  - method: 'GET', 'POST', etc. Defaults to 'GET' or 'POST' based on body\n//  - cors: If your using cross-origin, you will need this true for IE8-9\n//\n// The following parameters are passed onto the xhr object.\n// IMPORTANT NOTE: The caller is responsible for compatibility checking.\n//  - responseType: string, various compatability, see xhr docs for enum options\n//  - withCredentials: boolean, IE10+, CORS only\n//  - timeout: long, ms timeout, IE8+\n//  - onprogress: callback, IE10+\n//\n// Callback function prototype:\n//  - statusCode from request\n//  - response\n//    + if responseType set and supported by browser, this is an object of some type (see docs)\n//    + otherwise if request completed, this is the string text of the response\n//    + if request is aborted, this is \"Abort\"\n//    + if request times out, this is \"Timeout\"\n//    + if request errors before completing (probably a CORS issue), this is \"Error\"\n//  - request object\n//\n// Returns the request object. So you can call .abort() or other methods\n//\n// DEPRECATIONS:\n//  - Passing a string instead of the params object has been removed!\n//\nexports.ajax = function (params, callback) {\n  // Any variable used more than once is var'd here because\n  // minification will munge the variables whereas it can't munge\n  // the object access.\n  var headers = params.headers || {}\n    , body = params.body\n    , method = params.method || (body ? 'POST' : 'GET')\n    , called = false\n\n  var req = getRequest(params.cors)\n\n  function cb(statusCode, responseText) {\n    return function () {\n      if (!called) {\n        callback(req.status === undefined ? statusCode : req.status,\n                 req.status === 0 ? \"Error\" : (req.response || req.responseText || responseText),\n                 req)\n        called = true\n      }\n    }\n  }\n\n  req.open(method, params.url, true)\n\n  var success = req.onload = cb(200)\n  req.onreadystatechange = function () {\n    if (req.readyState === 4) success()\n  }\n  req.onerror = cb(null, 'Error')\n  req.ontimeout = cb(null, 'Timeout')\n  req.onabort = cb(null, 'Abort')\n\n  if (body) {\n    setDefault(headers, 'X-Requested-With', 'XMLHttpRequest')\n\n    if (!global.FormData || !(body instanceof global.FormData)) {\n      setDefault(headers, 'Content-Type', 'application/x-www-form-urlencoded')\n    }\n  }\n\n  for (var i = 0, len = reqfields.length, field; i < len; i++) {\n    field = reqfields[i]\n    if (params[field] !== undefined)\n      req[field] = params[field]\n  }\n\n  for (var field in headers)\n    req.setRequestHeader(field, headers[field])\n\n  req.send(body)\n\n  return req\n}\n\nfunction getRequest(cors) {\n  // XDomainRequest is only way to do CORS in IE 8 and 9\n  // But XDomainRequest isn't standards-compatible\n  // Notably, it doesn't allow cookies to be sent or set by servers\n  // IE 10+ is standards-compatible in its XMLHttpRequest\n  // but IE 10 can still have an XDomainRequest object, so we don't want to use it\n  if (cors && global.XDomainRequest && !/MSIE 1/.test(navigator.userAgent))\n    return new XDomainRequest\n  if (global.XMLHttpRequest)\n    return new XMLHttpRequest\n}\n\nfunction setDefault(obj, key, value) {\n  obj[key] = obj[key] || value\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/nanoajax/index.js\n// module id = 3\n// module chunks = 0","export function getGuid(): string {\n    return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n        /* tslint:disable:no-bitwise */\n        const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);\n        /* tslint:enable:no-bitwise */\n        return v.toString(16);\n    });\n}\n\nexport function convertBlobToText(blob: Blob, encoding: string, cb: (content: string) => void) {\n    const fileReader = new FileReader();\n    fileReader.onloadend = () => {\n        cb(fileReader.result);\n    };\n    fileReader.readAsText(blob, encoding);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/GeneralUtilities.ts","import { getGuid } from './GeneralUtilities';\n\nexport function getRequestId(): string {\n    // NOTE: agent should look to see if it can get the id\n    //       from a script tag first, then if it can't find\n    //       it there look to for a cookie (in the case where\n    //       we can't inject a script tag) and finally it will\n    //       create one which will be used moving forward\n    //       (CDN scenario).\n    let id = document.getElementById('__glimpse_browser_agent').getAttribute('data-request-id');\n    if (!id) {\n        id = getCookie('.Glimpse.RequestId');\n    }\n    if (!id) {\n        id = getGuid();\n    }\n    return id;\n}\n\nexport function addEvent(element, eventName: string, cb): void {\n    if (element.addEventListener) {\n        element.addEventListener(eventName, cb, false);\n    } else if (element.attachEvent) {\n        element.attachEvent('on' + eventName, cb);\n    }\n}\n\nexport function getCookie(cookie) {\n    // Modified from https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie\n    const regexp = new RegExp('(?:(?:^|.*;\\\\s*)' + cookie + '\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$');\n    return document.cookie.replace(regexp, '$1');\n}\n\nexport interface IHeaders {\n    [header: string]: string | number | boolean;\n}\n\nexport function getHeaderKeys(headers: Headers): string[] {\n    const headerKeys = [];\n    // tslint:disable-next-line:no-any\n    if ((<any>headers).keys) {\n        // tslint:disable-next-line:no-any\n        for (const header of (<any>headers).keys()) {\n            headerKeys.push(header);\n        }\n    }\n    else if (headers.forEach) {\n        headers.forEach((value, name) => headerKeys.push(name));\n    }\n    return headerKeys;\n}\n\n// Headers are not technically case sensitive, and the browser often normalizes\n// header so that they are all lower case and all strings. This method does the\n// same so that headers are always normalized from the browser agent in all cases.\nexport function normalizeHeaders(headers: IHeaders): IHeaders {\n    const normalizedHeaders: IHeaders = {};\n    for (const header in headers) {\n        if (!headers.hasOwnProperty(header)) {\n            continue;\n        }\n\n        let headerVal = headers[header];\n        // tslint:disable-next-line:no-null-keyword\n        if (headerVal !== undefined && headerVal !== null && typeof headerVal !== 'string') {\n            headerVal = headerVal.toString();\n        }\n        normalizedHeaders[header.toLowerCase()] = headerVal;\n    }\n    return normalizedHeaders;\n}\n\nexport function getMessageIngressUrl(): string {\n    return document.getElementById('__glimpse_browser_agent').getAttribute('data-message-ingress-template');\n}\n\nexport interface IParsedUrl {\n    protocol: string;\n    hostname: string;\n    port?: number;\n    pathname: string;\n    search: string;\n    hash: string;\n}\n\nexport function parseUrl(url: string): IParsedUrl {\n    const parser = document.createElement('a');\n    parser.href = url;\n    const parsedPort = parseInt(parser.port, 10);\n    return {\n        protocol: parser.protocol,\n        hostname: parser.hostname,\n        port: isNaN(parsedPort) ? undefined : parsedPort,\n        pathname: parser.pathname,\n        search: parser.search,\n        hash: parser.hash\n    };\n}\n\nexport function stringifyUrl(url: IParsedUrl): string {\n    const portSuffix = url.port !== undefined ? `:${url.port}` : '';\n    let stringifiedUrl = `${url.protocol}//${url.hostname}${portSuffix}${url.pathname}`;\n    if (url.search) {\n        stringifiedUrl += url.search;\n    }\n    if (url.hash) {\n        stringifiedUrl += url.hash;\n    }\n    return stringifiedUrl;\n}\n\nconst urlCache = {};\nexport function resolveUrl(url: string): string {\n    if (urlCache[url]) {\n        return urlCache[url];\n    }\n    return urlCache[url] = stringifyUrl(parseUrl(url));\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/RequestUtilities.ts","\nexport function addOffset(offset: number, envelope) {\n    envelope.offset = offset;\n}\n\nexport function addCorrelationBegin(correlationId, envelope) {\n    envelope.types.push('correlation-begin');\n\n    addCorrelation(correlationId, envelope);\n}\n\nexport function addCorrelationEnd(correlationId, duration, envelope) {\n    envelope.types.push('correlation-end');\n    envelope.payload.duration = duration;\n\n    addCorrelation(correlationId, envelope);\n}\n\nexport function addCorrelation(correlationId, envelope) {\n    envelope.types.push('correlation');\n    envelope.payload.correlationId = correlationId;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/MessageMixins.ts","import logger from '../common/GlimpseLogger';\nimport { IInspector } from './IInspector';\nimport { IMessagePublisher } from '../MessagePublisher';\nimport { IProxyEvent } from '../tracing/IProxyEvent';\nimport { addOffset } from '../common/MessageMixins';\nimport { MAX_HTTP_BODY_SIZE } from '../common/Constants';\nimport {\n    IRequestSentEvent, EVENT_XHR_REQUEST_SENT,\n    IResponseReceivedEvent, EVENT_XHR_RESPONSE_RECEIVED,\n    EVENT_XHR_ERROR,\n    EVENT_XHR_ABORT\n} from '../tracing/proxies/XHRProxy';\nimport tracing from '../tracing/Tracing';\nimport { getDateTime } from '../common/DateTimeUtilities';\nimport { parseUrl, normalizeHeaders, IHeaders } from '../common/RequestUtilities';\nimport parse from 'parse-headers';\nimport {\n    tryFindResourceTimingObject,\n    getMultiPartFormBoundary,\n    getMultiPartFormParts,\n    IBody,\n    IPartSummary,\n    createBodyForBlob,\n    createEmptyBody\n} from './HttpRequestUtils';\nimport { getStackTrace } from '../common/CallStackUtilities';\n\ninterface IRequestCacheEntry {\n    startTimeStamp: number;\n    startTimeOffset: number;\n}\n\nexport class XHRInspector implements IInspector {\n\n    private initiatorRegExp = /xmlhttprequest/i;\n\n    private messagePublisher: IMessagePublisher;\n\n    private requests: { [id: string]: IRequestCacheEntry } = {};\n\n    private createBodyProperty(headers: IHeaders, body: string | ArrayBuffer | ArrayBufferView | Blob | Document | FormData, cb: (bodyProperty: IBody) => void) {\n        //\n        // Note on use of setTimeout() below.  This is done to ensure all code paths execute asynchronously,\n        // irrespective of whether createBodyForBlob is called.  For a more in-depth discussion,\n        // see https://nodejs.org/dist/latest-v7.x/docs/api/process.html#process_process_nexttick_callback_args\n        //\n        if (!body) {\n            const bodyProperty = createEmptyBody(false);\n            setTimeout(() => cb(bodyProperty), 0);\n        }\n        else {\n            //\n            // according to MDN docs, body here can be one of the following types:\n            // ArrayBufferView | Blob | Document | string | FormData.  We need to\n            // account for all of these.\n            //\n            if (typeof body === 'string') {\n                const contentType = headers['content-type'] as string;\n                const boundary = getMultiPartFormBoundary(contentType);\n                const bodyProperty: IBody = {\n                    size: body.length,\n                    encoding: 'utf8',\n                    isTruncated: body.length > MAX_HTTP_BODY_SIZE,\n                    parts: getMultiPartFormParts(boundary, body),\n                    content: body.slice(0, MAX_HTTP_BODY_SIZE)\n                };\n                setTimeout(() => cb(bodyProperty), 0);\n            }\n            else if (body instanceof Blob) {\n                const contentType = headers['content-type'] as string;\n                const blob = body as Blob;\n                createBodyForBlob(contentType, blob, true, (bodyProperty: IBody) => {\n                    cb(bodyProperty);\n                });\n            }\n            else if (body instanceof ArrayBuffer || ((body as ArrayBufferView).buffer && (body as ArrayBufferView).buffer instanceof ArrayBuffer)) {\n                let buffer: ArrayBuffer;\n                if (body instanceof ArrayBuffer) {\n                    buffer = body;\n                }\n                else {\n                    buffer = (body as ArrayBufferView).buffer;\n                }\n\n                // TODO:  support body capture when body is ArrayBuffer\n                const bodyProperty: IBody = {\n                    size: buffer.byteLength,\n                    encoding: 'none',\n                    isTruncated: true,\n                    parts: [],\n                    content: ''\n                };\n                setTimeout(() => cb(bodyProperty), 0);\n            }\n            else if (body instanceof Document) {\n                // TODO:  support body capture when body is Document\n                const doc = body as Document;\n                const bodyProperty = createEmptyBody(true);\n                setTimeout(() => cb(bodyProperty), 0);\n            }\n            else if (body instanceof FormData) {\n                // TODO:  support body capture when body is FormData\n                const fd = body as FormData;\n                const bodyProperty = createEmptyBody(true);\n                setTimeout(() => cb(bodyProperty), 0);\n            }\n            else if (typeof body === 'object') {\n                // TODO:  support body capture when body is object\n                const bodyProperty = createEmptyBody(true);\n                setTimeout(() => cb(bodyProperty), 0);\n            }\n            else {\n                const bodyProperty = createEmptyBody(true);\n                setTimeout(() => cb(bodyProperty), 0);\n            }\n        }\n    }\n\n    private before(event: IProxyEvent) {\n        const eventData: IRequestSentEvent = event.data;\n        const url = parseUrl(eventData.url);\n        const headers = normalizeHeaders(eventData.headers);\n        getStackTrace((frames) => {\n            this.createBodyProperty(headers, eventData.body, (body: IBody) => {\n                const startTime = getDateTime(new Date(event.timeStamp));\n                const msg = this.messagePublisher.createMessage(['data-http-request', 'call-stack'], {\n                    correlationId: eventData.id,\n                    protocol: {\n                        identifier: url.protocol.replace(/\\:$/, '').toLowerCase()\n                    },\n                    url: eventData.url,\n                    method: eventData.method,\n                    startTime,\n                    timing: {\n                        startTime: 0\n                    },\n                    headers,\n                    isAjax: true,\n                    body,\n                    frames: frames.slice(0, 1)\n                });\n                addOffset(event.offset, msg);\n                this.messagePublisher.publishMessage(msg);\n            });\n        });\n    }\n\n    private after(event: IProxyEvent, requestEntry: IRequestCacheEntry) {\n        const eventData: IResponseReceivedEvent = event.data;\n        tryFindResourceTimingObject(event.data.id, this.initiatorRegExp, eventData.url, requestEntry.startTimeOffset, (timings: PerformanceResourceTiming) => {\n\n            const offset = timings ? timings.startTime : requestEntry.startTimeOffset;\n            // start here is relative to this http client request, so it is always 0\n            const startTime = 0;\n            // leave responseStart undefined if no timings instance since this is optional and we don't know accurate value\n            const responseStart = timings && (timings.responseStart >= timings.startTime) ? (timings.responseStart - timings.startTime) : undefined;\n            const responseEnd = timings ? (timings.responseEnd - timings.startTime) : (event.offset - requestEntry.startTimeOffset);\n\n            const headers = parse(eventData.xhr.getAllResponseHeaders());\n            // TODO: https://github.com/Glimpse/Glimpse.Node.Prototype/issues/307\n            // Add support for base64 encoding non-text content by setting the encoding here\n            this.createBodyProperty(headers, eventData.body, (body) => {\n                const msg = this.messagePublisher.createMessage('data-http-response', {\n                    correlationId: eventData.id,\n                    url: eventData.url,\n                    headers,\n                    statusCode: eventData.statusCode,\n                    statusMessage: eventData.statusMessage,\n                    endTime: getDateTime(new Date(event.timeStamp)),\n                    duration: responseEnd,\n                    timing: {\n                        startTime: 0,\n                        responseEnd\n                    },\n                    body\n                });\n\n                if (responseStart !== undefined) {\n                    msg.payload.timing.responseStart = responseStart;\n                }\n\n                addOffset(offset, msg);\n                this.messagePublisher.publishMessage(msg);\n            });\n        });\n    }\n\n    public numOutstandingRequests() {\n        return Object.keys(this.requests).length;\n    }\n\n    public init(messagePublisher: IMessagePublisher) {\n        this.messagePublisher = messagePublisher;\n\n        tracing.on(EVENT_XHR_REQUEST_SENT, (event: IProxyEvent) => {\n            this.requests[event.data.id] = {\n                startTimeStamp: event.timeStamp,\n                startTimeOffset: event.offset\n            };\n            this.before(event);\n        });\n\n        tracing.on(EVENT_XHR_RESPONSE_RECEIVED, (event: IProxyEvent) => {\n            const requestEntry = this.requests[event.data.id];\n            if (!requestEntry) {\n                logger.error('Glimpse Internal Error: could not find associated master data, some inspection data will be lost.');\n                return;\n            }\n            this.after(event, requestEntry);\n            delete this.requests[event.data.id];\n        });\n\n        tracing.on(EVENT_XHR_ERROR, (data: IProxyEvent) => {\n            delete this.requests[data.data.id];\n        });\n\n        tracing.on(EVENT_XHR_ABORT, (data: IProxyEvent) => {\n            delete this.requests[data.data.id];\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/inspectors/XHRInspector.ts","export interface IGlimpseLogger {\n    error(message?: string): void;\n}\n\nexport class GlimpseLogger implements IGlimpseLogger {\n    constructor(private logToConsole: boolean) {\n    }\n\n    public error(message?: string): void {\n        if (this.logToConsole) {\n            // tslint:disable-next-line:no-console\n            console.error(message);\n        }\n    }\n}\n\nconst logger = new GlimpseLogger(LOG_TO_CONSOLE);\n\nexport default logger;\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/GlimpseLogger.ts","export const MAX_HTTP_BODY_SIZE = 132000;\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/Constants.ts","import logger from '../../common/GlimpseLogger';\nimport { IProxy } from '../IProxy';\nimport tracing from '../Tracing';\nimport { getGuid } from '../../common/GeneralUtilities';\nimport { getMessageIngressUrl, resolveUrl } from '../../common/RequestUtilities';\n\nexport type EventBody = ArrayBuffer | ArrayBufferView | Blob | Document | string | FormData;\n\n/**\n * This event indicates that a request was sent, as indicated by a call to\n * an XMLHttpRequest instance's `send()` method.\n *\n * @property {string} id - An ID that is consistent for all stages of this request\n * @property {XMLHttpRequest} xhr - The XMLHttpRequest instance\n * @property {string} url - The resolved URL for the request\n * @property {string} method - The request method, e.g. \"GET\"\n * @property {object} headers - The request headers, represented as a key-value dictionary\n * @property {string} body - The body of the request, as passed to `xhr.send(body)`\n */\nexport interface IRequestSentEvent {\n    id: string;\n    xhr: XMLHttpRequest;\n    url: string;\n    method: string;\n    headers;\n    body: EventBody;\n}\nexport const EVENT_XHR_REQUEST_SENT = 'invoke|pre|XMLHttpRequest.request-sent';\n\n/**\n * This event indicates that a response was received. This event is fired either\n * as a response to a `readystatechange` event from the XMLHttpRequest object,\n * or that the `xhr.send()` method has returned, depending on if the request was\n * synchronous or asynchronous.\n *\n * @property {string} id - An ID that is consistent for all stages of this request\n * @property {XMLHttpRequest} xhr - The XMLHttpRequest instance\n * @property {string} url - The resolved URL for the request\n * @property {statusCode} number - The response status code, e.g. 200\n * @property {bodyType} string - The data type of the body, as reported by `xhr.responseType`\n * @property {string} body - The body of the request, as passed to `xhr.send(body)`\n */\nexport interface IResponseReceivedEvent {\n    id: string;\n    xhr: XMLHttpRequest;\n    url: string;\n    statusCode: number;\n    statusMessage: string;\n    bodyType: string;\n    body: EventBody;\n}\nexport const EVENT_XHR_RESPONSE_RECEIVED = 'notify|XMLHttpRequest.response-received';\n\n/**\n * This event indicates an error happened during the request. Note that an error is\n * different than the server returning an error status code. In the latter case,\n * an `EVENT_RESPONSE_RECEIVED` event is dispatched. This type of error indicates\n * that a response was not received from the server.\n *\n * @property {string} id - An ID that is consistent for all stages of this request\n * @property {XMLHttpRequest} xhr - The XMLHttpRequest instance\n * @property {error} error - A description of the error, if one is available\n */\nexport interface IErrorEvent {\n    id: string;\n    xhr: XMLHttpRequest;\n    error: string;\n}\nexport const EVENT_XHR_ERROR = 'notify|XMLHttpRequest.error';\n\n/**\n * This event indicates that the request was cancelled during the request. Note\n * that this is slightly different than an error, because the request may have\n * been able to be completed, had it been allowed to complete. This typically\n * happens when `xhr.abort()` is called, or when the page is navigated away from\n *\n * @property {string} id - An ID that is consistent for all stages of this request\n * @property {XMLHttpRequest} xhr - The XMLHttpRequest instance\n */\nexport interface IAbortEvent {\n    id: string;\n    xhr: XMLHttpRequest;\n}\nexport const EVENT_XHR_ABORT = 'notify|XMLHttpRequest.abort';\n\n/**\n * Proxy which wraps XHR usage and its various supporting functions.\n *\n * NOTE: Don't add any headers within this proxy, breaks CORS scenarioes.\n */\nexport class XHRProxy implements IProxy {\n    public static isInitialized = false;\n\n    public isSupported(): boolean {\n        // Note: TypeScript doesn't know about XMLHttpRequest existing on Window, so we\n        // reference the property this way to get around TypeScript\n        //tslint:disable-next-line:no-any\n        return !!(window && typeof (<any>window).XMLHttpRequest !== 'undefined');\n    }\n\n    public init() {\n        if (XHRProxy.isInitialized) {\n            logger.error('Glimpse Error: Cannot initialize the XHR Proxy more than once.');\n            return;\n        }\n\n        //tslint:disable-next-line:no-any\n        const oldXMLHttpRequest = (<any>window).XMLHttpRequest;\n\n        function XMLHttpRequest() {\n            const xhr = new oldXMLHttpRequest();\n            const id = getGuid();\n\n            function handleAsyncRequest(method, url) {\n\n                const requestHeaders = {};\n\n                xhr.addEventListener('readystatechange', () => {\n                    if (xhr.readyState === oldXMLHttpRequest.DONE) {\n                        const eventData: IResponseReceivedEvent = {\n                            id,\n                            xhr,\n                            url: resolveUrl(url),\n                            statusCode: xhr.status,\n                            statusMessage: xhr.statusText,\n                            bodyType: xhr.responseType,\n                            body: xhr.response\n                        };\n                        tracing.publish(EVENT_XHR_RESPONSE_RECEIVED, eventData);\n                    };\n                });\n\n                xhr.addEventListener('error', () => {\n                    const eventData: IErrorEvent = {\n                        id,\n                        xhr,\n                        error: xhr.statusText\n                    };\n                    tracing.publish(EVENT_XHR_ERROR, eventData);\n                });\n\n                xhr.addEventListener('abort', () => {\n                    const eventData: IAbortEvent = {\n                        id,\n                        xhr\n                    };\n                    tracing.publish(EVENT_XHR_ABORT, eventData);\n                });\n\n                const oldSend = xhr.send;\n                xhr.send = function send(body, ...sendArgs) {\n                    const eventData: IRequestSentEvent = {\n                        id,\n                        xhr,\n                        method,\n                        url: resolveUrl(url),\n                        body,\n                        headers: requestHeaders\n                    };\n                    tracing.publish(EVENT_XHR_REQUEST_SENT, eventData);\n                    oldSend.call(this, body, ...sendArgs);\n                };\n\n                const oldSetRequestHeader = xhr.setRequestHeader;\n                xhr.setRequestHeader = function setRequestHeader(header, value, ...setRequestHeaderArgs) {\n                    requestHeaders[header] = value;\n                    oldSetRequestHeader.call(this, header, value, ...setRequestHeaderArgs);\n                };\n            }\n\n            function handleSyncRequest(method, url) {\n                const oldSend = xhr.send;\n\n                const requestHeaders = {};\n                const oldSetRequestHeader = xhr.setRequestHeader;\n                xhr.setRequestHeader = function setRequestHeader(header, value, ...setRequestHeaderArgs) {\n                    requestHeaders[header] = value;\n                    oldSetRequestHeader.call(this, header, value, ...setRequestHeaderArgs);\n                };\n\n                xhr.send = function send(body, ...sendArgs) {\n                    const requestEventData: IRequestSentEvent = {\n                        id,\n                        xhr,\n                        method,\n                        url: resolveUrl(url),\n                        body,\n                        headers: requestHeaders\n                    };\n                    tracing.publish(EVENT_XHR_REQUEST_SENT, requestEventData);\n                    try {\n                        oldSend.call(this, body, ...sendArgs);\n                    } catch (e) {\n                        const errorEventData: IErrorEvent = {\n                            id,\n                            xhr,\n                            error: e.message\n                        };\n                        tracing.publish(EVENT_XHR_ERROR, errorEventData);\n                        throw e;\n                    }\n                    const responseEventData: IResponseReceivedEvent = {\n                        id,\n                        xhr,\n                        url: resolveUrl(url),\n                        statusCode: xhr.status,\n                        statusMessage: xhr.statusText || '',\n                        bodyType: xhr.responseType,\n                        body: xhr.response\n                    };\n                    tracing.publish(EVENT_XHR_RESPONSE_RECEIVED, responseEventData);\n                };\n            }\n\n            const oldOpen = xhr.open;\n            xhr.open = function open(method, url, async = true, ...openArgs) {\n\n                const result = oldOpen.call(this, method, url, async, ...openArgs);\n\n                // If the url equals the message ingress url, that means it's\n                // a Glimpse message and we don't want to profile it\n                if (url !== getMessageIngressUrl()) {\n                    if (async) {\n                        handleAsyncRequest(method, url);\n                    } else {\n                        handleSyncRequest(method, url);\n                    }\n                }\n\n                return result;\n            };\n\n            return xhr;\n        }\n        // Copy the states (and anything else) from the original object to our proxy\n        for (const prop in oldXMLHttpRequest) {\n            if (oldXMLHttpRequest.hasOwnProperty(prop)) {\n                XMLHttpRequest[prop] = oldXMLHttpRequest[prop];\n            }\n        }\n\n        // Note: TypeScript doesn't know about XMLHttpRequest existing on Window, so we\n        // reference the property this way to get around TypeScript, but we also have to\n        // disable tslint in the process\n        /* tslint:disable */\n        window['XMLHttpRequest'] = XMLHttpRequest;\n        /* tslint:enable */\n\n        XHRProxy.isInitialized = true;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/tracing/proxies/XHRProxy.ts","/**\n * The Tracing module provides mechanisms for registering to receive tracing\n * events from proxies.\n *\n * This module is pretty similar to a standard EventEmitter, but has a few\n * key differences. This module provides the ability to filter out which\n * events you would like to receive, based on criteria of your choosing.\n *\n * Tracing can hurt performance in some cases, and filtering is a way for\n * the profiling application to improve performance whenever the data is not\n * explicitly needed.\n *\n * @module tracing/Tracing\n */\n\nimport { IProxyEvent } from './IProxyEvent';\n\nexport interface IEventFilterCallback {\n    (): boolean;\n}\n\nexport interface IEventCallback {\n    (eventData: IProxyEvent): void;\n}\n\ninterface IListenerEntry {\n    listener: IEventCallback;\n}\n\nclass Tracing {\n\n    private listeners: { [eventName: string]: IListenerEntry[]; } = {};\n\n    /**\n     * Publishes an event, similar to the `EventEmitter.emit` method except that it\n     * does not accept more than one data argument.\n     *\n     * @param {string} event - The name of the event to fire, and should include a\n     *      descriptive namespace, e.g. `http.request:request-created`\n     * @param {object} data - The data associated with the event\n     * @returns {boolean} - Whether or not the event was published to any listeners\n     */\n    public publish(event: string, data): boolean {\n        const listeners = this.listeners[event];\n        if (!listeners || listeners.length === 0) {\n            return false;\n        }\n        let emitted = false;\n        const message: IProxyEvent = {\n            offset: performance.now(),\n            timeStamp: Date.now(),\n            data\n        };\n        for (const listener of listeners) {\n            emitted = true;\n            listener.listener(message);\n        }\n        return emitted;\n    }\n\n    /**\n     * Register to always receive an event without any filtering. This module is\n     * returned from this method, making it possible to chain `removeEventListener`\n     * calls.\n     *\n     * Note: if any other listeners are filtering this event, registering with\n     * this method will prevent the proxies from enabling any performance\n     * optimizations.\n     *\n     * Calling this method is equivalent to calling `onFiltered(event, listener, () => true)`\n     *\n     * @param {string} event - The name of the event to listen to, e.g.\n     *      `http.request:request-created`\n     * @param {function} listener - The callback to call when the event is emitted\n     */\n    public on(event: string, listener: IEventCallback): Tracing {\n        if (!this.listeners[event]) {\n            this.listeners[event] = [];\n        }\n        this.listeners[event].push({\n            listener\n        });\n        return this;\n    }\n\n    /**\n     * Removes exactly one registered event listener. If the same callback is\n     * registered more than once, only the first copy is removed. This behavior\n     * mimics that of EventEmitter.removeEventListener\n     *\n     * @param {string} event - The name of the event to remove the listener for,\n     *      e.g. `http.request:request-created`\n     * @param {function} listener - The listener to remove\n     * @returns {object} A refernce to this module, making it possible to chain\n     *      removeEventListener calls\n     */\n    public removeEventListener(event: string, listener: IEventCallback): Tracing {\n        const listeners = this.listeners[event];\n        if (!listeners) {\n            // Matches Node.js removeEventListener return signature\n            return this;\n        }\n        for (let i = 0; i < listeners.length; i++) {\n            if (listeners[i].listener === listener) {\n                this.listeners[event].splice(i, 1);\n                break;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Removes all listeners for the given event. If no event is specified, then\n     * all event listeners for all events are removed.\n     *\n     * @param {string} event - (Optional) The event to remove listeners for\n     * @returns {object} A refernce to this module, making it possible to chain calls\n     */\n    public removeAllListeners(event?: string): Tracing {\n        if (event) {\n            if (this.listeners[event]) {\n                this.listeners[event] = [];\n            }\n        } else {\n            this.listeners = {};\n        }\n        return this;\n    }\n\n    /**\n     * Returns the number of listeners for the given event. This behavior\n     * mimics that of EventEmitter.listenerCount\n     *\n     * @param {string} event - The event to count listeners for\n     * @returns {number} The number of listeners for the given event\n     */\n    public listenerCount(event: string): number {\n        if (!this.listeners[event]) {\n            return 0;\n        }\n        return this.listeners[event].length;\n    }\n}\n\nexport default new Tracing();\n\n\n\n// WEBPACK FOOTER //\n// ./src/tracing/Tracing.ts","function toTwoDigits(value) {\n    return value < 10 ? '0' + value : value;\n}\n\nfunction toThreeDigits(value) {\n    if (value < 10) {\n        return '00' + value;\n    }\n\n    if (value < 100) {\n        return '0' + value;\n    }\n\n    return value;\n}\n\nfunction getUTCOffset(date) {\n    let offset = date.getTimezoneOffset();\n    const sign = (offset >= 0) ? '+' : '-';\n    offset = Math.abs(offset);\n    const hours = toTwoDigits(Math.floor(offset / 60));\n    const minutes = toTwoDigits(offset % 60);\n    return sign + hours + minutes;\n}\n\n// Convert time according to the format string: 'YYYY-MM-DDTHH:mm:ss.SSS ZZ'\n// Output should look like: \"2016-06-08T09:07:11.021 -0700\"\nexport function getDateTime(d: Date = new Date()): string {\n    return d.getFullYear() + '-' + toTwoDigits(d.getMonth() + 1) + '-' + toTwoDigits(d.getDate()) + 'T' +\n        toTwoDigits(d.getHours()) + ':' + toTwoDigits(d.getMinutes()) + ':' + toTwoDigits(d.getSeconds()) + '.' +\n        toThreeDigits(d.getMilliseconds()) + getUTCOffset(d);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/DateTimeUtilities.ts","var trim = require('trim')\n  , forEach = require('for-each')\n  , isArray = function(arg) {\n      return Object.prototype.toString.call(arg) === '[object Array]';\n    }\n\nmodule.exports = function (headers) {\n  if (!headers)\n    return {}\n\n  var result = {}\n\n  forEach(\n      trim(headers).split('\\n')\n    , function (row) {\n        var index = row.indexOf(':')\n          , key = trim(row.slice(0, index)).toLowerCase()\n          , value = trim(row.slice(index + 1))\n\n        if (typeof(result[key]) === 'undefined') {\n          result[key] = value\n        } else if (isArray(result[key])) {\n          result[key].push(value)\n        } else {\n          result[key] = [ result[key], value ]\n        }\n      }\n  )\n\n  return result\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/parse-headers/parse-headers.js\n// module id = 13\n// module chunks = 0","\nexports = module.exports = trim;\n\nfunction trim(str){\n  return str.replace(/^\\s*|\\s*$/g, '');\n}\n\nexports.left = function(str){\n  return str.replace(/^\\s*/, '');\n};\n\nexports.right = function(str){\n  return str.replace(/\\s*$/, '');\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/trim/index.js\n// module id = 14\n// module chunks = 0","var isFunction = require('is-function')\n\nmodule.exports = forEach\n\nvar toString = Object.prototype.toString\nvar hasOwnProperty = Object.prototype.hasOwnProperty\n\nfunction forEach(list, iterator, context) {\n    if (!isFunction(iterator)) {\n        throw new TypeError('iterator must be a function')\n    }\n\n    if (arguments.length < 3) {\n        context = this\n    }\n    \n    if (toString.call(list) === '[object Array]')\n        forEachArray(list, iterator, context)\n    else if (typeof list === 'string')\n        forEachString(list, iterator, context)\n    else\n        forEachObject(list, iterator, context)\n}\n\nfunction forEachArray(array, iterator, context) {\n    for (var i = 0, len = array.length; i < len; i++) {\n        if (hasOwnProperty.call(array, i)) {\n            iterator.call(context, array[i], i, array)\n        }\n    }\n}\n\nfunction forEachString(string, iterator, context) {\n    for (var i = 0, len = string.length; i < len; i++) {\n        // no such thing as a sparse string.\n        iterator.call(context, string.charAt(i), i, string)\n    }\n}\n\nfunction forEachObject(object, iterator, context) {\n    for (var k in object) {\n        if (hasOwnProperty.call(object, k)) {\n            iterator.call(context, object[k], k, object)\n        }\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/for-each/index.js\n// module id = 15\n// module chunks = 0","module.exports = isFunction\n\nvar toString = Object.prototype.toString\n\nfunction isFunction (fn) {\n  var string = toString.call(fn)\n  return string === '[object Function]' ||\n    (typeof fn === 'function' && string !== '[object RegExp]') ||\n    (typeof window !== 'undefined' &&\n     // IE8 and below\n     (fn === window.setTimeout ||\n      fn === window.alert ||\n      fn === window.confirm ||\n      fn === window.prompt))\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/is-function/index.js\n// module id = 16\n// module chunks = 0","\nimport { convertBlobToText } from '../common/GeneralUtilities';\nimport { MAX_HTTP_BODY_SIZE } from '../common/Constants';\n\n/**\n * interface definition for a body part of data-http-request/data-http-response message\n */\nexport interface IBody {\n    size: number;\n    encoding: string;\n    content: string;\n    isTruncated: boolean;\n    parts?: IPartSummary[];\n}\n\n/**\n *  A summary of a single part in a multi-part/form body\n */\nexport interface IPartSummary {\n    headers: { [key: string]: string[] }; // map of header name to an array of header value.\n    bodyStartIndex?: number;  // index in the multi-part payload of the first character of this part's body.\n    bodyEndIndex?: number;    // index in the multi-part payload of the first character  **after** this part's body.\n    bodyLength?: number;      // length of body in bytes\n}\n\n/**\n * set of regular expressions that match a mime type when the encoding of a payload is UTF8\n */\nconst UTF8_ENCODING_MIME_TYPES = [\n    /^text\\//,\n    /^application\\/.*?xml/,\n    /^application\\/json/,\n    /^application\\/javascript/,\n    /^application\\/x-www-form-urlencoded/,\n    /^multipart\\/form-data/\n];\n\n/**\n * Infer the encoding type given a blob\n *\n * @param blob The blob to get the encoding for\n */\nfunction getEncodingForBlob(blob: Blob) {\n    let encoding = 'none';\n    for (const mimeType of UTF8_ENCODING_MIME_TYPES) {\n        if (mimeType.test(blob.type)) {\n            encoding = 'utf8';\n            break;\n        }\n    }\n    return encoding;\n}\n\nexport function createEmptyBody(isTruncated: boolean): IBody {\n    return {\n        size: 0,\n        encoding: 'none',\n        content: '',\n        isTruncated\n    };\n}\n\nexport function createBodyForBlob(contentTypeHeader: string, blob: Blob, includeParts: boolean, cb: (body: IBody) => void): void {\n    // TODO: https://github.com/Glimpse/Glimpse.Node.Prototype/issues/307\n    // Add support for base64 encoding non-text content by setting the encoding here\n\n    // Note on use of setTimeout() below.  This is done to ensure all code paths execute asynchronously,\n    // irrespective of whether convertBlobtoText is called.  For a more in-depth discussion,\n    // see https://nodejs.org/dist/latest-v7.x/docs/api/process.html#process_process_nexttick_callback_args\n\n    if (blob.size) {\n        let encoding = getEncodingForBlob(blob);\n        switch (encoding) {\n            case 'utf8':\n                convertBlobToText(blob, encoding, (content) => {\n                    const boundary = getMultiPartFormBoundary(contentTypeHeader);\n                    const parts = boundary && includeParts ? getMultiPartFormParts(boundary, content) : [];\n                    content = content.slice(0, MAX_HTTP_BODY_SIZE);\n                    const bodyMessage: IBody = {\n                        size: blob.size,\n                        encoding,\n                        content,\n                        isTruncated: blob.size > content.length\n                    };\n                    if (parts && includeParts) {\n                        bodyMessage.parts = parts;\n                    }\n                    cb(bodyMessage);\n                });\n                break;\n            default:\n                setTimeout(() => cb({\n                    size: blob.size,\n                    encoding,\n                    content: '',\n                    isTruncated: true\n                }), 0);\n                break;\n        }\n    } else {\n        setTimeout(() => cb(createEmptyBody(false)), 0);\n    }\n}\n\n/**\n * Function to convert a string to a map from header-name => string[] of header values\n *\n * @param rawHeaders raw headers string\n */\nfunction convertRawHeaders(rawHeaders: string): { [key: string]: string[] } {\n    const h: { [key: string]: string[] } = {};\n    rawHeaders = rawHeaders.trim();\n    const lines = rawHeaders.split('\\r\\n');\n    lines.forEach((l) => {\n        const idx = l.indexOf(':');\n        if (idx > 0) {\n            const name = l.substring(0, idx).trim().toLowerCase();\n            const value = l.substring(idx + 1, l.length).trim();\n            if (!h[name]) {\n                h[name] = [];\n            }\n            h[name].push(value);\n        }\n    });\n\n    return h;\n}\n\n/**\n * Regular expression to pull boundary delimiter from multipart/form-data content type.\n * valid boundary characters taken from grammar defined in https://www.ietf.org/rfc/rfc2046.txt, Appendix A\n */\nconst MULTIPART_FORMDATA_REG_EX = /\\s*(multipart\\/form-data)\\s*;.*boundary\\s*=\\s*\"?([0-9a-zA-Z'()+_,-.\\/:=?]+)\"?/i;\n\n/**\n * Get the boundary delimiter for a multipart/forma-data content-type header.\n * If boundary paramter doesn't exist, or if content-type is not multipart/form-data\n * this will return undefined;\n *\n * @param contentTypeHeader the value of the Content-Type header\n */\nexport function getMultiPartFormBoundary(contentTypeHeader: string) {\n    const matches = MULTIPART_FORMDATA_REG_EX.exec(contentTypeHeader);\n    if (matches) {\n        return matches[2];\n    }\n    return undefined;\n}\n\n/**\n * Given a multipart-form/data encoded body & a boundary delimiter, this will return an\n * array of IPartSummary interfaces describing the parts.\n *\n * @param boundary The boundary delimiter string used in a multipart/form-data message\n * @param body The text body.\n */\nexport function getMultiPartFormParts(boundary: string, body: string): IPartSummary[] {\n    boundary = '--' + boundary;\n    const firstBoundaryRegExString = `^((\\\\r\\\\n)?${boundary}\\\\s*?\\\\r\\\\n)`;\n    const firstBoundaryRegEx = new RegExp(firstBoundaryRegExString, 'gm');\n\n    // captures:\n    //    $1:  optional header section\n    //    $2:  CRLFCRLF seperating headers & body, or if no headers, separating boundary marker & body\n    //    $3:  body section\n    //    $4:  next boundary marker\n    //    $5:  content after closing boundary\n    //    $6:  \"--\" indicating end of multipart bodies.  If this part matches, then we've found the last boundary delimiter\n    //    $7:  trailing whitespace\n    const partRegExString = `([\\\\s\\\\S]*?)(\\\\r\\\\n\\\\r\\\\n)([\\\\s\\\\S]*?)(\\\\r\\\\n${boundary})((--)|(\\\\s*?\\\\r\\\\n))`;\n    const partRegEx = new RegExp(partRegExString, 'gm');\n\n    const firstBoundary = firstBoundaryRegEx.exec(body);\n    const partSummaries: IPartSummary[] = [];\n    if (firstBoundary) {\n        // start searching for parts immediately after the first boundary reg ex match.  Back up two to include trailing \\r\\n\n        partRegEx.lastIndex = firstBoundaryRegEx.lastIndex - 2;\n        while (true) {\n            const part = partRegEx.exec(body);\n            if (!part) {\n                break;\n            }\n            const headerSectionLength = part[1] ? part[1].length : 0;\n            const bodyStartIndex = part.index + headerSectionLength + part[2].length;\n            const convertedHeaders = part[1] ? convertRawHeaders(part[1]) : {};\n            const bodySectionLength = part[3] ? part[3].length : 0;\n            partSummaries.push({\n                headers: convertedHeaders,\n                bodyStartIndex: part.index + part[1].length + part[2].length,\n                bodyEndIndex: bodyStartIndex + bodySectionLength,\n                bodyLength: bodySectionLength\n            });\n\n            if (part[6]) {\n                // found trailing -- after boundary, which indicates we're done\n                break;\n            }\n        }\n    }\n    return partSummaries;\n}\n\ninterface GlimpsePerformanceResourceTiming extends PerformanceResourceTiming {\n    __glimpse_requestId?: string;\n}\n\n/**\n * Asynchronously attempts to find a PerformanceResourceTiming object that matches the given initiatorType and url and\n * whose startTime is within two milliseconds of `expectedStart` parameter. Specified callback will invoked with the\n * matching PerformanceResourceTiming object, or with undefined if unable to find matching object.\n * Will attempt lookup up to 8 times, with a delay increasing exponentially from 1ms up to 256ms, for a maximum delay of 511ms\n *\n * @param initiatorType A RegExp that will match the expected value for the initiatorType of the target PerformanceResourceTiming instance\n * @param url - expected URL of the target PerformanceResourceTiming instance\n * @param expectedStart - the expected start time for the target PerformanceResourceTiming instance\n * @param cb - callback to invoke when target is found, or when max number of lookup attempts has been made\n */\nexport function tryFindResourceTimingObject(requestId: string, initiatorType: RegExp, url: string, expectedStart: number, cb: (p: PerformanceResourceTiming) => void) {\n    if (!(performance && performance.getEntriesByType)) {\n        setTimeout(() => cb(undefined));\n        return;\n    }\n\n    const maxDelay = 1024; // milliseconds\n    let delay = 1;\n\n    function tryGet() {\n        function computeDelta(p2: PerformanceResourceTiming): number {\n            return Math.abs(p2.startTime - expectedStart);\n        }\n\n        // try to find this request\n        const entries: PerformanceResourceTiming[] = performance.getEntriesByType('resource');\n        let target: GlimpsePerformanceResourceTiming = undefined;\n        let candidates: GlimpsePerformanceResourceTiming[] = [];\n        for (let i = 0; i < entries.length; i++) {\n            const curr = entries[i] as GlimpsePerformanceResourceTiming;\n            if (requestId && curr.__glimpse_requestId === requestId) {\n                // if we've already matched this PerformanceResourceTiming with this specific request, then use it\n                target = curr;\n                break;\n            }\n            else if (initiatorType.test(curr.initiatorType) && curr.name === url && expectedStart <= curr.startTime && !curr.__glimpse_requestId) {\n                candidates.push(curr);\n            }\n        }\n\n        if (!target) {\n            candidates.sort((a, b) => {\n                const deltaA = computeDelta(a);\n                const deltaB = computeDelta(b);\n\n                // sort by smallest delta between startTime & expectedStart\n                return (deltaA - deltaB);\n            });\n\n            if (candidates.length > 0) {\n                target = candidates[0];\n                target.__glimpse_requestId = requestId;\n            }\n        }\n\n        if (target || delay >= maxDelay) {\n            cb(target);\n        }\n        else {\n            delay *= 2;\n            setTimeout(tryGet, delay);\n        }\n\n        return target;\n    }\n\n    setTimeout(tryGet, delay);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/inspectors/HttpRequestUtils.ts","import * as ErrorStackParser from 'error-stack-parser';\n\nexport interface IStackFrame {\n    fileName: string;\n    functionName: string;\n    lineNumber: number;\n    columnNumber: number;\n}\n\nexport function getStackTrace(cb: (frames: IStackFrame[]) => void): void {\n\n    // stacktrace-js library has a Get method that will try to apply sourcemaps, however\n    // that will trigger a download of the source, and will show up as an XHR request\n    // in glimpse, which we don't want.  When we disable source-maps, then\n    // stacktrace-js will reject a promise, which causes undesired debugger breakpoints\n    // when the user has their app open in f12 tools. The easiest thing here is to put\n    // generate the error ourself, and use the error-stack-parser library to parse the\n    // error into stack frames.\n\n    // this logic to get an error comes from stacktrace-js library.\n    // See https://github.com/stacktracejs/stacktrace.js/blob/master/stacktrace.js#L25-L32\n    function getError() {\n        let err = new Error();\n        if (!err.stack) {\n            try {\n                // Error must be thrown to get stack in IE\n                throw new Error();\n            } catch (e2) {\n                err = e2;\n            }\n        }\n        return err;\n    }\n\n    let stackFrames = ErrorStackParser.parse(getError());\n\n    // slice off top frames where glimpse code is on the stack.\n    for (let i = 0; i < stackFrames.length; i++) {\n        if (stackFrames[i].fileName && !stackFrames[i].fileName.endsWith('/glimpse/agent/agent.js?hash={hash}')) {\n            stackFrames = stackFrames.slice(i);\n            break;\n        }\n    }\n\n    // strip out any extra properties we don't want to send w/ the glimpse message\n    const newFrames: IStackFrame[] = [];\n    stackFrames.forEach((val: ErrorStackParser.StackFrame, index: number) => {\n        newFrames[index] = {\n            fileName: val.fileName,\n            functionName: val.functionName,\n            lineNumber: val.lineNumber,\n            columnNumber: val.columnNumber\n        };\n    });\n\n    // various tests are expecting this to run asynchronously, which we'll eventually need if we ever hook up\n    // source maps.  Even though we don't need it today, we'll leave this as an async function.\n    window.setTimeout(() => { cb(newFrames); }, 0);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/CallStackUtilities.ts","(function(root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('error-stack-parser', ['stackframe'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('stackframe'));\n    } else {\n        root.ErrorStackParser = factory(root.StackFrame);\n    }\n}(this, function ErrorStackParser(StackFrame) {\n    'use strict';\n\n    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+\\:\\d+/;\n    var CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+\\:\\d+|\\(native\\))/m;\n    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code\\])?$/;\n\n    return {\n        /**\n         * Given an Error object, extract the most information from it.\n         *\n         * @param {Error} error object\n         * @return {Array} of StackFrames\n         */\n        parse: function ErrorStackParser$$parse(error) {\n            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n                return this.parseOpera(error);\n            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n                return this.parseV8OrIE(error);\n            } else if (error.stack) {\n                return this.parseFFOrSafari(error);\n            } else {\n                throw new Error('Cannot parse given Error object');\n            }\n        },\n\n        // Separate line and column numbers from a string of the form: (URI:Line:Column)\n        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n            // Fail-fast but return locations like \"(native)\"\n            if (urlLike.indexOf(':') === -1) {\n                return [urlLike];\n            }\n\n            var regExp = /(.+?)(?:\\:(\\d+))?(?:\\:(\\d+))?$/;\n            var parts = regExp.exec(urlLike.replace(/[\\(\\)]/g, ''));\n            return [parts[1], parts[2] || undefined, parts[3] || undefined];\n        },\n\n        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n            var filtered = error.stack.split('\\n').filter(function(line) {\n                return !!line.match(CHROME_IE_STACK_REGEXP);\n            }, this);\n\n            return filtered.map(function(line) {\n                if (line.indexOf('(eval ') > -1) {\n                    // Throw away eval information until we implement stacktrace.js/stackframe#8\n                    line = line.replace(/eval code/g, 'eval').replace(/(\\(eval at [^\\()]*)|(\\)\\,.*$)/g, '');\n                }\n                var tokens = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '(').split(/\\s+/).slice(1);\n                var locationParts = this.extractLocation(tokens.pop());\n                var functionName = tokens.join(' ') || undefined;\n                var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];\n\n                return new StackFrame({\n                    functionName: functionName,\n                    fileName: fileName,\n                    lineNumber: locationParts[1],\n                    columnNumber: locationParts[2],\n                    source: line\n                });\n            }, this);\n        },\n\n        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n            var filtered = error.stack.split('\\n').filter(function(line) {\n                return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n            }, this);\n\n            return filtered.map(function(line) {\n                // Throw away eval information until we implement stacktrace.js/stackframe#8\n                if (line.indexOf(' > eval') > -1) {\n                    line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval\\:\\d+\\:\\d+/g, ':$1');\n                }\n\n                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n                    // Safari eval frames only have function names and nothing else\n                    return new StackFrame({\n                        functionName: line\n                    });\n                } else {\n                    var tokens = line.split('@');\n                    var locationParts = this.extractLocation(tokens.pop());\n                    var functionName = tokens.join('@') || undefined;\n\n                    return new StackFrame({\n                        functionName: functionName,\n                        fileName: locationParts[0],\n                        lineNumber: locationParts[1],\n                        columnNumber: locationParts[2],\n                        source: line\n                    });\n                }\n            }, this);\n        },\n\n        parseOpera: function ErrorStackParser$$parseOpera(e) {\n            if (!e.stacktrace || (e.message.indexOf('\\n') > -1 &&\n                e.message.split('\\n').length > e.stacktrace.split('\\n').length)) {\n                return this.parseOpera9(e);\n            } else if (!e.stack) {\n                return this.parseOpera10(e);\n            } else {\n                return this.parseOpera11(e);\n            }\n        },\n\n        parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n            var lines = e.message.split('\\n');\n            var result = [];\n\n            for (var i = 2, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    result.push(new StackFrame({\n                        fileName: match[2],\n                        lineNumber: match[1],\n                        source: lines[i]\n                    }));\n                }\n            }\n\n            return result;\n        },\n\n        parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n            var lines = e.stacktrace.split('\\n');\n            var result = [];\n\n            for (var i = 0, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    result.push(\n                        new StackFrame({\n                            functionName: match[3] || undefined,\n                            fileName: match[2],\n                            lineNumber: match[1],\n                            source: lines[i]\n                        })\n                    );\n                }\n            }\n\n            return result;\n        },\n\n        // Opera 10.65+ Error.stack very similar to FF/Safari\n        parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n            var filtered = error.stack.split('\\n').filter(function(line) {\n                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n            }, this);\n\n            return filtered.map(function(line) {\n                var tokens = line.split('@');\n                var locationParts = this.extractLocation(tokens.pop());\n                var functionCall = (tokens.shift() || '');\n                var functionName = functionCall\n                        .replace(/<anonymous function(: (\\w+))?>/, '$2')\n                        .replace(/\\([^\\)]*\\)/g, '') || undefined;\n                var argsRaw;\n                if (functionCall.match(/\\(([^\\)]*)\\)/)) {\n                    argsRaw = functionCall.replace(/^[^\\(]+\\(([^\\)]*)\\)$/, '$1');\n                }\n                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?\n                    undefined : argsRaw.split(',');\n\n                return new StackFrame({\n                    functionName: functionName,\n                    args: args,\n                    fileName: locationParts[0],\n                    lineNumber: locationParts[1],\n                    columnNumber: locationParts[2],\n                    source: line\n                });\n            }, this);\n        }\n    };\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/error-stack-parser/error-stack-parser.js\n// module id = 19\n// module chunks = 0","(function(root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('stackframe', [], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        root.StackFrame = factory();\n    }\n}(this, function() {\n    'use strict';\n    function _isNumber(n) {\n        return !isNaN(parseFloat(n)) && isFinite(n);\n    }\n\n    function _capitalize(str) {\n        return str[0].toUpperCase() + str.substring(1);\n    }\n\n    function _getter(p) {\n        return function() {\n            return this[p];\n        };\n    }\n\n    var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];\n    var numericProps = ['columnNumber', 'lineNumber'];\n    var stringProps = ['fileName', 'functionName', 'source'];\n    var arrayProps = ['args'];\n\n    var props = booleanProps.concat(numericProps, stringProps, arrayProps);\n\n    function StackFrame(obj) {\n        if (obj instanceof Object) {\n            for (var i = 0; i < props.length; i++) {\n                if (obj.hasOwnProperty(props[i]) && obj[props[i]] !== undefined) {\n                    this['set' + _capitalize(props[i])](obj[props[i]]);\n                }\n            }\n        }\n    }\n\n    StackFrame.prototype = {\n        getArgs: function() {\n            return this.args;\n        },\n        setArgs: function(v) {\n            if (Object.prototype.toString.call(v) !== '[object Array]') {\n                throw new TypeError('Args must be an Array');\n            }\n            this.args = v;\n        },\n\n        getEvalOrigin: function() {\n            return this.evalOrigin;\n        },\n        setEvalOrigin: function(v) {\n            if (v instanceof StackFrame) {\n                this.evalOrigin = v;\n            } else if (v instanceof Object) {\n                this.evalOrigin = new StackFrame(v);\n            } else {\n                throw new TypeError('Eval Origin must be an Object or StackFrame');\n            }\n        },\n\n        toString: function() {\n            var functionName = this.getFunctionName() || '{anonymous}';\n            var args = '(' + (this.getArgs() || []).join(',') + ')';\n            var fileName = this.getFileName() ? ('@' + this.getFileName()) : '';\n            var lineNumber = _isNumber(this.getLineNumber()) ? (':' + this.getLineNumber()) : '';\n            var columnNumber = _isNumber(this.getColumnNumber()) ? (':' + this.getColumnNumber()) : '';\n            return functionName + args + fileName + lineNumber + columnNumber;\n        }\n    };\n\n    for (var i = 0; i < booleanProps.length; i++) {\n        StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);\n        StackFrame.prototype['set' + _capitalize(booleanProps[i])] = (function(p) {\n            return function(v) {\n                this[p] = Boolean(v);\n            };\n        })(booleanProps[i]);\n    }\n\n    for (var j = 0; j < numericProps.length; j++) {\n        StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);\n        StackFrame.prototype['set' + _capitalize(numericProps[j])] = (function(p) {\n            return function(v) {\n                if (!_isNumber(v)) {\n                    throw new TypeError(p + ' must be a Number');\n                }\n                this[p] = Number(v);\n            };\n        })(numericProps[j]);\n    }\n\n    for (var k = 0; k < stringProps.length; k++) {\n        StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);\n        StackFrame.prototype['set' + _capitalize(stringProps[k])] = (function(p) {\n            return function(v) {\n                this[p] = String(v);\n            };\n        })(stringProps[k]);\n    }\n\n    return StackFrame;\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/stackframe/stackframe.js\n// module id = 20\n// module chunks = 0","import logger from '../common/GlimpseLogger';\nimport { IInspector } from './IInspector';\nimport { IMessagePublisher } from '../MessagePublisher';\nimport { IProxyEvent } from '../tracing/IProxyEvent';\nimport { addOffset } from '../common/MessageMixins';\nimport {\n    IRequestSentEvent, EVENT_FETCH_REQUEST_SENT,\n    IResponseReceivedEvent, EVENT_FETCH_RESPONSE_RECEIVED,\n    EVENT_FETCH_ERROR\n} from '../tracing/proxies/FetchProxy';\nimport tracing from '../tracing/Tracing';\nimport { getDateTime } from '../common/DateTimeUtilities';\nimport { parseUrl, getHeaderKeys } from '../common/RequestUtilities';\nimport {\n    tryFindResourceTimingObject,\n    IBody,\n    IPartSummary,\n    getMultiPartFormBoundary,\n    getMultiPartFormParts,\n    createBodyForBlob,\n    createEmptyBody\n} from './HttpRequestUtils';\nimport { getStackTrace } from '../common/CallStackUtilities';\n\ninterface IRequestCacheEntry {\n    startTimeStamp: number;\n    startTimeOffset: number;\n}\n\nexport class FetchInspector implements IInspector {\n\n    private initiatorRexExp = /(^$)|(other)/i;\n\n    private messagePublisher: IMessagePublisher;\n\n    private requests: { [id: string]: IRequestCacheEntry } = {};\n\n    private createHeaders(headers: Headers): { [header: string]: string } {\n        const parsedHeaders = {};\n        const headerKeys = getHeaderKeys(headers);\n        for (const header of headerKeys) {\n            parsedHeaders[header] = headers.get(header);\n        }\n        return parsedHeaders;\n    }\n\n    private getContentTypeHeader(headers: Headers): string {\n        let val: string;\n        val = headers.get('content-type');\n        if (!val) {\n            const headerKeys = getHeaderKeys(headers);\n            for (const header of headerKeys) {\n                if (header.toLowerCase() === 'content-type') {\n                    val = headers[header];\n                    break;\n                }\n            }\n        }\n        return val;\n    }\n\n    private before(event: IProxyEvent) {\n        const eventData: IRequestSentEvent = event.data;\n\n        getStackTrace((frames) => {\n            const publishMessage = (body: IBody) => {\n                const url = parseUrl(eventData.request.url);\n                const startTime = getDateTime(new Date(event.timeStamp));\n                const msg = this.messagePublisher.createMessage(['data-http-request', 'call-stack'], {\n                    correlationId: eventData.id,\n                    protocol: {\n                        identifier: url.protocol.replace(/\\:$/, '').toLowerCase()\n                    },\n                    url: eventData.request.url,\n                    method: eventData.request.method,\n                    startTime,\n                    timing: {\n                        startTime: 0\n                    },\n                    headers: this.createHeaders(eventData.request.headers),\n                    isAjax: true,\n                    body,\n                    frames: frames.slice(0, 1)\n                });\n                addOffset(event.offset, msg);\n                this.messagePublisher.publishMessage(msg);\n            };\n\n            eventData.request\n                .blob()\n                .then(\n                blob => {\n                    const contentTypeHeader = this.getContentTypeHeader(eventData.request.headers);\n                    createBodyForBlob(contentTypeHeader, blob, true, body => {\n                        publishMessage(body);\n                    });\n                },\n                reason => {\n                    // Safari 10.1 fails to obtain the request body as a blob, so publish the message with a \"truncated\" body...\n                    // (https://github.com/Glimpse/Glimpse.Browser.Agent/issues/192)\n                    publishMessage(createEmptyBody(/* truncated: */ true));\n                });\n        });\n    }\n\n    private after(event: IProxyEvent, requestEntry: IRequestCacheEntry) {\n        const eventData: IResponseReceivedEvent = event.data;\n        eventData.response.blob().then((blob) => {\n            const responseEndOffset = performance.now();\n\n            // for fetch events, the initiator type is an empty string on chrome, and 'other' on firefox.\n\n            tryFindResourceTimingObject(event.data.id, this.initiatorRexExp, event.data.response.url, requestEntry.startTimeOffset, (timings: PerformanceResourceTiming) => {\n\n                // we make a best-effort to find the PerformanceResourceTiming instance associated with this request.  If we have one,\n                // we use it, but if not, we fall back to using times associated with when different proxy methods were invoked\n                const offset = timings ? timings.startTime : requestEntry.startTimeOffset;\n                const startTime = 0;\n                // leave responseStart undefined if no timings instance since this is optional and we don't know accurate value\n                const responseStart = timings && (timings.responseStart >= timings.startTime) ? (timings.responseStart - timings.startTime) : undefined;\n                const responseEnd = timings ? (timings.responseEnd - timings.startTime) : (responseEndOffset - requestEntry.startTimeOffset);\n\n                const contentTypeHeader = this.getContentTypeHeader(eventData.response.headers);\n                createBodyForBlob(contentTypeHeader, blob, true, (body) => {\n                    let statusCode: number;\n                    switch (eventData.response.type) {\n                        case 'error':\n                            // TODO: publish an error message here. See https://github.com/Glimpse/Glimpse.Browser.Agent/issues/134\n                            return;\n                        case 'opaque':\n                            statusCode = -1;\n                            break;\n                        case 'opaqueredirect':\n                            statusCode = -2;\n                            break;\n                        default:\n                            statusCode = eventData.response.status;\n                            break;\n                    }\n\n                    const msg = this.messagePublisher.createMessage('data-http-response', {\n                        correlationId: eventData.id,\n                        url: eventData.response.url,\n                        headers: this.createHeaders(eventData.response.headers),\n                        statusCode,\n                        statusMessage: eventData.response.statusText,\n                        endTime: getDateTime(new Date(event.timeStamp)),\n                        duration: responseEnd,\n                        timing: {\n                            startTime,\n                            responseEnd\n                        },\n                        body\n                    });\n\n                    if (responseStart !== undefined) {\n                        msg.payload.timing.responseStart = responseStart;\n                    }\n\n                    addOffset(offset, msg);\n                    this.messagePublisher.publishMessage(msg);\n                });\n            });\n        });\n    }\n\n    public numOutstandingRequests() {\n        return Object.keys(this.requests).length;\n    }\n\n    public init(messagePublisher: IMessagePublisher) {\n        this.messagePublisher = messagePublisher;\n\n        tracing.on(EVENT_FETCH_REQUEST_SENT, (event: IProxyEvent) => {\n            this.requests[event.data.id] = {\n                startTimeStamp: event.timeStamp,\n                startTimeOffset: event.offset\n            };\n            this.before(event);\n        });\n\n        tracing.on(EVENT_FETCH_RESPONSE_RECEIVED, (event: IProxyEvent) => {\n            const requestEntry = this.requests[event.data.id];\n            if (!requestEntry) {\n                logger.error('Glimpse Internal Error: could not find associated master data, some inspection data will be lost.');\n                return;\n            }\n            this.after(event, requestEntry);\n            delete this.requests[event.data.id];\n        });\n\n        tracing.on(EVENT_FETCH_ERROR, (data: IProxyEvent) => {\n            delete this.requests[data.data.id];\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/inspectors/FetchInspector.ts","import { IProxy } from '../IProxy';\nimport tracing from '../Tracing';\nimport { getGuid } from '../../common/GeneralUtilities';\n\n/**\n * This event indicates that a request was sent, as indicated by a call to\n * `self.fetch()`\n *\n * @property {string} id - An ID that is consistent for all stages of this request\n * @property {Request} request - A request object representing the user request.\n *      Note: this is always a request object, regardless of how the fetch API\n *      was called. If a request object was passed to the `fetch()` method, this\n *      request object is a clone of that one, not the original instance.\n */\nexport interface IRequestSentEvent {\n    id: string;\n    request: Request;\n}\nexport const EVENT_FETCH_REQUEST_SENT = 'invoke|pre|fetch.request-sent';\n\n/**\n * This event indicates that a response was received. This event is fired when\n * the promise returned from a call to `self.fetch()` is resolved (not rejected).\n *\n * @property {string} id - An ID that is consistent for all stages of this request\n * @property {Response} response - The response object. Note: this response object\n *      is a cloned copy of the response object that the original promise returned,\n *      not the original instance.\n */\nexport interface IResponseReceivedEvent {\n    id: string;\n    response: Response;\n}\nexport const EVENT_FETCH_RESPONSE_RECEIVED = 'notify|fetch.response-received';\n\n/**\n * This event indicates an error happened during the request, which is done\n * by waiting for the promise returned by `fetch()` to reject. There is a caveat\n * though: rejections caused by malformed input does _not_ cause an error event\n * to be emitted. This is by design, as this error condition means no request\n * was ever sent at all, even if the promise returned from `fetch()` _does_ reject.\n *\n * @property {string} id - An ID that is consistent for all stages of this request\n * @property {XMLHttpRequest} xhr - The XMLHttpRequest instance\n * @property {error} error - A description of the error, if one is available\n */\nexport interface IErrorEvent {\n    id: string;\n    error: string | Error;\n}\nexport const EVENT_FETCH_ERROR = 'notify|fetch.error';\n\n/**\n * Proxy which wraps fetch usage and its various supporting functions.\n *\n * NOTE: Don't add any headers within this proxy, breaks CORS scenarioes.\n */\nexport class FetchProxy implements IProxy {\n    public isSupported(): boolean {\n        return !!(self && typeof self.fetch !== 'undefined');\n    }\n\n    public init() {\n        // Note: we use `self` instead of `window` in case we're in a worker thread\n        // See https://developer.mozilla.org/en-US/docs/Web/API/Window/self\n\n        // Only initialize if this browser supports the Fetch API\n        if (self.fetch) {\n            const oldFetch = self.fetch;\n            self.fetch = function fetch(input, init, ...args) {\n                // Create a request object if one wasn't specified, or clone the\n                // existing one if it was so we can safely read the body.\n                let request;\n                if (input instanceof Request) {\n                    request = input.clone();\n                } else {\n                    // OK, so I know this looks weird, but the use of Promises\n                    // here provides a unique challenge. If you instantiate a\n                    // Request object directly, it will throw an exception if the\n                    // input is malformed. However, the `fetch()` API is wrapped\n                    // in a promise, which means malformed input does _not_ throw\n                    // when passed to `fetch()`. Instead it causes the promise to\n                    // reject. We do _not_ want to pick up on this case though,\n                    // because we would otherwise publish an ERROR_EVENT, which\n                    // we do _not_ want in this case. So we detect malformed input,\n                    // and return the promise directly without listening to it.\n                    try {\n                        request = new Request(input, init);\n                    } catch (e) {\n                        return oldFetch.call(this, input, init, ...args);\n                    }\n                }\n\n                const id = getGuid();\n\n                // Publish the request message\n                const requestSentEventData: IRequestSentEvent = {\n                    id,\n                    request\n                };\n                tracing.publish(EVENT_FETCH_REQUEST_SENT, requestSentEventData);\n\n                // Call the original fetch method. We wait for the response to be\n                // received using the promise, and publish the resulting\n                const fetchPromise = oldFetch.call(this, input, init, ...args);\n                fetchPromise.then((response) => {\n                    const responseReceivedEventData: IResponseReceivedEvent = {\n                        id,\n                        response: response.clone()\n                    };\n                    tracing.publish(EVENT_FETCH_RESPONSE_RECEIVED, responseReceivedEventData);\n                }, (error) => {\n                    const errorEventData: IErrorEvent = {\n                        id,\n                        error\n                    };\n                    tracing.publish(EVENT_FETCH_ERROR, errorEventData);\n                });\n\n                return fetchPromise;\n            };\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/tracing/proxies/FetchProxy.ts","import { IInspector } from './IInspector';\nimport { IMessagePublisher } from '../MessagePublisher';\nimport { IProxyEvent } from '../tracing/IProxyEvent';\nimport { EVENT_RESOURCE_TIMING_COLLECTED } from '../tracing/proxies/ResourceTimingProxy';\nimport tracing from '../tracing/Tracing';\n\nexport class ResourceTimingInspector implements IInspector {\n    public init(messagePublisher: IMessagePublisher) {\n        tracing.on(EVENT_RESOURCE_TIMING_COLLECTED, (event: IProxyEvent) => {\n            // TODO: Eventually, we'll add more logic here to clean up data in\n            // https://github.com/Glimpse/Glimpse.Browser.Agent/issues/29.\n            messagePublisher.createAndPublishMessage('browser-resource', {\n                timings: event.data\n            });\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/inspectors/ResourceTimingInspector.ts","import { IProxy } from '../IProxy';\nimport tracing from '../Tracing';\nimport { getMessageIngressUrl } from '../../common/RequestUtilities';\nimport performance from '../../common/PerformanceUtilities';\n\nconst UPDATE_INTERVAL = 1000;\n\n/**\n * @property {string} name - The fully resolved URL of the resource\n * @property {number} startTime - The amount of time that has elapsed since the\n *      time origin of the browser, typically page load\n * @property {number} duration - The amount of time it took to fetch the resource\n * @property {string} initiatorType - The type of resource, e.g. 'css', 'img', etc.\n * @property {string} nextHopProtocol - The protocol used by the browser to fetch\n *      the resource, e.g. 'HTTP/1'\n * @property {number} redirectStart - The timestamp of the start of a redirect\n * @property {number} redirectEnd - The timestamp of the end of a redirect\n * @property {number} fetchStart - The timestamp of the start of a fetch request\n * @property {number} domainLookupStart - The timestamp of the start of a DNS lookup\n * @property {number} domainLookupEnd - The timestamp of the end of a DNS lookup\n * @property {number} connectStart - The timestamp of the start of a TCP connection\n *      being made\n * @property {number} connectEnd - The timestamp of the end of a TCP connection\n *      being made\n * @property {number} secureConnectionStart - The timestamp of the start of a\n *      secure TLS connection being made\n * @property {number} requestStart - The timestamp of the start the HTTP request\n * @property {number} responseStart - The timestamp of the start the HTTP response\n * @property {number} responseEnd - The timestamp of the end the HTTP response\n * @property {number} transferSize - The size of the entire response, including headers, body, etc.\n * @property {number} encodedBodySize - The size of the response body before decoding, e.g. gzipped size\n * @Property {number} decodedBodySize - The size of the response body after decoding\n */\nexport interface IResourceTimingCollectionEvent {\n    name: string;\n    startTime: number;\n    duration: number;\n    initiatorType: string;\n    nextHopProtocol: string;\n    redirectStart: number;\n    redirectEnd: number;\n    fetchStart: number;\n    domainLookupStart: number;\n    domainLookupEnd: number;\n    connectStart: number;\n    connectEnd: number;\n    secureConnectionStart: number;\n    requestStart: number;\n    responseStart: number;\n    responseEnd: number;\n    transferSize: number;\n    encodedBodySize: number;\n    decodedBodySize: number;\n}\nexport const EVENT_RESOURCE_TIMING_COLLECTED = 'notify|performance.resource-collected';\n\nexport class ResourceTimingProxy implements IProxy {\n    public isSupported(): boolean {\n        // Don't initialize if this browser doesn't support resource timing\n        return !!(performance && performance.getEntriesByType);\n    }\n\n    public init() {\n        function processEntry(entry): IResourceTimingCollectionEvent {\n            // This sheds any extra properties that may be introduced to resource timing\n            // or are browser specific, and ensures the data matches our interface for it.\n            return {\n                name: entry.name,\n                startTime: entry.startTime,\n                duration: entry.duration,\n                initiatorType: entry.initiatorType,\n                nextHopProtocol: entry.nextHopProtocol,\n                redirectStart: entry.redirectStart,\n                redirectEnd: entry.redirectEnd,\n                fetchStart: entry.fetchStart,\n                domainLookupStart: entry.domainLookupStart,\n                domainLookupEnd: entry.domainLookupEnd,\n                connectStart: entry.connectStart,\n                connectEnd: entry.connectEnd,\n                secureConnectionStart: entry.secureConnectionStart,\n                requestStart: entry.requestStart,\n                responseStart: entry.responseStart,\n                responseEnd: entry.responseEnd,\n                transferSize: entry.transferSize,\n                encodedBodySize: entry.encodedBodySize,\n                decodedBodySize: entry.decodedBodySize\n            };\n        }\n\n        // Eventually we want to switch to using Performance Observers once browsers\n        // start to implement, but currently none do, so we poll for entries instead\n        // https://w3c.github.io/performance-timeline/#dom-performanceobserver\n        const reportedEntries = {};\n        function record() {\n            const resources = performance.getEntriesByType('resource');\n            const entriesToPublish = [];\n            const ingressUrl = getMessageIngressUrl();\n            for (const resource of resources) {\n                // Create a unique id for the entry, a combination of the start time\n                // and resolved URL\n                const id = `${resource.startTime}#${resource.name}`;\n                if (!reportedEntries[id] && resource.name.indexOf(ingressUrl) === -1) {\n                    reportedEntries[id] = true;\n                    entriesToPublish.push(processEntry(resource));\n                }\n            }\n            if (entriesToPublish.length) {\n                tracing.publish(EVENT_RESOURCE_TIMING_COLLECTED, entriesToPublish);\n            }\n            setTimeout(record, UPDATE_INTERVAL);\n        };\n        record();\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/tracing/proxies/ResourceTimingProxy.ts","function getPerformance(): Performance {\n    // tslint:disable:no-any\n    return window.performance ||\n        (<any>window).webkitPerformance ||\n        (<any>window).msPerformance ||\n        (<any>window).mozPerformance;\n}\n\nexport default getPerformance();\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/PerformanceUtilities.ts","import { IInspector } from './IInspector';\nimport { IMessagePublisher } from '../MessagePublisher';\nimport { IProxyEvent } from '../tracing/IProxyEvent';\nimport { EVENT_NAVIGATION_TIMING_COLLECTED, INavigationTimingCollectionEvent } from '../tracing/proxies/NavigationTimingProxy';\nimport tracing from '../tracing/Tracing';\n\nexport class NavigationTimingInspector implements IInspector {\n    public init(messagePublisher: IMessagePublisher) {\n        tracing.on(EVENT_NAVIGATION_TIMING_COLLECTED, (event: IProxyEvent) => {\n            const data: INavigationTimingCollectionEvent = event.data;\n            const message = {\n                loadDuration: data.loadEventEnd - data.fetchStart,\n                // time spent constructing the DOM tree\n                domReadyDuration: data.domComplete - data.domInteractive,\n                // time consumed preparing the new page\n                readyStartDuration: data.fetchStart - data.navigationStart,\n                // time spent during redirection\n                redirectDuration: data.redirectEnd - data.redirectStart,\n                // appCache\n                appcacheDuration: data.domainLookupStart - data.fetchStart,\n                // time spent unloading documents\n                unloadEventDuration: data.unloadEventEnd - data.unloadEventStart,\n                // DNS query time\n                lookupDomainDuration: data.domainLookupEnd - data.domainLookupStart,\n                // TCP connection time\n                connectDuration: data.connectEnd - data.connectStart,\n                // time spent during the request\n                requestDuration: data.responseEnd - data.requestStart,\n                // request to completion of the DOM loading\n                initDomTreeDuration: data.domInteractive - data.responseEnd,\n                // load event time\n                loadEventDuration: data.loadEventEnd - data.loadEventStart,\n\n                // time spent on the network making the outgoing request\n                networkRequestDuration: data.requestStart - data.navigationStart,\n                // time spent on the network receiving the incoming response\n                networkResponseDuration: data.responseEnd - data.responseStart,\n                // time spent on the server processing the request\n                serverDuration: data.responseEnd - data.requestStart,\n                // time spent on the browser handling the response\n                browserDuration: data.loadEventEnd - data.responseStart,\n                // total time\n                totalDuration: data.loadEventEnd - data.navigationStart,\n\n                ...event.data\n            };\n            // time spent on the network for the whole request/response\n            message.networkDuration = message.networkRequestDuration + message.networkResponseDuration;\n\n            // TODO: Eventually, we'll add more logic here to clean up data in\n            // https://github.com/Glimpse/Glimpse.Browser.Agent/issues/29.\n            messagePublisher.createAndPublishMessage('browser-navigation-timing', message);\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/inspectors/NavigationTimingInspector.ts","import { IProxy } from '../IProxy';\nimport tracing from '../Tracing';\nimport { getMessageIngressUrl } from '../../common/RequestUtilities';\nimport performance from '../../common/PerformanceUtilities';\nimport { addEvent } from '../../common/RequestUtilities';\n\nexport interface INavigationTimingCollectionEvent {\n    connectEnd: number;\n    connectStart: number;\n    domComplete: number;\n    domContentLoadedEventEnd: number;\n    domContentLoadedEventStart: number;\n    domInteractive: number;\n    domLoading: number;\n    domainLookupEnd: number;\n    domainLookupStart: number;\n    fetchStart: number;\n    firstPaint: number;\n    firstPaintDuration?: number;\n    loadEventEnd: number;\n    loadEventStart: number;\n    navigationStart: number;\n    redirectEnd: number;\n    redirectStart: number;\n    requestStart: number;\n    responseEnd: number;\n    responseStart: number;\n    secureConnectionStart: number;\n    unloadEventEnd: number;\n    unloadEventStart: number;\n}\nexport const EVENT_NAVIGATION_TIMING_COLLECTED = 'notify|performance.navigation-timing';\n\nexport class NavigationTimingProxy implements IProxy {\n    public isSupported(): boolean {\n        return !!(performance && performance.timing);\n    }\n\n    public init() {\n        // setup/regiter strategy to run later\n        addEvent(window, 'load', () => {\n            setTimeout(() => {\n                this.processTimings(performance.timing);\n            });\n        });\n    }\n\n    private processEntry(entry: PerformanceTiming): INavigationTimingCollectionEvent {\n        // This sheds any extra properties that may be introduced to navigation\n        // timing or are browser specific, and ensures the data matches our\n        // interface for it.\n        return {\n            connectEnd: entry.connectEnd,\n            connectStart: entry.connectStart,\n            domComplete: entry.domComplete,\n            domContentLoadedEventEnd: entry.domContentLoadedEventEnd,\n            domContentLoadedEventStart: entry.domContentLoadedEventStart,\n            domInteractive: entry.domInteractive,\n            domLoading: entry.domLoading,\n            domainLookupEnd: entry.domainLookupEnd,\n            domainLookupStart: entry.domainLookupStart,\n            fetchStart: entry.fetchStart,\n            firstPaint: (<any>entry).firstPaint,  //tslint:disable-line:no-any\n            firstPaintDuration: 0,\n            loadEventEnd: entry.loadEventEnd,\n            loadEventStart: entry.loadEventStart,\n            navigationStart: entry.navigationStart,\n            redirectEnd: entry.redirectEnd,\n            redirectStart: entry.redirectStart,\n            requestStart: entry.requestStart,\n            responseEnd: entry.responseEnd,\n            responseStart: entry.responseStart,\n            secureConnectionStart: entry.secureConnectionStart,\n            unloadEventEnd: entry.unloadEventEnd,\n            unloadEventStart: entry.unloadEventStart\n        };\n    }\n\n    private processTimings(timing: PerformanceTiming) {\n        const eventData = this.processEntry(timing);\n\n        // time to first paint\n        // tslint:disable-next-line:no-any\n        if ((<any>eventData).firstPaint === undefined) {\n            // All times are relative times to the start time within the\n            // same objects\n            let firstPaint = 0;\n            let firstPaintDuration = 0;\n\n            //tslint:disable-next-line:no-any\n            if ((<any>window).chrome && (<any>window).chrome.loadTimes) {\n                //tslint:disable-next-line:no-any\n                const loadTimes = (<any>window).chrome.loadTimes();\n                firstPaint = loadTimes.firstPaintTime * 1000;\n                firstPaintDuration = firstPaint - loadTimes.startLoadTime * 1000;\n            } else if (typeof timing.msFirstPaint === 'number') {\n                firstPaint = timing.msFirstPaint;\n                firstPaintDuration = firstPaint - timing.navigationStart;\n            }\n            eventData.firstPaint = firstPaint;\n            eventData.firstPaintDuration = firstPaintDuration;\n        }\n\n        tracing.publish(EVENT_NAVIGATION_TIMING_COLLECTED, eventData);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/tracing/proxies/NavigationTimingProxy.ts","import { NOTIFY_CONSOLE_EVENT_OCCURED, IConsoleEvent } from '../tracing/proxies/ConsoleProxy';\n\nimport { IInspector } from './IInspector';\nimport { IMessagePublisher, IMessage } from '../MessagePublisher';\nimport { IProxyEvent } from '../tracing/IProxyEvent';\nimport tracing from '../tracing/Tracing';\nimport { getGuid } from '../common/GeneralUtilities';\nimport { addCorrelationBegin, addCorrelationEnd, addOffset } from '../common/MessageMixins';\nimport { getStackTrace } from '../common/CallStackUtilities';\n\nexport enum LogMessageTypes {\n    json,\n    xml,\n    table,\n    assert,\n    count,\n    timespan_begin,\n    timespan_end,\n    group_begin,\n    group_end\n}\n\ninterface IConsoleData {\n    method: string;\n    arguments: any[]; // tslint:disable-line:no-any\n    offset: number;\n}\n\ninterface InspectionMethods {\n    [key: string]: {\n        level: string;\n        nullByPass?: boolean,\n        tokenTypeByPass?: boolean,\n        processor?: (message: IMessage, data: IConsoleData) => boolean | void;\n    };\n}\n\nexport class ConsoleInspector implements IInspector {\n    private countMap = {};\n\n    private stack = {\n        group: [],\n        profile: []\n    };\n\n    private map = {\n        time: {}\n    };\n\n    private mapNull = {\n        time: undefined\n    };\n\n    public methods: InspectionMethods = {\n        assert: {\n            level: 'Error',\n            processor: (message, data) => this.assert(message, data)\n        },\n        count: {\n            level: 'Debug',\n            processor: (message, data) => this.count(message, data),\n            tokenTypeByPass: true\n        },\n        debug: {\n            level: 'Debug',\n            nullByPass: true\n        },\n        dir: {\n            level: 'Log',\n            nullByPass: true,\n            processor: (message, data) => this.dir(message, data, LogMessageTypes.json),\n            tokenTypeByPass: true\n        },\n        dirxml: {\n            level: 'Log',\n            nullByPass: true,\n            processor: (message, data) => this.dir(message, data, LogMessageTypes.xml),\n            tokenTypeByPass: true\n        },\n        error: {\n            level: 'Error',\n            nullByPass: true\n        },\n        group: {\n            level: undefined,\n            processor: (message, data) => this.groupStart(message, data, false)\n        },\n        groupCollapsed: {\n            level: undefined,\n            processor: (message, data) => this.groupStart(message, data, true)\n        },\n        groupEnd: {\n            level: undefined,\n            processor: (message, data) => this.groupEnd(message, data)\n        },\n        info: {\n            level: 'Info',\n            nullByPass: true\n        },\n        log: {\n            level: 'Log',\n            nullByPass: true\n        },\n        profile: {\n            level: 'Debug',\n            processor: (message, data) => this.profileStart(message, data),\n            tokenTypeByPass: true\n        },\n        profileEnd: {\n            level: 'Debug',\n            processor: (message, data) => this.profileEnd(message, data),\n            tokenTypeByPass: true\n        },\n        table: {\n            level: 'Log',\n            nullByPass: true,\n            processor: (message, data) => this.applyType(message, data, LogMessageTypes.table),\n            tokenTypeByPass: true\n        },\n        time: {\n            level: 'Debug',\n            processor: (message, data) => this.mapStart('time', message, data, LogMessageTypes.timespan_begin),\n            tokenTypeByPass: true\n        },\n        timeEnd: {\n            level: 'Debug',\n            processor: (message, data) => this.mapEnd('time', message, data, LogMessageTypes.timespan_end),\n            tokenTypeByPass: true\n        },\n        timeStamp: {\n            level: 'Debug',\n            processor: (message, data) => this.timeStamp(message, data),\n            tokenTypeByPass: true\n        },\n        trace: {\n            level: 'Debug',\n            processor: (message, data) => this.trace(message, data)\n        },\n        warn: {\n            level: 'Warning',\n            nullByPass: true\n        }\n    };\n\n    public init(messagePublisher: IMessagePublisher) {\n        tracing.on(NOTIFY_CONSOLE_EVENT_OCCURED, (event: IProxyEvent) => {\n            const data: IConsoleEvent = event.data;\n\n            const payload: IConsoleData = {\n                method: data.method,\n                arguments: data.arguments,\n                offset: event.offset\n            };\n\n            this.publishMessage(messagePublisher, payload);\n        });\n    }\n\n    private publishMessage(messagePublisher: IMessagePublisher, data: IConsoleData) {\n        const info = this.methods[data.method];\n\n        // in the case where we have no args or a nullByPass is in effect then we shouldn't log messages\n        if (!data.arguments || data.arguments.constructor !== Array || (info.nullByPass && data.arguments.length === 0)) {\n            return;\n        }\n\n        // build base message\n        const payload = {\n            message: data.arguments,\n            library: 'Browser Console',\n            level: info.level\n        };\n        const message = messagePublisher.createMessage('log-write', payload);\n        addOffset(data.offset, message);\n\n        // run through any custom processors\n        let suppressMessage = false;\n        if (info.processor) {\n            suppressMessage = info.processor(message, data) || false;\n        }\n\n        // normalize token format\n        if (!info.tokenTypeByPass) {\n            this.deriveTokenType(message);\n        }\n\n        if (!suppressMessage) {\n            getStackTrace((frames) => {\n                message.payload.frames = frames;\n                message.types.push('call-stack');\n                messagePublisher.publishMessage(message);\n            });\n        }\n    }\n\n    // api specific targets\n\n    private count(message, data: IConsoleData) {\n        // chrome treats no args the same as ''\n        const label = data.arguments.length > 0 ? String(data.arguments[0]) : '';\n\n        // for record the label\n        message.payload.message = label;\n\n        // track ongoing progress\n        let currentCount = (this.countMap[label] || 0) + 1;\n        this.countMap[label] = currentCount;\n\n        // record the applyType\n        this.applyType(message, data, LogMessageTypes.count);\n\n        // record the addition count data\n        message.payload.count = currentCount;\n    }\n\n    private assert(message, data: IConsoleData) {\n        const assertion = data.arguments.length > 0 ? data.arguments[0] : false;\n        // if we have no args|null|undefined|0 we will treat it as a fail\n        if (assertion) {\n            return true;\n        }\n        else {\n            message.payload.message = message.payload.message.slice(1);\n        }\n    }\n\n    private dir(message, data: IConsoleData, type: LogMessageTypes) {\n        let newArgs: any = data.arguments.length > 0 ? [data.arguments[0]] : data.arguments; // tslint:disable-line:no-any\n\n        let processAsDir = false;\n\n        let value = newArgs[0];\n        if (type === LogMessageTypes.xml && value && typeof value === 'object' && value.getElementsByTagName && 'outerHTML' in value) {\n            const nodeCount = value.getElementsByTagName('*').length;\n            // Safety checks to deal with large data payloads\n            if (nodeCount > 100) {\n                newArgs = 'Node with more than `100` decendents aren\\'t supported.';\n            }\n            else {\n                value = value.outerHTML;\n                if (value.length > 2500) {\n                    newArgs = 'Node with more than `2500` characters aren\\'t supported.';\n                }\n                else {\n                    newArgs[0] = value;\n                }\n            }\n\n            processAsDir = true;\n        }\n        else if (type === LogMessageTypes.json) {\n            processAsDir = true;\n        }\n\n        // this is setup this way so that in non valid `LogMessageTypes.xml` cases, we essentually\n        // treat it as plain console.log\n        if (processAsDir) {\n            // we only care about the first arg in this case\n            message.payload.message = newArgs;\n\n            this.applyType(message, data, type);\n        }\n        else {\n            this.deriveTokenType(message);\n        }\n    }\n\n    private timeStamp(message, data: IConsoleData) {\n        this.getAndApplyLabel(message, data);\n    }\n\n    private groupStart(message, data: IConsoleData, isCollapsed: boolean) {\n        message.payload.isCollapsed = isCollapsed;\n\n        this.stackStart('group', message, data, LogMessageTypes.group_begin);\n    }\n\n    private groupEnd(message, data: IConsoleData) {\n        return this.stackEnd('group', message, data, LogMessageTypes.group_end);\n    }\n\n    private profileStart(message, data: IConsoleData) {\n        this.getAndApplyLabel(message, data);\n\n        this.stackStart('profile', message, data, LogMessageTypes.timespan_begin);\n    }\n\n    private profileEnd(message, data: IConsoleData) {\n        this.getAndApplyLabel(message, data);\n\n        const result = this.stackEnd('profile', message, data, LogMessageTypes.timespan_end);\n\n        return result;\n    }\n\n    private trace(message, data: IConsoleData) {\n        // for trace methods include 'log-display-callstack' message type so callstack will be displayed\n        message.types.push('log-display-callstack');\n\n        // make a copy of the message since we're going to modify it.\n        message.payload.message = Array.prototype.slice.call(message.payload.message, 0);\n        if (message.payload.message[0] === undefined) {\n            message.payload.message[0] = 'Trace:';\n        }\n        else {\n            message.payload.message[0] = 'Trace: ' + message.payload.message[0];\n        }\n    }\n\n    // common/shared helpers\n\n    private applyType(message, data: IConsoleData, mixin: LogMessageTypes) {\n        const type = LogMessageTypes[mixin].replace('_', '-');\n\n        message.types.push('log-' + type);\n    }\n\n    private getAndApplyLabel(message, data: IConsoleData) {\n        const label = data.arguments.length > 0 ? String(data.arguments[0]) : undefined;\n\n        // for mapEnds we dump the args and just use the label\n        message.payload.message = label;\n\n        return label;\n    }\n\n    private stackStart(type, message, data: IConsoleData, mixin: LogMessageTypes) {\n        const group = this.coreStart(message, data, mixin);\n\n        this.stack[type].push(group);\n    }\n\n    private stackEnd(type, message, data: IConsoleData, mixin: LogMessageTypes) {\n        const group = this.stack[type].pop();\n        if (group) {\n            this.coreEnd(group, message, data, mixin);\n        }\n        else {\n            return true;\n        }\n    }\n\n    private mapStart(type, message, data: IConsoleData, mixin: LogMessageTypes) {\n        const label = this.getAndApplyLabel(message, data);\n\n        const group = this.coreStart(message, data, mixin);\n\n        if (label !== undefined) {\n            this.map[type][label] = group;\n        }\n        else {\n            this.mapNull[type] = group;\n        }\n    }\n\n    private mapEnd(type, message, data: IConsoleData, mixin: LogMessageTypes) {\n        const label = this.getAndApplyLabel(message, data);\n\n        let group = label !== undefined ? this.map[type][label] : this.mapNull[type];\n        if (group) {\n            if (label !== undefined) {\n                delete this.map[type][label];\n            }\n            else {\n                this.mapNull[type] = undefined;\n            }\n        }\n        else {\n            // if no match is found we should match to page load\n            group = { correlationId: getGuid(), time: 0 };\n        }\n\n        this.coreEnd(group, message, data, mixin);\n    }\n\n    private coreStart(message, data: IConsoleData, mixin: LogMessageTypes) {\n        const correlationId = getGuid();\n        const time = data.offset;\n\n        addCorrelationBegin(correlationId, message);\n\n        // add action begin specific data\n        this.applyType(message, data, mixin);\n\n        return {\n            correlationId: correlationId,\n            time: time\n        };\n    }\n\n    private coreEnd(group, message, data: IConsoleData, mixin: LogMessageTypes) {\n        const time = data.offset;\n\n        // add action begin specific data\n        this.applyType(message, data, mixin);\n\n        addCorrelationEnd(group.correlationId, time - group.time, message);\n    }\n\n    private deriveTokenType(message) {\n        if (message.payload.message !== undefined\n            && message.payload.message !== null // tslint:disable-line:no-null-keyword\n            && message.payload.message !== 'string') {\n            message.types.push('log-token-printf');\n            message.payload.tokenSupport = 'browser';\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/inspectors/ConsoleInspector.ts","import { IProxy } from '../IProxy';\nimport tracing from '../Tracing';\n\nexport const NOTIFY_CONSOLE_EVENT_OCCURED = 'notify|event|console';\n\nexport interface IConsoleEvent {\n    method: string;\n    arguments: any[]; // tslint:disable-line:no-any\n}\n\ninterface ProxyFunction { (): any; __glimpse_original: any; } // tslint:disable-line:no-any\n\nexport class ConsoleProxy implements IProxy {\n    // NOTE: this should probably be pulled from the inspector,\n    //       but that raising a dependency question and whether\n    //       one should know about the other. Was thinking about\n    //       adding a neutral party but thats overkill.\n    public methods = [\n        'assert',\n        'count',\n        'debug',\n        'dir',\n        'dirxml',\n        'error',\n        'group',\n        'groupCollapsed',\n        'groupEnd',\n        'info',\n        'log',\n        'profile',\n        'profileEnd',\n        'table',\n        'time',\n        'timeEnd',\n        'timeStamp',\n        'trace',\n        'warn'\n    ];\n\n    public isSupported() {\n        // IE9 and older throws an exception if we try and write a value to\n        // an undefined preoprty on console methods, so we test here if we\n        // can write to `console.log`, and if not return not supported\n        try {\n            // tslint:disable-next-line:no-any\n            (<any>console.log).__glimpse_enabled = true;\n            // tslint:disable-next-line:no-any\n            delete (<any>console.log).__glimpse_enabled;\n        } catch (e) {\n            return false;\n        }\n        return !!(window && typeof window.console !== 'undefined');\n    }\n\n    public init() {\n        this.methods.forEach((methodKey) => {\n            if (methodKey && console[methodKey] && !console[methodKey].__glimpse_original) {\n                console[methodKey] = (function (key) {\n                    const oldFunction = console[key];\n\n                    const newFunction = <ProxyFunction>function () {\n                        const args = Array.prototype.slice.call(arguments);\n\n                        tracing.publish(NOTIFY_CONSOLE_EVENT_OCCURED, { method: key, arguments: args });\n\n                        return oldFunction.apply(this, arguments);\n                    };\n\n                    oldFunction.__glimpse_proxy = newFunction;\n                    newFunction.__glimpse_original = oldFunction;\n\n                    return newFunction;\n                }(methodKey));\n            }\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/tracing/proxies/ConsoleProxy.ts","import { IInspector } from './IInspector';\nimport { IMessagePublisher } from '../MessagePublisher';\nimport { IProxyEvent } from '../tracing/IProxyEvent';\nimport tracing from '../tracing/Tracing';\nimport {\n  IPerformanceMarkEvent, EVENT_PERFORMANCE_MARK,\n  IPerformanceMeasureEvent, EVENT_PERFORMANCE_MEASURE\n} from '../tracing/proxies/PerformanceProxy';\nimport { addOffset } from '../common/MessageMixins';\nimport { getStackTrace, IStackFrame } from '../common/CallStackUtilities';\n\nexport class PerformanceInspector implements IInspector {\n\n    private messagePublisher: IMessagePublisher;\n\n    private markIdCache: { [ id: string ]: string } = {};\n\n    public init(messagePublisher: IMessagePublisher) {\n        this.messagePublisher = messagePublisher;\n        tracing.on(EVENT_PERFORMANCE_MARK, (data) => this.mark(data));\n        tracing.on(EVENT_PERFORMANCE_MEASURE, (data) => this.measure(data));\n    }\n\n    private mark(data: IProxyEvent) {\n        const eventData: IPerformanceMarkEvent = data.data;\n        const message = this.messagePublisher.createMessage('debug-timestamp', {\n            name: eventData.name\n        });\n\n        // Save the internal ID <> message ID correlation for lookup in measure\n        // events. We do this two stage caching level so that proxies don't need\n        // to know anything about the details of how message IDs work.\n        this.markIdCache[eventData.id] = message.id;\n\n        // Override the message offset directly. We override it manually instead\n        // of using `addOffset` because that method adjust the offset we pass to\n        // be relative to `performance.timing.requestStart - performance.timing.fetchStart`\n        // however the offsets we receive here are from performance.timing, so they\n        // are already relative to the proper time, and so shouldn't be adjusted\n        message.offset = eventData.startTime;\n\n        // If the mark is a built-in mark, then we skip collecting the stack trace\n        // because there is no actual stack trace associated with the mark\n        if (eventData.isBuiltIn) {\n            // Wrap the publish in a set timeout to make the asynchronicity\n            // of this method consistent across different event configurations\n            setTimeout(() => this.messagePublisher.publishMessage(message), 0);\n        } else {\n            // We create the message first, and add frames later, to ensure that\n            // the mark ID cache is filled and waiting when `performance.measure`\n            // is called, which may occur before the getStackTrace callback is\n            // called.\n            getStackTrace((frames: IStackFrame[]) => {\n                message.payload.frames = frames;\n                this.messagePublisher.publishMessage(message);\n            });\n        }\n    }\n\n    private measure(data: IProxyEvent) {\n        const eventData: IPerformanceMeasureEvent = data.data;\n\n        const startMarkMessageId = this.markIdCache[eventData.startMarkId];\n        const endMarkMessageId = this.markIdCache[eventData.endMarkId];\n\n        const message = this.messagePublisher.createMessage('debug-timestamp-measurement', {\n            correlationMessageIds: [ startMarkMessageId, endMarkMessageId ],\n            category: 'duration',\n            name: eventData.name\n        });\n        addOffset(data.offset, message);\n\n        this.messagePublisher.publishMessage(message);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/inspectors/PerformanceInspector.ts","import { IProxy } from '../IProxy';\nimport tracing from '../Tracing';\nimport performance from '../../common/PerformanceUtilities';\nimport { getGuid } from '../../common/GeneralUtilities';\n\n/**\n * This event indicates that `performance.mark()` was called.\n *\n * @property {string} id - a globally unique identifier\n * @property {string} name - The name of the mark\n * @property {string} startTime - The start time of the mark, as indicated by\n *      by a call to `performance.getEntriesByName(name)\n * @property {boolean} isBuiltIn - Whether or not this mark was explicitly\n *      created by the user, or if it was generated automatically by the browser\n */\nexport interface IPerformanceMarkEvent {\n    id: string;\n    name: string;\n    startTime: number;\n    isBuiltIn: boolean;\n}\nexport const EVENT_PERFORMANCE_MARK = 'invoke|post|performance.mark';\n\n/**\n * This event indicates that `performance.measure()` was called. The mark entries\n * supplied with this event are normalized. If a mark event is an \"implicit\" event,\n * e.g. it came from `performance.timing` instead of `performance.mark()`, then\n * a synthetic IPerformanceMarkEvent is created to represent it.\n *\n * @property {string} name - The name of the measure\n * @property {number} startTime - The time that measure was called\n * @property {object} startMark - The start mark event\n * @property {object} endMark - The end mark event\n */\nexport interface IPerformanceMeasureEvent {\n    name: string;\n    startMarkId: string;\n    endMarkId: string;\n}\nexport const EVENT_PERFORMANCE_MEASURE = 'invoke|post|performance.measure';\n\nlet measureIdCount = 1;\n\ninterface IPerformanceEntry {\n    name: string;\n    entryType: string;\n    startTime: number;\n    duration: number;\n}\n\nexport class PerformanceProxy implements IProxy {\n    private markIdCache: { [ name: string ]: string } = {};\n\n    private oldMeasure: (name: string, start: string, end: string) => void;\n\n    private getMarkId(name: string): string {\n\n        // Check if we have a cached mark entry, and if so, return it\n        if (this.markIdCache[name]) {\n            return this.markIdCache[name];\n        }\n\n        // If we got here, then that means there is not a cached mark entry,\n        // meaning we haven't seen the mark before. This can happen for two reasons:\n        // 1) The name is not a known mark name. Technically it shouldn't ever\n        //    get to this method, because `performance.measure` will throw first\n        // 2) The name is a built-in performance timing mark that the browser\n        //    generated on page load. These are stored in `performance.timing`\n\n        // This checks if we have a built-in `performance.timing` mark. If\n        // we do have a built in `performance.timing` mark, we create a mark\n        // message for this retroactively and publish a mark event. Note:\n        // if this built in mark was already referenced, it will be in the\n        // cache, meaning that this code will not be run twice for the same mark\n        if (performance.timing[name]) {\n\n            // We do a little hack here to get the `startTime` of the entry\n            // by measuring this mark against itself and getting the\n            // resulting performance entry\n            const tempMeasureName = `__glimpse_measure-${measureIdCount++}`;\n            this.oldMeasure.call(performance, tempMeasureName, name, name);\n            const tempMeasureEntry = this.getPerformanceEntryByName(tempMeasureName);\n\n            const eventData = this.initializeMark(name, tempMeasureEntry.startTime, true);\n\n            // We clear the measure entry now so we can keep the `performance.getEntries`\n            // history clean for users who want to query performance entries\n            performance.clearMeasures(tempMeasureName);\n\n            tracing.publish(EVENT_PERFORMANCE_MARK, eventData);\n            return eventData.id;\n        }\n\n        // If we got here, then it means the mark name is not valid. We _shouldn't_\n        // ever get here, because the browser's native `performance.measure` method\n        // will throw if the name is not know before this method is called.\n        return undefined;\n    }\n\n    private getPerformanceEntryByName(name: string): IPerformanceEntry {\n        return performance.getEntriesByName(name).pop();\n    }\n\n    private initializeMark(name: string, startTime: number, isBuiltIn: boolean): IPerformanceMarkEvent {\n        const id = getGuid();\n        const eventData: IPerformanceMarkEvent = {\n            id,\n            name,\n            startTime,\n            isBuiltIn\n        };\n\n        // We only need to store the newest ID in the cache because `performance.measure`\n        // always grabs the newest mark with a given name. For more info, see\n        // https://www.w3.org/TR/user-timing/#dom-performance-measure\n        this.markIdCache[name] = id;\n        return eventData;\n    }\n\n    private instrumentMark() {\n        const oldMark = performance.mark;\n        const self = this;\n        performance.mark = function mark(name, ...args) {\n            oldMark.call(this, name, ...args);\n            const performanceEntry = self.getPerformanceEntryByName(name);\n            const eventData = self.initializeMark(performanceEntry.name, performanceEntry.startTime, false);\n            tracing.publish(EVENT_PERFORMANCE_MARK, eventData);\n        };\n    }\n\n    private instrumentMeasure() {\n        this.oldMeasure = performance.measure;\n        const self = this;\n        performance.measure = function measure(name, startMark, endMark, ...args) {\n            self.oldMeasure.call(this, name, startMark, endMark, ...args);\n            const startMarkId = self.getMarkId(startMark);\n            const endMarkId = self.getMarkId(endMark);\n            if (startMarkId && endMarkId) {\n                const eventData: IPerformanceMeasureEvent = {\n                    name,\n                    startMarkId,\n                    endMarkId\n                };\n                tracing.publish(EVENT_PERFORMANCE_MEASURE, eventData);\n            }\n        };\n    }\n\n    public isSupported(): boolean {\n        return !!(performance && performance.getEntriesByName);\n    }\n\n    public init() {\n        if (performance.mark) {\n            this.instrumentMark();\n        }\n        if (performance.measure) {\n            this.instrumentMeasure();\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/tracing/proxies/PerformanceProxy.ts","import { IProxyClass } from './IProxy';\nimport { XHRProxy } from './proxies/XHRProxy';\nimport { FetchProxy } from './proxies/FetchProxy';\nimport { ResourceTimingProxy } from './proxies/ResourceTimingProxy';\nimport { NavigationTimingProxy } from './proxies/NavigationTimingProxy';\nimport { ConsoleProxy } from './proxies/ConsoleProxy';\nimport { PerformanceProxy } from './proxies/PerformanceProxy';\n\nconst proxies: { [proxyName: string]: IProxyClass } = {\n    XHRProxy,\n    FetchProxy,\n    ResourceTimingProxy,\n    NavigationTimingProxy,\n    ConsoleProxy,\n    PerformanceProxy\n};\n\nexport default function initializeProxies(): void {\n    for (const proxyName in proxies) {\n        if (proxies.hasOwnProperty(proxyName)) {\n            const proxy = new proxies[proxyName];\n\n            // Only initiate (attach) proxies if they are\n            // able to be used in the client.\n            if (proxy.isSupported()) {\n                proxy.init();\n            }\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/tracing/initializeProxies.ts"],"sourceRoot":""}