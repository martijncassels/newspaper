'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var http = require("http");
var https = require("https");
var glimpse_common_1 = require("@glimpse/glimpse-common");
function setupProxy() {
    // Note: http.createServer and https.createServer have different signatures,
    // so we do each one separately here to keep things simple, even if there is
    // some duplicated code
    var oldHttpCreateServer = http.createServer;
    // tslint:disable-next-line:no-any
    http.createServer = function createServer() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var callback;
        if (args.length && typeof args[0] === 'function') {
            callback = args[0];
            args.splice(0, 1);
        }
        // NOTE: The callback is not passed through to the old createServer() (as it's added later).
        var server = oldHttpCreateServer.apply(this, args);
        patchServer(server, callback, 'http');
        return server;
    };
    var oldHttpsCreateServer = https.createServer;
    // tslint:disable-next-line:no-any
    https.createServer = function createServer(options) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var callback;
        if (args.length && typeof args[0] === 'function') {
            callback = args[0];
            args.splice(0, 1);
        }
        // NOTE: The callback is not passed through to the old createServer() (as it's added later).
        var server = oldHttpsCreateServer.call.apply(oldHttpsCreateServer, [this, options].concat(args));
        patchServer(server, callback, 'https');
        return server;
    };
}
exports.setupProxy = setupProxy;
;
function buildApp() {
    // NOTE: Express provides wrappers around http for starting the web server. If used,
    //       apps may not otherwise import http themselves. In that case, the only mechanism
    //       for importing http (and thereby initializing the Glimpse proxy), is importing
    //       express. Since the server uses Express itself and is initialized before the
    //       agent, it needs to defer importing express until after agent initialization.
    //       This ensures that the first import of Express is done by the app itself and
    //       after all of the proxies have been registered.
    var express = require('express');
    var glimpse = require('../routes/glimpse');
    var app = express();
    app.use(function (req, res, next) {
        /* eslint-disable camelcase */
        req.__glimpse_inProcessServerRequest = true;
        res.__glimpse_inProcessServerResponse = true;
        /* eslint-enable camelcase */
        next();
    });
    app.use('/glimpse', glimpse);
    return app;
}
;
function patchServerOn(server, app) {
    var oldOn = server.on;
    server.on = function glimpseServerOn(eventName, listener) {
        var onArgs = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            onArgs[_i - 2] = arguments[_i];
        }
        if (eventName === 'request') {
            var oldListener_1 = listener;
            listener = function (req, res) {
                var glimpseReq = req;
                // Express `request` handlers will alter the `res.url`, so we maintain our own "original" URL...
                if (!glimpseReq.__glimpse_originalUrl) {
                    glimpseReq.__glimpse_originalUrl = glimpseReq.url;
                }
                var isGlimpseEndpoint = glimpseReq.__glimpse_originalUrl.indexOf('/glimpse') === 0;
                var isGlimpseEndpointHandler = oldListener_1 === app;
                // Only invoke the listener:
                //   If it's the Glimpse listener *and* the request is for a Glimpse endpoint.
                //     - or -
                //   If it's not the Glimpse listener *and* the request is for an application (i.e. non-Glimpse) endpoint.
                if ((isGlimpseEndpoint && isGlimpseEndpointHandler) || (!isGlimpseEndpoint && !isGlimpseEndpointHandler)) {
                    return oldListener_1(req, res);
                }
            };
        }
        return oldOn.call.apply(oldOn, [this, eventName, listener].concat(onArgs));
    };
}
function patchServer(server, callback, protocol) {
    var app = buildApp();
    patchServerOn(server, app);
    server.on('request', app);
    // If specified, attach the callback originally passed to createServer()...
    if (callback) {
        server.on('request', callback);
    }
    server.on('listening', function () {
        glimpse_common_1.printBannerGreeting(protocol + "://localhost:" + server.address().port + "/glimpse/client");
    });
}

//# sourceMappingURL=../../../maps/src/hosting/host-express.js.map
